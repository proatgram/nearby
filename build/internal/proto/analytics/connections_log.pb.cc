// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: internal/proto/analytics/connections_log.proto

#include "internal/proto/analytics/connections_log.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace location {
namespace nearby {
namespace analytics {
namespace proto {
PROTOBUF_CONSTEXPR ConnectionsLog_ClientSession::ConnectionsLog_ClientSession(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.strategy_session_)*/{}
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}
} {}
struct ConnectionsLog_ClientSessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_ClientSessionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_ClientSessionDefaultTypeInternal() {}
  union {
    ConnectionsLog_ClientSession _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_ClientSessionDefaultTypeInternal _ConnectionsLog_ClientSession_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_StrategySession::ConnectionsLog_StrategySession(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.role_)*/ {}

  , /*decltype(_impl_.discovery_phase_)*/{}
  , /*decltype(_impl_.advertising_phase_)*/{}
  , /*decltype(_impl_.connection_attempt_)*/{}
  , /*decltype(_impl_.established_connection_)*/{}
  , /*decltype(_impl_.upgrade_attempt_)*/{}
  , /*decltype(_impl_.build_version_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.strategy_)*/ 0
} {}
struct ConnectionsLog_StrategySessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_StrategySessionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_StrategySessionDefaultTypeInternal() {}
  union {
    ConnectionsLog_StrategySession _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_StrategySessionDefaultTypeInternal _ConnectionsLog_StrategySession_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_DiscoveryPhase::ConnectionsLog_DiscoveryPhase(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.medium_)*/ {}

  , /*decltype(_impl_.discovered_endpoint_)*/{}
  , /*decltype(_impl_.sent_connection_request_)*/{}
  , /*decltype(_impl_.uwb_ranging_)*/{}
  , /*decltype(_impl_.discovery_metadata_)*/nullptr
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.client_flow_id_)*/ ::int64_t{0}
} {}
struct ConnectionsLog_DiscoveryPhaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_DiscoveryPhaseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_DiscoveryPhaseDefaultTypeInternal() {}
  union {
    ConnectionsLog_DiscoveryPhase _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_DiscoveryPhaseDefaultTypeInternal _ConnectionsLog_DiscoveryPhase_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_DiscoveredEndpoint::ConnectionsLog_DiscoveredEndpoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latency_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.medium_)*/ 0
} {}
struct ConnectionsLog_DiscoveredEndpointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_DiscoveredEndpointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_DiscoveredEndpointDefaultTypeInternal() {}
  union {
    ConnectionsLog_DiscoveredEndpoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_DiscoveredEndpointDefaultTypeInternal _ConnectionsLog_DiscoveredEndpoint_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_UwbRangingProcess::ConnectionsLog_UwbRangingProcess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uwb_ranging_data_)*/{}
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.number_of_ranging_data_)*/ 0

  , /*decltype(_impl_.distance_min_)*/ 0

  , /*decltype(_impl_.distance_max_)*/ 0

  , /*decltype(_impl_.distance_ave_)*/ 0

  , /*decltype(_impl_.distance_variance_)*/ 0

  , /*decltype(_impl_.azimuth_min_)*/ 0

  , /*decltype(_impl_.azimuth_max_)*/ 0

  , /*decltype(_impl_.azimuth_ave_)*/ 0

  , /*decltype(_impl_.azimuth_variance_)*/ 0
} {}
struct ConnectionsLog_UwbRangingProcessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_UwbRangingProcessDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_UwbRangingProcessDefaultTypeInternal() {}
  union {
    ConnectionsLog_UwbRangingProcess _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_UwbRangingProcessDefaultTypeInternal _ConnectionsLog_UwbRangingProcess_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_RawUwbRangingEvent::ConnectionsLog_RawUwbRangingEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.distance_)*/ 0

  , /*decltype(_impl_.azimuth_angle_)*/ 0

  , /*decltype(_impl_.polar_angle_)*/ 0
} {}
struct ConnectionsLog_RawUwbRangingEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_RawUwbRangingEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_RawUwbRangingEventDefaultTypeInternal() {}
  union {
    ConnectionsLog_RawUwbRangingEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_RawUwbRangingEventDefaultTypeInternal _ConnectionsLog_RawUwbRangingEvent_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_AdvertisingPhase::ConnectionsLog_AdvertisingPhase(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.medium_)*/ {}

  , /*decltype(_impl_.received_connection_request_)*/{}
  , /*decltype(_impl_.advertising_metadata_)*/nullptr
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.client_flow_id_)*/ ::int64_t{0}
} {}
struct ConnectionsLog_AdvertisingPhaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_AdvertisingPhaseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_AdvertisingPhaseDefaultTypeInternal() {}
  union {
    ConnectionsLog_AdvertisingPhase _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_AdvertisingPhaseDefaultTypeInternal _ConnectionsLog_AdvertisingPhase_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_ConnectionRequest::ConnectionsLog_ConnectionRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.request_delay_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.local_response_)*/ 0

  , /*decltype(_impl_.remote_response_)*/ 0

  , /*decltype(_impl_.client_flow_id_)*/ ::int64_t{0}
} {}
struct ConnectionsLog_ConnectionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_ConnectionRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_ConnectionRequestDefaultTypeInternal() {}
  union {
    ConnectionsLog_ConnectionRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_ConnectionRequestDefaultTypeInternal _ConnectionsLog_ConnectionRequest_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_ConnectionAttempt::ConnectionsLog_ConnectionAttempt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.connection_token_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.connection_attempt_metadata_)*/nullptr
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_.direction_)*/ 0

  , /*decltype(_impl_.medium_)*/ 0

  , /*decltype(_impl_.attempt_result_)*/ 0

  , /*decltype(_impl_.client_flow_id_)*/ ::int64_t{0}
} {}
struct ConnectionsLog_ConnectionAttemptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_ConnectionAttemptDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_ConnectionAttemptDefaultTypeInternal() {}
  union {
    ConnectionsLog_ConnectionAttempt _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_ConnectionAttemptDefaultTypeInternal _ConnectionsLog_ConnectionAttempt_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_EstablishedConnection::ConnectionsLog_EstablishedConnection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sent_payload_)*/{}
  , /*decltype(_impl_.received_payload_)*/{}
  , /*decltype(_impl_.connection_token_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.medium_)*/ 0

  , /*decltype(_impl_.disconnection_reason_)*/ 0

  , /*decltype(_impl_.client_flow_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_.safe_disconnection_result_)*/ 0
} {}
struct ConnectionsLog_EstablishedConnectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_EstablishedConnectionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_EstablishedConnectionDefaultTypeInternal() {}
  union {
    ConnectionsLog_EstablishedConnection _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_EstablishedConnectionDefaultTypeInternal _ConnectionsLog_EstablishedConnection_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_Payload::ConnectionsLog_Payload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.total_size_bytes_)*/ ::int64_t{0}

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_.num_chunks_)*/ 0

  , /*decltype(_impl_.num_bytes_transferred_)*/ ::int64_t{0}

  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_.num_successful_auto_resume_)*/ 0
} {}
struct ConnectionsLog_PayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_PayloadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_PayloadDefaultTypeInternal() {}
  union {
    ConnectionsLog_Payload _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_PayloadDefaultTypeInternal _ConnectionsLog_Payload_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_BandwidthUpgradeAttempt::ConnectionsLog_BandwidthUpgradeAttempt(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.connection_token_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.duration_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.direction_)*/ 0

  , /*decltype(_impl_.from_medium_)*/ 0

  , /*decltype(_impl_.to_medium_)*/ 0

  , /*decltype(_impl_.upgrade_result_)*/ 0

  , /*decltype(_impl_.client_flow_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.error_stage_)*/ 0
} {}
struct ConnectionsLog_BandwidthUpgradeAttemptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_BandwidthUpgradeAttemptDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_BandwidthUpgradeAttemptDefaultTypeInternal() {}
  union {
    ConnectionsLog_BandwidthUpgradeAttempt _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_BandwidthUpgradeAttemptDefaultTypeInternal _ConnectionsLog_BandwidthUpgradeAttempt_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_ErrorCode::ConnectionsLog_ErrorCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.service_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.connection_token_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.direction_)*/ 0

  , /*decltype(_impl_.medium_)*/ 0

  , /*decltype(_impl_.event_)*/ 0

  , /*decltype(_impl_.description_)*/ 0

  , /*decltype(_impl_.flow_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.ErrorCodeDetail_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ConnectionsLog_ErrorCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_ErrorCodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_ErrorCodeDefaultTypeInternal() {}
  union {
    ConnectionsLog_ErrorCode _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_ErrorCodeDefaultTypeInternal _ConnectionsLog_ErrorCode_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_AdvertisingMetadata::ConnectionsLog_AdvertisingMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.connected_ap_frequency_)*/ 0

  , /*decltype(_impl_.supports_extended_ble_advertisements_)*/ false

  , /*decltype(_impl_.supports_nfc_technology_)*/ false

  , /*decltype(_impl_.multiple_advertisement_supported_)*/ false

  , /*decltype(_impl_.power_level_)*/ -1
} {}
struct ConnectionsLog_AdvertisingMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_AdvertisingMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_AdvertisingMetadataDefaultTypeInternal() {}
  union {
    ConnectionsLog_AdvertisingMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_AdvertisingMetadataDefaultTypeInternal _ConnectionsLog_AdvertisingMetadata_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_DiscoveryMetadata::ConnectionsLog_DiscoveryMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.connected_ap_frequency_)*/ 0

  , /*decltype(_impl_.supports_extended_ble_advertisements_)*/ false

  , /*decltype(_impl_.supports_nfc_technology_)*/ false

  , /*decltype(_impl_.power_level_)*/ -1
} {}
struct ConnectionsLog_DiscoveryMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_DiscoveryMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_DiscoveryMetadataDefaultTypeInternal() {}
  union {
    ConnectionsLog_DiscoveryMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_DiscoveryMetadataDefaultTypeInternal _ConnectionsLog_DiscoveryMetadata_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog_ConnectionAttemptMetadata::ConnectionsLog_ConnectionAttemptMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.network_operator_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.country_code_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.technology_)*/ 0

  , /*decltype(_impl_.band_)*/ 0

  , /*decltype(_impl_.frequency_)*/ 0

  , /*decltype(_impl_.try_counts_)*/ 0

  , /*decltype(_impl_.max_tx_speed_)*/ 0

  , /*decltype(_impl_.is_tdls_used_)*/ false

  , /*decltype(_impl_.wifi_hotspot_status_)*/ false

  , /*decltype(_impl_.is_mcc_mode_)*/ false

  , /*decltype(_impl_.max_rx_speed_)*/ 0

  , /*decltype(_impl_.wifi_channel_width_)*/ 0

  , /*decltype(_impl_.send_buffer_size_)*/ 0

  , /*decltype(_impl_.receive_buffer_size_)*/ 0

  , /*decltype(_impl_.connected_ap_frequency_)*/ 0
} {}
struct ConnectionsLog_ConnectionAttemptMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLog_ConnectionAttemptMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLog_ConnectionAttemptMetadataDefaultTypeInternal() {}
  union {
    ConnectionsLog_ConnectionAttemptMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLog_ConnectionAttemptMetadataDefaultTypeInternal _ConnectionsLog_ConnectionAttemptMetadata_default_instance_;
PROTOBUF_CONSTEXPR ConnectionsLog::ConnectionsLog(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.version_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.files_migration_phase_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.client_session_)*/nullptr
  , /*decltype(_impl_.error_code_)*/nullptr
  , /*decltype(_impl_.event_type_)*/ 0

  , /*decltype(_impl_.log_source_)*/ 0
} {}
struct ConnectionsLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionsLogDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionsLogDefaultTypeInternal() {}
  union {
    ConnectionsLog _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionsLogDefaultTypeInternal _ConnectionsLog_default_instance_;
}  // namespace proto
}  // namespace analytics
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace analytics {
namespace proto {
bool ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_strings[3] = {};

static const char ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_names[] = {
    "SAFE_DISCONNECTION"
    "UNKNOWN_SAFE_DISCONNECTION_RESULT"
    "UNSAFE_DISCONNECTION"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries[] =
    {
        {{&ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_names[0], 18}, 1},
        {{&ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_names[18], 33}, 0},
        {{&ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_names[51], 20}, 2},
};

static const int ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries_by_number[] = {
    1,  // 0 -> UNKNOWN_SAFE_DISCONNECTION_RESULT
    0,  // 1 -> SAFE_DISCONNECTION
    2,  // 2 -> UNSAFE_DISCONNECTION
};

const std::string& ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_Name(ConnectionsLog_EstablishedConnection_SafeDisconnectionResult value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries, ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries_by_number,
          3, ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries, ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries_by_number, 3,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_strings[idx].get();
}

bool ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_Parse(absl::string_view name, ConnectionsLog_EstablishedConnection_SafeDisconnectionResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionsLog_EstablishedConnection_SafeDisconnectionResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ConnectionsLog_EstablishedConnection_SafeDisconnectionResult ConnectionsLog_EstablishedConnection::UNKNOWN_SAFE_DISCONNECTION_RESULT;
constexpr ConnectionsLog_EstablishedConnection_SafeDisconnectionResult ConnectionsLog_EstablishedConnection::SAFE_DISCONNECTION;
constexpr ConnectionsLog_EstablishedConnection_SafeDisconnectionResult ConnectionsLog_EstablishedConnection::UNSAFE_DISCONNECTION;
constexpr ConnectionsLog_EstablishedConnection_SafeDisconnectionResult ConnectionsLog_EstablishedConnection::SafeDisconnectionResult_MIN;
constexpr ConnectionsLog_EstablishedConnection_SafeDisconnectionResult ConnectionsLog_EstablishedConnection::SafeDisconnectionResult_MAX;
constexpr int ConnectionsLog_EstablishedConnection::SafeDisconnectionResult_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class ConnectionsLog_ClientSession::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_ClientSession>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_ClientSession, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConnectionsLog_ClientSession::ConnectionsLog_ClientSession(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
}
ConnectionsLog_ClientSession::ConnectionsLog_ClientSession(const ConnectionsLog_ClientSession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_ClientSession* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strategy_session_){from._impl_.strategy_session_}
    , decltype(_impl_.duration_millis_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
}

inline void ConnectionsLog_ClientSession::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strategy_session_){arena}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

  };
}

ConnectionsLog_ClientSession::~ConnectionsLog_ClientSession() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_ClientSession::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_strategy_session()->~RepeatedPtrField();
}

void ConnectionsLog_ClientSession::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_ClientSession::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_strategy_session()->Clear();
  _impl_.duration_millis_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_ClientSession::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.StrategySession strategy_session = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_strategy_session(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_ClientSession::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.StrategySession strategy_session = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_strategy_session_size()); i < n; i++) {
    const auto& repfield = this->_internal_strategy_session(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  return target;
}

::size_t ConnectionsLog_ClientSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.analytics.proto.ConnectionsLog.StrategySession strategy_session = 2;
  total_size += 1UL * this->_internal_strategy_session_size();
  for (const auto& msg : this->_internal_strategy_session()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 duration_millis = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_duration_millis());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_ClientSession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_ClientSession*>(
      &from));
}

void ConnectionsLog_ClientSession::MergeFrom(const ConnectionsLog_ClientSession& from) {
  ConnectionsLog_ClientSession* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_strategy_session()->MergeFrom(from._internal_strategy_session());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_duration_millis(from._internal_duration_millis());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_ClientSession::CopyFrom(const ConnectionsLog_ClientSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.ClientSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_ClientSession::IsInitialized() const {
  return true;
}

void ConnectionsLog_ClientSession::InternalSwap(ConnectionsLog_ClientSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_strategy_session()->InternalSwap(other->_internal_mutable_strategy_session());

  swap(_impl_.duration_millis_, other->_impl_.duration_millis_);
}

std::string ConnectionsLog_ClientSession::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.ClientSession";
}

// ===================================================================

class ConnectionsLog_StrategySession::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_StrategySession>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_StrategySession, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_build_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConnectionsLog_StrategySession::ConnectionsLog_StrategySession(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
}
ConnectionsLog_StrategySession::ConnectionsLog_StrategySession(const ConnectionsLog_StrategySession& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_StrategySession* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_) { from._internal_role() }

    , decltype(_impl_.discovery_phase_){from._impl_.discovery_phase_}
    , decltype(_impl_.advertising_phase_){from._impl_.advertising_phase_}
    , decltype(_impl_.connection_attempt_){from._impl_.connection_attempt_}
    , decltype(_impl_.established_connection_){from._impl_.established_connection_}
    , decltype(_impl_.upgrade_attempt_){from._impl_.upgrade_attempt_}
    , decltype(_impl_.build_version_) {}

    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.strategy_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.build_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.build_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.build_version_.Set(from._internal_build_version(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.strategy_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.strategy_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
}

inline void ConnectionsLog_StrategySession::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.role_) { arena }

    , decltype(_impl_.discovery_phase_){arena}
    , decltype(_impl_.advertising_phase_){arena}
    , decltype(_impl_.connection_attempt_){arena}
    , decltype(_impl_.established_connection_){arena}
    , decltype(_impl_.upgrade_attempt_){arena}
    , decltype(_impl_.build_version_) {}

    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.strategy_) { 0 }

  };
  _impl_.build_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.build_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectionsLog_StrategySession::~ConnectionsLog_StrategySession() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_StrategySession::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_role()->~RepeatedField();
  _internal_mutable_discovery_phase()->~RepeatedPtrField();
  _internal_mutable_advertising_phase()->~RepeatedPtrField();
  _internal_mutable_connection_attempt()->~RepeatedPtrField();
  _internal_mutable_established_connection()->~RepeatedPtrField();
  _internal_mutable_upgrade_attempt()->~RepeatedPtrField();
  _impl_.build_version_.Destroy();
}

void ConnectionsLog_StrategySession::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_StrategySession::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_role()->Clear();
  _internal_mutable_discovery_phase()->Clear();
  _internal_mutable_advertising_phase()->Clear();
  _internal_mutable_connection_attempt()->Clear();
  _internal_mutable_established_connection()->Clear();
  _internal_mutable_upgrade_attempt()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.build_version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.strategy_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.strategy_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_StrategySession::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionsStrategy strategy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionsStrategy_IsValid(static_cast<int>(val)))) {
            _internal_set_strategy(static_cast<::location::nearby::proto::connections::ConnectionsStrategy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.proto.connections.SessionRole role = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::SessionRole_IsValid(static_cast<int>(val)))) {
              _internal_add_role(static_cast<::location::nearby::proto::connections::SessionRole>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_role(), ptr, ctx, ::location::nearby::proto::connections::SessionRole_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase discovery_phase = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_discovery_phase(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase advertising_phase = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_advertising_phase(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt connection_attempt = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_connection_attempt(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection established_connection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_established_connection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt upgrade_attempt = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_upgrade_attempt(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string build_version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_build_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_StrategySession::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionsStrategy strategy = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_strategy(), target);
  }

  // repeated .location.nearby.proto.connections.SessionRole role = 3;
  for (int i = 0, n = this->_internal_role_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_role(i), target);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase discovery_phase = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_discovery_phase_size()); i < n; i++) {
    const auto& repfield = this->_internal_discovery_phase(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase advertising_phase = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_advertising_phase_size()); i < n; i++) {
    const auto& repfield = this->_internal_advertising_phase(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt connection_attempt = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_connection_attempt_size()); i < n; i++) {
    const auto& repfield = this->_internal_connection_attempt(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection established_connection = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_established_connection_size()); i < n; i++) {
    const auto& repfield = this->_internal_established_connection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt upgrade_attempt = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_upgrade_attempt_size()); i < n; i++) {
    const auto& repfield = this->_internal_upgrade_attempt(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string build_version = 10;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_build_version();
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  return target;
}

::size_t ConnectionsLog_StrategySession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.proto.connections.SessionRole role = 3;
  {
    std::size_t data_size = 0;
    auto count = static_cast<std::size_t>(this->_internal_role_size());

    for (std::size_t i = 0; i < count; ++i) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
          this->_internal_role(static_cast<int>(i)));
    }
    total_size += data_size;
    total_size += std::size_t{1} * count;
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase discovery_phase = 4;
  total_size += 1UL * this->_internal_discovery_phase_size();
  for (const auto& msg : this->_internal_discovery_phase()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase advertising_phase = 5;
  total_size += 1UL * this->_internal_advertising_phase_size();
  for (const auto& msg : this->_internal_advertising_phase()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt connection_attempt = 6;
  total_size += 1UL * this->_internal_connection_attempt_size();
  for (const auto& msg : this->_internal_connection_attempt()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection established_connection = 7;
  total_size += 1UL * this->_internal_established_connection_size();
  for (const auto& msg : this->_internal_established_connection()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt upgrade_attempt = 9;
  total_size += 1UL * this->_internal_upgrade_attempt_size();
  for (const auto& msg : this->_internal_upgrade_attempt()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string build_version = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_build_version());
    }

    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional .location.nearby.proto.connections.ConnectionsStrategy strategy = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_strategy());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_StrategySession::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_StrategySession*>(
      &from));
}

void ConnectionsLog_StrategySession::MergeFrom(const ConnectionsLog_StrategySession& from) {
  ConnectionsLog_StrategySession* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_role()->MergeFrom(from._internal_role());
  _this->_internal_mutable_discovery_phase()->MergeFrom(from._internal_discovery_phase());
  _this->_internal_mutable_advertising_phase()->MergeFrom(from._internal_advertising_phase());
  _this->_internal_mutable_connection_attempt()->MergeFrom(from._internal_connection_attempt());
  _this->_internal_mutable_established_connection()->MergeFrom(from._internal_established_connection());
  _this->_internal_mutable_upgrade_attempt()->MergeFrom(from._internal_upgrade_attempt());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_build_version(from._internal_build_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.strategy_ = from._impl_.strategy_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_StrategySession::CopyFrom(const ConnectionsLog_StrategySession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.StrategySession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_StrategySession::IsInitialized() const {
  return true;
}

void ConnectionsLog_StrategySession::InternalSwap(ConnectionsLog_StrategySession* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_role()->InternalSwap(
      other->_internal_mutable_role());
  _internal_mutable_discovery_phase()->InternalSwap(other->_internal_mutable_discovery_phase());
  _internal_mutable_advertising_phase()->InternalSwap(other->_internal_mutable_advertising_phase());
  _internal_mutable_connection_attempt()->InternalSwap(other->_internal_mutable_connection_attempt());
  _internal_mutable_established_connection()->InternalSwap(other->_internal_mutable_established_connection());
  _internal_mutable_upgrade_attempt()->InternalSwap(other->_internal_mutable_upgrade_attempt());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.build_version_, lhs_arena,
                                       &other->_impl_.build_version_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_StrategySession, _impl_.strategy_)
      + sizeof(ConnectionsLog_StrategySession::_impl_.strategy_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_StrategySession, _impl_.duration_millis_)>(
          reinterpret_cast<char*>(&_impl_.duration_millis_),
          reinterpret_cast<char*>(&other->_impl_.duration_millis_));
}

std::string ConnectionsLog_StrategySession::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.StrategySession";
}

// ===================================================================

class ConnectionsLog_DiscoveryPhase::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_DiscoveryPhase>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveryPhase, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata& discovery_metadata(const ConnectionsLog_DiscoveryPhase* msg);
  static void set_has_discovery_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata&
ConnectionsLog_DiscoveryPhase::_Internal::discovery_metadata(const ConnectionsLog_DiscoveryPhase* msg) {
  return *msg->_impl_.discovery_metadata_;
}
ConnectionsLog_DiscoveryPhase::ConnectionsLog_DiscoveryPhase(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
}
ConnectionsLog_DiscoveryPhase::ConnectionsLog_DiscoveryPhase(const ConnectionsLog_DiscoveryPhase& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_DiscoveryPhase* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.medium_) { from._internal_medium() }

    , decltype(_impl_.discovered_endpoint_){from._impl_.discovered_endpoint_}
    , decltype(_impl_.sent_connection_request_){from._impl_.sent_connection_request_}
    , decltype(_impl_.uwb_ranging_){from._impl_.uwb_ranging_}
    , decltype(_impl_.discovery_metadata_){nullptr}
    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.client_flow_id_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.discovery_metadata_ = new ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata(*from._impl_.discovery_metadata_);
  }
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.client_flow_id_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
}

inline void ConnectionsLog_DiscoveryPhase::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.medium_) { arena }

    , decltype(_impl_.discovered_endpoint_){arena}
    , decltype(_impl_.sent_connection_request_){arena}
    , decltype(_impl_.uwb_ranging_){arena}
    , decltype(_impl_.discovery_metadata_){nullptr}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.client_flow_id_) { ::int64_t{0} }

  };
}

ConnectionsLog_DiscoveryPhase::~ConnectionsLog_DiscoveryPhase() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_DiscoveryPhase::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_medium()->~RepeatedField();
  _internal_mutable_discovered_endpoint()->~RepeatedPtrField();
  _internal_mutable_sent_connection_request()->~RepeatedPtrField();
  _internal_mutable_uwb_ranging()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.discovery_metadata_;
}

void ConnectionsLog_DiscoveryPhase::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_DiscoveryPhase::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_medium()->Clear();
  _internal_mutable_discovered_endpoint()->Clear();
  _internal_mutable_sent_connection_request()->Clear();
  _internal_mutable_uwb_ranging()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.discovery_metadata_ != nullptr);
    _impl_.discovery_metadata_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.client_flow_id_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_DiscoveryPhase::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.proto.connections.Medium medium = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
              _internal_add_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_medium(), ptr, ctx, ::location::nearby::proto::connections::Medium_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint discovered_endpoint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_discovered_endpoint(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest sent_connection_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sent_connection_request(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess uwb_ranging = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uwb_ranging(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 client_flow_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_client_flow_id(&has_bits);
          _impl_.client_flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata discovery_metadata = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_discovery_metadata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_DiscoveryPhase::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // repeated .location.nearby.proto.connections.Medium medium = 2;
  for (int i = 0, n = this->_internal_medium_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_medium(i), target);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint discovered_endpoint = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_discovered_endpoint_size()); i < n; i++) {
    const auto& repfield = this->_internal_discovered_endpoint(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest sent_connection_request = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sent_connection_request_size()); i < n; i++) {
    const auto& repfield = this->_internal_sent_connection_request(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess uwb_ranging = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uwb_ranging_size()); i < n; i++) {
    const auto& repfield = this->_internal_uwb_ranging(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 client_flow_id = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_client_flow_id(), target);
  }

  // optional .location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata discovery_metadata = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::discovery_metadata(this),
        _Internal::discovery_metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  return target;
}

::size_t ConnectionsLog_DiscoveryPhase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.proto.connections.Medium medium = 2;
  {
    std::size_t data_size = 0;
    auto count = static_cast<std::size_t>(this->_internal_medium_size());

    for (std::size_t i = 0; i < count; ++i) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
          this->_internal_medium(static_cast<int>(i)));
    }
    total_size += data_size;
    total_size += std::size_t{1} * count;
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint discovered_endpoint = 3;
  total_size += 1UL * this->_internal_discovered_endpoint_size();
  for (const auto& msg : this->_internal_discovered_endpoint()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest sent_connection_request = 4;
  total_size += 1UL * this->_internal_sent_connection_request_size();
  for (const auto& msg : this->_internal_sent_connection_request()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess uwb_ranging = 5;
  total_size += 1UL * this->_internal_uwb_ranging_size();
  for (const auto& msg : this->_internal_uwb_ranging()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata discovery_metadata = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.discovery_metadata_);
    }

    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional int64 client_flow_id = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_client_flow_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_DiscoveryPhase::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_DiscoveryPhase*>(
      &from));
}

void ConnectionsLog_DiscoveryPhase::MergeFrom(const ConnectionsLog_DiscoveryPhase& from) {
  ConnectionsLog_DiscoveryPhase* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_medium()->MergeFrom(from._internal_medium());
  _this->_internal_mutable_discovered_endpoint()->MergeFrom(from._internal_discovered_endpoint());
  _this->_internal_mutable_sent_connection_request()->MergeFrom(from._internal_sent_connection_request());
  _this->_internal_mutable_uwb_ranging()->MergeFrom(from._internal_uwb_ranging());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_discovery_metadata()->::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata::MergeFrom(
          from._internal_discovery_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_flow_id_ = from._impl_.client_flow_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_DiscoveryPhase::CopyFrom(const ConnectionsLog_DiscoveryPhase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_DiscoveryPhase::IsInitialized() const {
  return true;
}

void ConnectionsLog_DiscoveryPhase::InternalSwap(ConnectionsLog_DiscoveryPhase* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_medium()->InternalSwap(
      other->_internal_mutable_medium());
  _internal_mutable_discovered_endpoint()->InternalSwap(other->_internal_mutable_discovered_endpoint());
  _internal_mutable_sent_connection_request()->InternalSwap(other->_internal_mutable_sent_connection_request());
  _internal_mutable_uwb_ranging()->InternalSwap(other->_internal_mutable_uwb_ranging());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveryPhase, _impl_.client_flow_id_)
      + sizeof(ConnectionsLog_DiscoveryPhase::_impl_.client_flow_id_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveryPhase, _impl_.discovery_metadata_)>(
          reinterpret_cast<char*>(&_impl_.discovery_metadata_),
          reinterpret_cast<char*>(&other->_impl_.discovery_metadata_));
}

std::string ConnectionsLog_DiscoveryPhase::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.DiscoveryPhase";
}

// ===================================================================

class ConnectionsLog_DiscoveredEndpoint::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_DiscoveredEndpoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveredEndpoint, _impl_._has_bits_);
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_latency_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConnectionsLog_DiscoveredEndpoint::ConnectionsLog_DiscoveredEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
}
ConnectionsLog_DiscoveredEndpoint::ConnectionsLog_DiscoveredEndpoint(const ConnectionsLog_DiscoveredEndpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
}

inline void ConnectionsLog_DiscoveredEndpoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latency_millis_) { ::int64_t{0} }

    , decltype(_impl_.medium_) { 0 }

  };
}

ConnectionsLog_DiscoveredEndpoint::~ConnectionsLog_DiscoveredEndpoint() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_DiscoveredEndpoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionsLog_DiscoveredEndpoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_DiscoveredEndpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.latency_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.medium_) -
        reinterpret_cast<char*>(&_impl_.latency_millis_)) + sizeof(_impl_.medium_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_DiscoveredEndpoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.proto.connections.Medium medium = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
            _internal_set_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 latency_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_latency_millis(&has_bits);
          _impl_.latency_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_DiscoveredEndpoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.proto.connections.Medium medium = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_medium(), target);
  }

  // optional int64 latency_millis = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_latency_millis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  return target;
}

::size_t ConnectionsLog_DiscoveredEndpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 latency_millis = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_latency_millis());
    }

    // optional .location.nearby.proto.connections.Medium medium = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_medium());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_DiscoveredEndpoint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_DiscoveredEndpoint*>(
      &from));
}

void ConnectionsLog_DiscoveredEndpoint::MergeFrom(const ConnectionsLog_DiscoveredEndpoint& from) {
  ConnectionsLog_DiscoveredEndpoint* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.latency_millis_ = from._impl_.latency_millis_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.medium_ = from._impl_.medium_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_DiscoveredEndpoint::CopyFrom(const ConnectionsLog_DiscoveredEndpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_DiscoveredEndpoint::IsInitialized() const {
  return true;
}

void ConnectionsLog_DiscoveredEndpoint::InternalSwap(ConnectionsLog_DiscoveredEndpoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveredEndpoint, _impl_.medium_)
      + sizeof(ConnectionsLog_DiscoveredEndpoint::_impl_.medium_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveredEndpoint, _impl_.latency_millis_)>(
          reinterpret_cast<char*>(&_impl_.latency_millis_),
          reinterpret_cast<char*>(&other->_impl_.latency_millis_));
}

std::string ConnectionsLog_DiscoveredEndpoint::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.DiscoveredEndpoint";
}

// ===================================================================

class ConnectionsLog_UwbRangingProcess::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_UwbRangingProcess>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_UwbRangingProcess, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_ranging_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_distance_min(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_distance_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_distance_ave(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_distance_variance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_azimuth_min(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_azimuth_max(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_azimuth_ave(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_azimuth_variance(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

ConnectionsLog_UwbRangingProcess::ConnectionsLog_UwbRangingProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
}
ConnectionsLog_UwbRangingProcess::ConnectionsLog_UwbRangingProcess(const ConnectionsLog_UwbRangingProcess& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_UwbRangingProcess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uwb_ranging_data_){from._impl_.uwb_ranging_data_}
    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.number_of_ranging_data_) {}

    , decltype(_impl_.distance_min_) {}

    , decltype(_impl_.distance_max_) {}

    , decltype(_impl_.distance_ave_) {}

    , decltype(_impl_.distance_variance_) {}

    , decltype(_impl_.azimuth_min_) {}

    , decltype(_impl_.azimuth_max_) {}

    , decltype(_impl_.azimuth_ave_) {}

    , decltype(_impl_.azimuth_variance_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.azimuth_variance_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.azimuth_variance_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
}

inline void ConnectionsLog_UwbRangingProcess::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uwb_ranging_data_){arena}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.number_of_ranging_data_) { 0 }

    , decltype(_impl_.distance_min_) { 0 }

    , decltype(_impl_.distance_max_) { 0 }

    , decltype(_impl_.distance_ave_) { 0 }

    , decltype(_impl_.distance_variance_) { 0 }

    , decltype(_impl_.azimuth_min_) { 0 }

    , decltype(_impl_.azimuth_max_) { 0 }

    , decltype(_impl_.azimuth_ave_) { 0 }

    , decltype(_impl_.azimuth_variance_) { 0 }

  };
}

ConnectionsLog_UwbRangingProcess::~ConnectionsLog_UwbRangingProcess() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_UwbRangingProcess::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_uwb_ranging_data()->~RepeatedPtrField();
}

void ConnectionsLog_UwbRangingProcess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_UwbRangingProcess::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_uwb_ranging_data()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.azimuth_max_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.azimuth_max_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.azimuth_ave_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.azimuth_variance_) -
        reinterpret_cast<char*>(&_impl_.azimuth_ave_)) + sizeof(_impl_.azimuth_variance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_UwbRangingProcess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent uwb_ranging_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uwb_ranging_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 number_of_ranging_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_number_of_ranging_data(&has_bits);
          _impl_.number_of_ranging_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 distance_min = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_distance_min(&has_bits);
          _impl_.distance_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 distance_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_distance_max(&has_bits);
          _impl_.distance_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 distance_ave = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_distance_ave(&has_bits);
          _impl_.distance_ave_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 distance_variance = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_distance_variance(&has_bits);
          _impl_.distance_variance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 azimuth_min = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_azimuth_min(&has_bits);
          _impl_.azimuth_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 azimuth_max = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_azimuth_max(&has_bits);
          _impl_.azimuth_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 azimuth_ave = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_azimuth_ave(&has_bits);
          _impl_.azimuth_ave_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 azimuth_variance = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_azimuth_variance(&has_bits);
          _impl_.azimuth_variance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_UwbRangingProcess::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent uwb_ranging_data = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uwb_ranging_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_uwb_ranging_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 number_of_ranging_data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_number_of_ranging_data(), target);
  }

  // optional int32 distance_min = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_distance_min(), target);
  }

  // optional int32 distance_max = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_distance_max(), target);
  }

  // optional int32 distance_ave = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        6, this->_internal_distance_ave(), target);
  }

  // optional int32 distance_variance = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_distance_variance(), target);
  }

  // optional int32 azimuth_min = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        8, this->_internal_azimuth_min(), target);
  }

  // optional int32 azimuth_max = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_azimuth_max(), target);
  }

  // optional int32 azimuth_ave = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_azimuth_ave(), target);
  }

  // optional int32 azimuth_variance = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_azimuth_variance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  return target;
}

::size_t ConnectionsLog_UwbRangingProcess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent uwb_ranging_data = 2;
  total_size += 1UL * this->_internal_uwb_ranging_data_size();
  for (const auto& msg : this->_internal_uwb_ranging_data()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional int32 number_of_ranging_data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_number_of_ranging_data());
    }

    // optional int32 distance_min = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_distance_min());
    }

    // optional int32 distance_max = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_distance_max());
    }

    // optional int32 distance_ave = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_distance_ave());
    }

    // optional int32 distance_variance = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_distance_variance());
    }

    // optional int32 azimuth_min = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_azimuth_min());
    }

    // optional int32 azimuth_max = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_azimuth_max());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 azimuth_ave = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_azimuth_ave());
    }

    // optional int32 azimuth_variance = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_azimuth_variance());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_UwbRangingProcess::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_UwbRangingProcess*>(
      &from));
}

void ConnectionsLog_UwbRangingProcess::MergeFrom(const ConnectionsLog_UwbRangingProcess& from) {
  ConnectionsLog_UwbRangingProcess* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_uwb_ranging_data()->MergeFrom(from._internal_uwb_ranging_data());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.number_of_ranging_data_ = from._impl_.number_of_ranging_data_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.distance_min_ = from._impl_.distance_min_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.distance_max_ = from._impl_.distance_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.distance_ave_ = from._impl_.distance_ave_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.distance_variance_ = from._impl_.distance_variance_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.azimuth_min_ = from._impl_.azimuth_min_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.azimuth_max_ = from._impl_.azimuth_max_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.azimuth_ave_ = from._impl_.azimuth_ave_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.azimuth_variance_ = from._impl_.azimuth_variance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_UwbRangingProcess::CopyFrom(const ConnectionsLog_UwbRangingProcess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_UwbRangingProcess::IsInitialized() const {
  return true;
}

void ConnectionsLog_UwbRangingProcess::InternalSwap(ConnectionsLog_UwbRangingProcess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_uwb_ranging_data()->InternalSwap(other->_internal_mutable_uwb_ranging_data());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_UwbRangingProcess, _impl_.azimuth_variance_)
      + sizeof(ConnectionsLog_UwbRangingProcess::_impl_.azimuth_variance_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_UwbRangingProcess, _impl_.duration_millis_)>(
          reinterpret_cast<char*>(&_impl_.duration_millis_),
          reinterpret_cast<char*>(&other->_impl_.duration_millis_));
}

std::string ConnectionsLog_UwbRangingProcess::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.UwbRangingProcess";
}

// ===================================================================

class ConnectionsLog_RawUwbRangingEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_RawUwbRangingEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_RawUwbRangingEvent, _impl_._has_bits_);
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_azimuth_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_polar_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ConnectionsLog_RawUwbRangingEvent::ConnectionsLog_RawUwbRangingEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
}
ConnectionsLog_RawUwbRangingEvent::ConnectionsLog_RawUwbRangingEvent(const ConnectionsLog_RawUwbRangingEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
}

inline void ConnectionsLog_RawUwbRangingEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.distance_) { 0 }

    , decltype(_impl_.azimuth_angle_) { 0 }

    , decltype(_impl_.polar_angle_) { 0 }

  };
}

ConnectionsLog_RawUwbRangingEvent::~ConnectionsLog_RawUwbRangingEvent() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_RawUwbRangingEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionsLog_RawUwbRangingEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_RawUwbRangingEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.distance_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.polar_angle_) -
        reinterpret_cast<char*>(&_impl_.distance_)) + sizeof(_impl_.polar_angle_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_RawUwbRangingEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 distance = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_distance(&has_bits);
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 azimuth_angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_azimuth_angle(&has_bits);
          _impl_.azimuth_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 polar_angle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_polar_angle(&has_bits);
          _impl_.polar_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_RawUwbRangingEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 distance = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_distance(), target);
  }

  // optional int32 azimuth_angle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_azimuth_angle(), target);
  }

  // optional int32 polar_angle = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_polar_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  return target;
}

::size_t ConnectionsLog_RawUwbRangingEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 distance = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_distance());
    }

    // optional int32 azimuth_angle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_azimuth_angle());
    }

    // optional int32 polar_angle = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_polar_angle());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_RawUwbRangingEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_RawUwbRangingEvent*>(
      &from));
}

void ConnectionsLog_RawUwbRangingEvent::MergeFrom(const ConnectionsLog_RawUwbRangingEvent& from) {
  ConnectionsLog_RawUwbRangingEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.azimuth_angle_ = from._impl_.azimuth_angle_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.polar_angle_ = from._impl_.polar_angle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_RawUwbRangingEvent::CopyFrom(const ConnectionsLog_RawUwbRangingEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_RawUwbRangingEvent::IsInitialized() const {
  return true;
}

void ConnectionsLog_RawUwbRangingEvent::InternalSwap(ConnectionsLog_RawUwbRangingEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_RawUwbRangingEvent, _impl_.polar_angle_)
      + sizeof(ConnectionsLog_RawUwbRangingEvent::_impl_.polar_angle_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_RawUwbRangingEvent, _impl_.distance_)>(
          reinterpret_cast<char*>(&_impl_.distance_),
          reinterpret_cast<char*>(&other->_impl_.distance_));
}

std::string ConnectionsLog_RawUwbRangingEvent::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.RawUwbRangingEvent";
}

// ===================================================================

class ConnectionsLog_AdvertisingPhase::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_AdvertisingPhase>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_AdvertisingPhase, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_client_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata& advertising_metadata(const ConnectionsLog_AdvertisingPhase* msg);
  static void set_has_advertising_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata&
ConnectionsLog_AdvertisingPhase::_Internal::advertising_metadata(const ConnectionsLog_AdvertisingPhase* msg) {
  return *msg->_impl_.advertising_metadata_;
}
ConnectionsLog_AdvertisingPhase::ConnectionsLog_AdvertisingPhase(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
}
ConnectionsLog_AdvertisingPhase::ConnectionsLog_AdvertisingPhase(const ConnectionsLog_AdvertisingPhase& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_AdvertisingPhase* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.medium_) { from._internal_medium() }

    , decltype(_impl_.received_connection_request_){from._impl_.received_connection_request_}
    , decltype(_impl_.advertising_metadata_){nullptr}
    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.client_flow_id_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.advertising_metadata_ = new ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata(*from._impl_.advertising_metadata_);
  }
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.client_flow_id_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
}

inline void ConnectionsLog_AdvertisingPhase::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.medium_) { arena }

    , decltype(_impl_.received_connection_request_){arena}
    , decltype(_impl_.advertising_metadata_){nullptr}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.client_flow_id_) { ::int64_t{0} }

  };
}

ConnectionsLog_AdvertisingPhase::~ConnectionsLog_AdvertisingPhase() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_AdvertisingPhase::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_medium()->~RepeatedField();
  _internal_mutable_received_connection_request()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.advertising_metadata_;
}

void ConnectionsLog_AdvertisingPhase::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_AdvertisingPhase::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_medium()->Clear();
  _internal_mutable_received_connection_request()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.advertising_metadata_ != nullptr);
    _impl_.advertising_metadata_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.client_flow_id_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_AdvertisingPhase::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.proto.connections.Medium medium = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
              _internal_add_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_medium(), ptr, ctx, ::location::nearby::proto::connections::Medium_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest received_connection_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_received_connection_request(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 client_flow_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_client_flow_id(&has_bits);
          _impl_.client_flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata advertising_metadata = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_advertising_metadata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_AdvertisingPhase::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // repeated .location.nearby.proto.connections.Medium medium = 2;
  for (int i = 0, n = this->_internal_medium_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_medium(i), target);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest received_connection_request = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_received_connection_request_size()); i < n; i++) {
    const auto& repfield = this->_internal_received_connection_request(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 client_flow_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_client_flow_id(), target);
  }

  // optional .location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata advertising_metadata = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::advertising_metadata(this),
        _Internal::advertising_metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  return target;
}

::size_t ConnectionsLog_AdvertisingPhase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.proto.connections.Medium medium = 2;
  {
    std::size_t data_size = 0;
    auto count = static_cast<std::size_t>(this->_internal_medium_size());

    for (std::size_t i = 0; i < count; ++i) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
          this->_internal_medium(static_cast<int>(i)));
    }
    total_size += data_size;
    total_size += std::size_t{1} * count;
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest received_connection_request = 3;
  total_size += 1UL * this->_internal_received_connection_request_size();
  for (const auto& msg : this->_internal_received_connection_request()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata advertising_metadata = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.advertising_metadata_);
    }

    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional int64 client_flow_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_client_flow_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_AdvertisingPhase::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_AdvertisingPhase*>(
      &from));
}

void ConnectionsLog_AdvertisingPhase::MergeFrom(const ConnectionsLog_AdvertisingPhase& from) {
  ConnectionsLog_AdvertisingPhase* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_medium()->MergeFrom(from._internal_medium());
  _this->_internal_mutable_received_connection_request()->MergeFrom(from._internal_received_connection_request());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_advertising_metadata()->::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata::MergeFrom(
          from._internal_advertising_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_flow_id_ = from._impl_.client_flow_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_AdvertisingPhase::CopyFrom(const ConnectionsLog_AdvertisingPhase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_AdvertisingPhase::IsInitialized() const {
  return true;
}

void ConnectionsLog_AdvertisingPhase::InternalSwap(ConnectionsLog_AdvertisingPhase* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_medium()->InternalSwap(
      other->_internal_mutable_medium());
  _internal_mutable_received_connection_request()->InternalSwap(other->_internal_mutable_received_connection_request());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_AdvertisingPhase, _impl_.client_flow_id_)
      + sizeof(ConnectionsLog_AdvertisingPhase::_impl_.client_flow_id_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_AdvertisingPhase, _impl_.advertising_metadata_)>(
          reinterpret_cast<char*>(&_impl_.advertising_metadata_),
          reinterpret_cast<char*>(&other->_impl_.advertising_metadata_));
}

std::string ConnectionsLog_AdvertisingPhase::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.AdvertisingPhase";
}

// ===================================================================

class ConnectionsLog_ConnectionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_ConnectionRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionRequest, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_delay_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_local_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_remote_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ConnectionsLog_ConnectionRequest::ConnectionsLog_ConnectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
}
ConnectionsLog_ConnectionRequest::ConnectionsLog_ConnectionRequest(const ConnectionsLog_ConnectionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
}

inline void ConnectionsLog_ConnectionRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.request_delay_millis_) { ::int64_t{0} }

    , decltype(_impl_.local_response_) { 0 }

    , decltype(_impl_.remote_response_) { 0 }

    , decltype(_impl_.client_flow_id_) { ::int64_t{0} }

  };
}

ConnectionsLog_ConnectionRequest::~ConnectionsLog_ConnectionRequest() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_ConnectionRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionsLog_ConnectionRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_ConnectionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.client_flow_id_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_ConnectionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 request_delay_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_request_delay_millis(&has_bits);
          _impl_.request_delay_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionRequestResponse local_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionRequestResponse_IsValid(static_cast<int>(val)))) {
            _internal_set_local_response(static_cast<::location::nearby::proto::connections::ConnectionRequestResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionRequestResponse remote_response = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionRequestResponse_IsValid(static_cast<int>(val)))) {
            _internal_set_remote_response(static_cast<::location::nearby::proto::connections::ConnectionRequestResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 client_flow_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_client_flow_id(&has_bits);
          _impl_.client_flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_ConnectionRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // optional int64 request_delay_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_request_delay_millis(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionRequestResponse local_response = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_local_response(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionRequestResponse remote_response = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_remote_response(), target);
  }

  // optional int64 client_flow_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_client_flow_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  return target;
}

::size_t ConnectionsLog_ConnectionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional int64 request_delay_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_request_delay_millis());
    }

    // optional .location.nearby.proto.connections.ConnectionRequestResponse local_response = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_local_response());
    }

    // optional .location.nearby.proto.connections.ConnectionRequestResponse remote_response = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_remote_response());
    }

    // optional int64 client_flow_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_client_flow_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_ConnectionRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_ConnectionRequest*>(
      &from));
}

void ConnectionsLog_ConnectionRequest::MergeFrom(const ConnectionsLog_ConnectionRequest& from) {
  ConnectionsLog_ConnectionRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_delay_millis_ = from._impl_.request_delay_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.local_response_ = from._impl_.local_response_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.remote_response_ = from._impl_.remote_response_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.client_flow_id_ = from._impl_.client_flow_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_ConnectionRequest::CopyFrom(const ConnectionsLog_ConnectionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_ConnectionRequest::IsInitialized() const {
  return true;
}

void ConnectionsLog_ConnectionRequest::InternalSwap(ConnectionsLog_ConnectionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionRequest, _impl_.client_flow_id_)
      + sizeof(ConnectionsLog_ConnectionRequest::_impl_.client_flow_id_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionRequest, _impl_.duration_millis_)>(
          reinterpret_cast<char*>(&_impl_.duration_millis_),
          reinterpret_cast<char*>(&other->_impl_.duration_millis_));
}

std::string ConnectionsLog_ConnectionRequest::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.ConnectionRequest";
}

// ===================================================================

class ConnectionsLog_ConnectionAttempt::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_ConnectionAttempt>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionAttempt, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_attempt_result(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_connection_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata& connection_attempt_metadata(const ConnectionsLog_ConnectionAttempt* msg);
  static void set_has_connection_attempt_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata&
ConnectionsLog_ConnectionAttempt::_Internal::connection_attempt_metadata(const ConnectionsLog_ConnectionAttempt* msg) {
  return *msg->_impl_.connection_attempt_metadata_;
}
ConnectionsLog_ConnectionAttempt::ConnectionsLog_ConnectionAttempt(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
}
ConnectionsLog_ConnectionAttempt::ConnectionsLog_ConnectionAttempt(const ConnectionsLog_ConnectionAttempt& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_ConnectionAttempt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.connection_attempt_metadata_){nullptr}
    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.type_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.medium_) {}

    , decltype(_impl_.attempt_result_) {}

    , decltype(_impl_.client_flow_id_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.connection_token_.Set(from._internal_connection_token(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.connection_attempt_metadata_ = new ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata(*from._impl_.connection_attempt_metadata_);
  }
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.client_flow_id_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
}

inline void ConnectionsLog_ConnectionAttempt::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.connection_attempt_metadata_){nullptr}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.type_) { 0 }

    , decltype(_impl_.direction_) { 0 }

    , decltype(_impl_.medium_) { 0 }

    , decltype(_impl_.attempt_result_) { 0 }

    , decltype(_impl_.client_flow_id_) { ::int64_t{0} }

  };
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectionsLog_ConnectionAttempt::~ConnectionsLog_ConnectionAttempt() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_ConnectionAttempt::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.connection_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.connection_attempt_metadata_;
}

void ConnectionsLog_ConnectionAttempt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_ConnectionAttempt::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.connection_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.connection_attempt_metadata_ != nullptr);
      _impl_.connection_attempt_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.client_flow_id_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.client_flow_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_ConnectionAttempt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionAttemptType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionAttemptType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::location::nearby::proto::connections::ConnectionAttemptType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionAttemptDirection_IsValid(static_cast<int>(val)))) {
            _internal_set_direction(static_cast<::location::nearby::proto::connections::ConnectionAttemptDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.Medium medium = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
            _internal_set_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionAttemptResult attempt_result = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionAttemptResult_IsValid(static_cast<int>(val)))) {
            _internal_set_attempt_result(static_cast<::location::nearby::proto::connections::ConnectionAttemptResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 client_flow_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_client_flow_id(&has_bits);
          _impl_.client_flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string connection_token = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_connection_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata connection_attempt_metadata = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_attempt_metadata(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_ConnectionAttempt::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionAttemptType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_type(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_direction(), target);
  }

  // optional .location.nearby.proto.connections.Medium medium = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_medium(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionAttemptResult attempt_result = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_attempt_result(), target);
  }

  // optional int64 client_flow_id = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_client_flow_id(), target);
  }

  // optional string connection_token = 7;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_connection_token();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional .location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata connection_attempt_metadata = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::connection_attempt_metadata(this),
        _Internal::connection_attempt_metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  return target;
}

::size_t ConnectionsLog_ConnectionAttempt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string connection_token = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_connection_token());
    }

    // optional .location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata connection_attempt_metadata = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connection_attempt_metadata_);
    }

    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional .location.nearby.proto.connections.ConnectionAttemptType type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
    }

    // optional .location.nearby.proto.connections.Medium medium = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_medium());
    }

    // optional .location.nearby.proto.connections.ConnectionAttemptResult attempt_result = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_attempt_result());
    }

    // optional int64 client_flow_id = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_client_flow_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_ConnectionAttempt::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_ConnectionAttempt*>(
      &from));
}

void ConnectionsLog_ConnectionAttempt::MergeFrom(const ConnectionsLog_ConnectionAttempt& from) {
  ConnectionsLog_ConnectionAttempt* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_connection_token(from._internal_connection_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connection_attempt_metadata()->::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata::MergeFrom(
          from._internal_connection_attempt_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.medium_ = from._impl_.medium_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.attempt_result_ = from._impl_.attempt_result_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_flow_id_ = from._impl_.client_flow_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_ConnectionAttempt::CopyFrom(const ConnectionsLog_ConnectionAttempt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_ConnectionAttempt::IsInitialized() const {
  return true;
}

void ConnectionsLog_ConnectionAttempt::InternalSwap(ConnectionsLog_ConnectionAttempt* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_token_, lhs_arena,
                                       &other->_impl_.connection_token_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionAttempt, _impl_.client_flow_id_)
      + sizeof(ConnectionsLog_ConnectionAttempt::_impl_.client_flow_id_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionAttempt, _impl_.connection_attempt_metadata_)>(
          reinterpret_cast<char*>(&_impl_.connection_attempt_metadata_),
          reinterpret_cast<char*>(&other->_impl_.connection_attempt_metadata_));
}

std::string ConnectionsLog_ConnectionAttempt::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.ConnectionAttempt";
}

// ===================================================================

class ConnectionsLog_EstablishedConnection::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_EstablishedConnection>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_EstablishedConnection, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_disconnection_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_connection_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_safe_disconnection_result(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ConnectionsLog_EstablishedConnection::ConnectionsLog_EstablishedConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
}
ConnectionsLog_EstablishedConnection::ConnectionsLog_EstablishedConnection(const ConnectionsLog_EstablishedConnection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_EstablishedConnection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sent_payload_){from._impl_.sent_payload_}
    , decltype(_impl_.received_payload_){from._impl_.received_payload_}
    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.medium_) {}

    , decltype(_impl_.disconnection_reason_) {}

    , decltype(_impl_.client_flow_id_) {}

    , decltype(_impl_.type_) {}

    , decltype(_impl_.safe_disconnection_result_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.connection_token_.Set(from._internal_connection_token(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.safe_disconnection_result_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.safe_disconnection_result_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
}

inline void ConnectionsLog_EstablishedConnection::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sent_payload_){arena}
    , decltype(_impl_.received_payload_){arena}
    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.medium_) { 0 }

    , decltype(_impl_.disconnection_reason_) { 0 }

    , decltype(_impl_.client_flow_id_) { ::int64_t{0} }

    , decltype(_impl_.type_) { 0 }

    , decltype(_impl_.safe_disconnection_result_) { 0 }

  };
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectionsLog_EstablishedConnection::~ConnectionsLog_EstablishedConnection() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_EstablishedConnection::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_sent_payload()->~RepeatedPtrField();
  _internal_mutable_received_payload()->~RepeatedPtrField();
  _impl_.connection_token_.Destroy();
}

void ConnectionsLog_EstablishedConnection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_EstablishedConnection::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_sent_payload()->Clear();
  _internal_mutable_received_payload()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.connection_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.safe_disconnection_result_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.safe_disconnection_result_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_EstablishedConnection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.Medium medium = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
            _internal_set_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.Payload sent_payload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sent_payload(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .location.nearby.analytics.proto.ConnectionsLog.Payload received_payload = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_received_payload(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.DisconnectionReason disconnection_reason = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::DisconnectionReason_IsValid(static_cast<int>(val)))) {
            _internal_set_disconnection_reason(static_cast<::location::nearby::proto::connections::DisconnectionReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 client_flow_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_client_flow_id(&has_bits);
          _impl_.client_flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string connection_token = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_connection_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionAttemptType type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionAttemptType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::location::nearby::proto::connections::ConnectionAttemptType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection.SafeDisconnectionResult safe_disconnection_result = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::analytics::proto::ConnectionsLog_EstablishedConnection_SafeDisconnectionResult_IsValid(static_cast<int>(val)))) {
            _internal_set_safe_disconnection_result(static_cast<::location::nearby::analytics::proto::ConnectionsLog_EstablishedConnection_SafeDisconnectionResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_EstablishedConnection::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // optional .location.nearby.proto.connections.Medium medium = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_medium(), target);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.Payload sent_payload = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sent_payload_size()); i < n; i++) {
    const auto& repfield = this->_internal_sent_payload(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.Payload received_payload = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_received_payload_size()); i < n; i++) {
    const auto& repfield = this->_internal_received_payload(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .location.nearby.proto.connections.DisconnectionReason disconnection_reason = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_disconnection_reason(), target);
  }

  // optional int64 client_flow_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_client_flow_id(), target);
  }

  // optional string connection_token = 7;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_connection_token();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional .location.nearby.proto.connections.ConnectionAttemptType type = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_type(), target);
  }

  // optional .location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection.SafeDisconnectionResult safe_disconnection_result = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        9, this->_internal_safe_disconnection_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  return target;
}

::size_t ConnectionsLog_EstablishedConnection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.analytics.proto.ConnectionsLog.Payload sent_payload = 3;
  total_size += 1UL * this->_internal_sent_payload_size();
  for (const auto& msg : this->_internal_sent_payload()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .location.nearby.analytics.proto.ConnectionsLog.Payload received_payload = 4;
  total_size += 1UL * this->_internal_received_payload_size();
  for (const auto& msg : this->_internal_received_payload()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string connection_token = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_connection_token());
    }

    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional .location.nearby.proto.connections.Medium medium = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_medium());
    }

    // optional .location.nearby.proto.connections.DisconnectionReason disconnection_reason = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_disconnection_reason());
    }

    // optional int64 client_flow_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_client_flow_id());
    }

    // optional .location.nearby.proto.connections.ConnectionAttemptType type = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection.SafeDisconnectionResult safe_disconnection_result = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_safe_disconnection_result());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_EstablishedConnection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_EstablishedConnection*>(
      &from));
}

void ConnectionsLog_EstablishedConnection::MergeFrom(const ConnectionsLog_EstablishedConnection& from) {
  ConnectionsLog_EstablishedConnection* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_sent_payload()->MergeFrom(from._internal_sent_payload());
  _this->_internal_mutable_received_payload()->MergeFrom(from._internal_received_payload());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_connection_token(from._internal_connection_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.medium_ = from._impl_.medium_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.disconnection_reason_ = from._impl_.disconnection_reason_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.client_flow_id_ = from._impl_.client_flow_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.safe_disconnection_result_ = from._impl_.safe_disconnection_result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_EstablishedConnection::CopyFrom(const ConnectionsLog_EstablishedConnection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_EstablishedConnection::IsInitialized() const {
  return true;
}

void ConnectionsLog_EstablishedConnection::InternalSwap(ConnectionsLog_EstablishedConnection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_sent_payload()->InternalSwap(other->_internal_mutable_sent_payload());
  _internal_mutable_received_payload()->InternalSwap(other->_internal_mutable_received_payload());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_token_, lhs_arena,
                                       &other->_impl_.connection_token_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_EstablishedConnection, _impl_.safe_disconnection_result_)
      + sizeof(ConnectionsLog_EstablishedConnection::_impl_.safe_disconnection_result_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_EstablishedConnection, _impl_.duration_millis_)>(
          reinterpret_cast<char*>(&_impl_.duration_millis_),
          reinterpret_cast<char*>(&other->_impl_.duration_millis_));
}

std::string ConnectionsLog_EstablishedConnection::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.EstablishedConnection";
}

// ===================================================================

class ConnectionsLog_Payload::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_Payload>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_Payload, _impl_._has_bits_);
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_bytes_transferred(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_chunks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_successful_auto_resume(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

ConnectionsLog_Payload::ConnectionsLog_Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.Payload)
}
ConnectionsLog_Payload::ConnectionsLog_Payload(const ConnectionsLog_Payload& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.Payload)
}

inline void ConnectionsLog_Payload::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.total_size_bytes_) { ::int64_t{0} }

    , decltype(_impl_.type_) { 0 }

    , decltype(_impl_.num_chunks_) { 0 }

    , decltype(_impl_.num_bytes_transferred_) { ::int64_t{0} }

    , decltype(_impl_.status_) { 0 }

    , decltype(_impl_.num_successful_auto_resume_) { 0 }

  };
}

ConnectionsLog_Payload::~ConnectionsLog_Payload() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.Payload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_Payload::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionsLog_Payload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_Payload::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.Payload)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.num_successful_auto_resume_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.num_successful_auto_resume_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_Payload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 duration_millis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.PayloadType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::PayloadType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::location::nearby::proto::connections::PayloadType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 total_size_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_total_size_bytes(&has_bits);
          _impl_.total_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 num_bytes_transferred = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_num_bytes_transferred(&has_bits);
          _impl_.num_bytes_transferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num_chunks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_num_chunks(&has_bits);
          _impl_.num_chunks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.PayloadStatus status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::PayloadStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_status(static_cast<::location::nearby::proto::connections::PayloadStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 num_successful_auto_resume = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_num_successful_auto_resume(&has_bits);
          _impl_.num_successful_auto_resume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_Payload::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.Payload)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 duration_millis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_duration_millis(), target);
  }

  // optional .location.nearby.proto.connections.PayloadType type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_type(), target);
  }

  // optional int64 total_size_bytes = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_total_size_bytes(), target);
  }

  // optional int64 num_bytes_transferred = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_num_bytes_transferred(), target);
  }

  // optional int32 num_chunks = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_num_chunks(), target);
  }

  // optional .location.nearby.proto.connections.PayloadStatus status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_status(), target);
  }

  // optional int32 num_successful_auto_resume = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_num_successful_auto_resume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.Payload)
  return target;
}

::size_t ConnectionsLog_Payload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.Payload)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int64 duration_millis = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional int64 total_size_bytes = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_total_size_bytes());
    }

    // optional .location.nearby.proto.connections.PayloadType type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 num_chunks = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_num_chunks());
    }

    // optional int64 num_bytes_transferred = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_num_bytes_transferred());
    }

    // optional .location.nearby.proto.connections.PayloadStatus status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional int32 num_successful_auto_resume = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_num_successful_auto_resume());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_Payload::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_Payload*>(
      &from));
}

void ConnectionsLog_Payload::MergeFrom(const ConnectionsLog_Payload& from) {
  ConnectionsLog_Payload* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.Payload)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_size_bytes_ = from._impl_.total_size_bytes_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_chunks_ = from._impl_.num_chunks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.num_bytes_transferred_ = from._impl_.num_bytes_transferred_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_successful_auto_resume_ = from._impl_.num_successful_auto_resume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_Payload::CopyFrom(const ConnectionsLog_Payload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.Payload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_Payload::IsInitialized() const {
  return true;
}

void ConnectionsLog_Payload::InternalSwap(ConnectionsLog_Payload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_Payload, _impl_.num_successful_auto_resume_)
      + sizeof(ConnectionsLog_Payload::_impl_.num_successful_auto_resume_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_Payload, _impl_.duration_millis_)>(
          reinterpret_cast<char*>(&_impl_.duration_millis_),
          reinterpret_cast<char*>(&other->_impl_.duration_millis_));
}

std::string ConnectionsLog_Payload::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.Payload";
}

// ===================================================================

class ConnectionsLog_BandwidthUpgradeAttempt::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_BandwidthUpgradeAttempt>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_BandwidthUpgradeAttempt, _impl_._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_duration_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_to_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_upgrade_result(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_error_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_client_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_connection_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConnectionsLog_BandwidthUpgradeAttempt::ConnectionsLog_BandwidthUpgradeAttempt(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
}
ConnectionsLog_BandwidthUpgradeAttempt::ConnectionsLog_BandwidthUpgradeAttempt(const ConnectionsLog_BandwidthUpgradeAttempt& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_BandwidthUpgradeAttempt* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.duration_millis_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.from_medium_) {}

    , decltype(_impl_.to_medium_) {}

    , decltype(_impl_.upgrade_result_) {}

    , decltype(_impl_.client_flow_id_) {}

    , decltype(_impl_.error_stage_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.connection_token_.Set(from._internal_connection_token(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.duration_millis_, &from._impl_.duration_millis_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.error_stage_) -
    reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.error_stage_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
}

inline void ConnectionsLog_BandwidthUpgradeAttempt::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.duration_millis_) { ::int64_t{0} }

    , decltype(_impl_.direction_) { 0 }

    , decltype(_impl_.from_medium_) { 0 }

    , decltype(_impl_.to_medium_) { 0 }

    , decltype(_impl_.upgrade_result_) { 0 }

    , decltype(_impl_.client_flow_id_) { ::int64_t{0} }

    , decltype(_impl_.error_stage_) { 0 }

  };
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectionsLog_BandwidthUpgradeAttempt::~ConnectionsLog_BandwidthUpgradeAttempt() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_BandwidthUpgradeAttempt::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.connection_token_.Destroy();
}

void ConnectionsLog_BandwidthUpgradeAttempt::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_BandwidthUpgradeAttempt::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.connection_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.duration_millis_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_stage_) -
        reinterpret_cast<char*>(&_impl_.duration_millis_)) + sizeof(_impl_.error_stage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_BandwidthUpgradeAttempt::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionAttemptDirection_IsValid(static_cast<int>(val)))) {
            _internal_set_direction(static_cast<::location::nearby::proto::connections::ConnectionAttemptDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 duration_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_duration_millis(&has_bits);
          _impl_.duration_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.Medium from_medium = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
            _internal_set_from_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.Medium to_medium = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
            _internal_set_to_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.BandwidthUpgradeResult upgrade_result = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::BandwidthUpgradeResult_IsValid(static_cast<int>(val)))) {
            _internal_set_upgrade_result(static_cast<::location::nearby::proto::connections::BandwidthUpgradeResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.BandwidthUpgradeErrorStage error_stage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::BandwidthUpgradeErrorStage_IsValid(static_cast<int>(val)))) {
            _internal_set_error_stage(static_cast<::location::nearby::proto::connections::BandwidthUpgradeErrorStage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 client_flow_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_client_flow_id(&has_bits);
          _impl_.client_flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string connection_token = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_connection_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_BandwidthUpgradeAttempt::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_direction(), target);
  }

  // optional int64 duration_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_duration_millis(), target);
  }

  // optional .location.nearby.proto.connections.Medium from_medium = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_from_medium(), target);
  }

  // optional .location.nearby.proto.connections.Medium to_medium = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_to_medium(), target);
  }

  // optional .location.nearby.proto.connections.BandwidthUpgradeResult upgrade_result = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_upgrade_result(), target);
  }

  // optional .location.nearby.proto.connections.BandwidthUpgradeErrorStage error_stage = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_error_stage(), target);
  }

  // optional int64 client_flow_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        7, this->_internal_client_flow_id(), target);
  }

  // optional string connection_token = 8;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_connection_token();
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  return target;
}

::size_t ConnectionsLog_BandwidthUpgradeAttempt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string connection_token = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_connection_token());
    }

    // optional int64 duration_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_duration_millis());
    }

    // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
    }

    // optional .location.nearby.proto.connections.Medium from_medium = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_from_medium());
    }

    // optional .location.nearby.proto.connections.Medium to_medium = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_to_medium());
    }

    // optional .location.nearby.proto.connections.BandwidthUpgradeResult upgrade_result = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_upgrade_result());
    }

    // optional int64 client_flow_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_client_flow_id());
    }

    // optional .location.nearby.proto.connections.BandwidthUpgradeErrorStage error_stage = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error_stage());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_BandwidthUpgradeAttempt::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_BandwidthUpgradeAttempt*>(
      &from));
}

void ConnectionsLog_BandwidthUpgradeAttempt::MergeFrom(const ConnectionsLog_BandwidthUpgradeAttempt& from) {
  ConnectionsLog_BandwidthUpgradeAttempt* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_connection_token(from._internal_connection_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.duration_millis_ = from._impl_.duration_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.from_medium_ = from._impl_.from_medium_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.to_medium_ = from._impl_.to_medium_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.upgrade_result_ = from._impl_.upgrade_result_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.client_flow_id_ = from._impl_.client_flow_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.error_stage_ = from._impl_.error_stage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_BandwidthUpgradeAttempt::CopyFrom(const ConnectionsLog_BandwidthUpgradeAttempt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_BandwidthUpgradeAttempt::IsInitialized() const {
  return true;
}

void ConnectionsLog_BandwidthUpgradeAttempt::InternalSwap(ConnectionsLog_BandwidthUpgradeAttempt* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_token_, lhs_arena,
                                       &other->_impl_.connection_token_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_BandwidthUpgradeAttempt, _impl_.error_stage_)
      + sizeof(ConnectionsLog_BandwidthUpgradeAttempt::_impl_.error_stage_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_BandwidthUpgradeAttempt, _impl_.duration_millis_)>(
          reinterpret_cast<char*>(&_impl_.duration_millis_),
          reinterpret_cast<char*>(&other->_impl_.duration_millis_));
}

std::string ConnectionsLog_BandwidthUpgradeAttempt::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.BandwidthUpgradeAttempt";
}

// ===================================================================

class ConnectionsLog_ErrorCode::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_ErrorCode>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_ErrorCode, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::location::nearby::analytics::proto::ConnectionsLog_ErrorCode, _impl_._oneof_case_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_service_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_medium(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flow_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_connection_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ConnectionsLog_ErrorCode::ConnectionsLog_ErrorCode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
}
ConnectionsLog_ErrorCode::ConnectionsLog_ErrorCode(const ConnectionsLog_ErrorCode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_ErrorCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_id_) {}

    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.medium_) {}

    , decltype(_impl_.event_) {}

    , decltype(_impl_.description_) {}

    , decltype(_impl_.flow_id_) {}

    , decltype(_impl_.ErrorCodeDetail_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.service_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.service_id_.Set(from._internal_service_id(), _this->GetArenaForAllocation());
  }
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.connection_token_.Set(from._internal_connection_token(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.flow_id_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.flow_id_));
  clear_has_ErrorCodeDetail();
  switch (from.ErrorCodeDetail_case()) {
    case kCommonError: {
      _this->_internal_set_common_error(from._internal_common_error());
      break;
    }
    case kStartAdvertisingError: {
      _this->_internal_set_start_advertising_error(from._internal_start_advertising_error());
      break;
    }
    case kStartDiscoveringError: {
      _this->_internal_set_start_discovering_error(from._internal_start_discovering_error());
      break;
    }
    case kStopAdvertisingError: {
      _this->_internal_set_stop_advertising_error(from._internal_stop_advertising_error());
      break;
    }
    case kStopDiscoveringError: {
      _this->_internal_set_stop_discovering_error(from._internal_stop_discovering_error());
      break;
    }
    case kStartListeningIncomingConnectionError: {
      _this->_internal_set_start_listening_incoming_connection_error(from._internal_start_listening_incoming_connection_error());
      break;
    }
    case kStopListeningIncomingConnectionError: {
      _this->_internal_set_stop_listening_incoming_connection_error(from._internal_stop_listening_incoming_connection_error());
      break;
    }
    case kConnectError: {
      _this->_internal_set_connect_error(from._internal_connect_error());
      break;
    }
    case kDisconnectError: {
      _this->_internal_set_disconnect_error(from._internal_disconnect_error());
      break;
    }
    case kSendPayloadError: {
      _this->_internal_set_send_payload_error(from._internal_send_payload_error());
      break;
    }
    case kReceivePayloadError: {
      _this->_internal_set_receive_payload_error(from._internal_receive_payload_error());
      break;
    }
    case kUpgradeError: {
      _this->_internal_set_upgrade_error(from._internal_upgrade_error());
      break;
    }
    case kAcceptConnectionError: {
      _this->_internal_set_accept_connection_error(from._internal_accept_connection_error());
      break;
    }
    case kRejectConnectionError: {
      _this->_internal_set_reject_connection_error(from._internal_reject_connection_error());
      break;
    }
    case ERRORCODEDETAIL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
}

inline void ConnectionsLog_ErrorCode::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.service_id_) {}

    , decltype(_impl_.connection_token_) {}

    , decltype(_impl_.direction_) { 0 }

    , decltype(_impl_.medium_) { 0 }

    , decltype(_impl_.event_) { 0 }

    , decltype(_impl_.description_) { 0 }

    , decltype(_impl_.flow_id_) { ::int64_t{0} }

    , decltype(_impl_.ErrorCodeDetail_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.service_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connection_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.connection_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_ErrorCodeDetail();
}

ConnectionsLog_ErrorCode::~ConnectionsLog_ErrorCode() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_ErrorCode::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_id_.Destroy();
  _impl_.connection_token_.Destroy();
  if (has_ErrorCodeDetail()) {
    clear_ErrorCodeDetail();
  }
}

void ConnectionsLog_ErrorCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_ErrorCode::clear_ErrorCodeDetail() {
// @@protoc_insertion_point(one_of_clear_start:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  switch (ErrorCodeDetail_case()) {
    case kCommonError: {
      // No need to clear
      break;
    }
    case kStartAdvertisingError: {
      // No need to clear
      break;
    }
    case kStartDiscoveringError: {
      // No need to clear
      break;
    }
    case kStopAdvertisingError: {
      // No need to clear
      break;
    }
    case kStopDiscoveringError: {
      // No need to clear
      break;
    }
    case kStartListeningIncomingConnectionError: {
      // No need to clear
      break;
    }
    case kStopListeningIncomingConnectionError: {
      // No need to clear
      break;
    }
    case kConnectError: {
      // No need to clear
      break;
    }
    case kDisconnectError: {
      // No need to clear
      break;
    }
    case kSendPayloadError: {
      // No need to clear
      break;
    }
    case kReceivePayloadError: {
      // No need to clear
      break;
    }
    case kUpgradeError: {
      // No need to clear
      break;
    }
    case kAcceptConnectionError: {
      // No need to clear
      break;
    }
    case kRejectConnectionError: {
      // No need to clear
      break;
    }
    case ERRORCODEDETAIL_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ERRORCODEDETAIL_NOT_SET;
}


void ConnectionsLog_ErrorCode::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.service_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.connection_token_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.direction_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flow_id_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.flow_id_));
  }
  clear_ErrorCodeDetail();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_ErrorCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionAttemptDirection_IsValid(static_cast<int>(val)))) {
            _internal_set_direction(static_cast<::location::nearby::proto::connections::ConnectionAttemptDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string service_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_service_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.Medium medium = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::Medium_IsValid(static_cast<int>(val)))) {
            _internal_set_medium(static_cast<::location::nearby::proto::connections::Medium>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.errorcode.proto.Event event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::Event_IsValid(static_cast<int>(val)))) {
            _internal_set_event(static_cast<::location::nearby::errorcode::proto::Event>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.errorcode.proto.Description description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::Description_IsValid(static_cast<int>(val)))) {
            _internal_set_description(static_cast<::location::nearby::errorcode::proto::Description>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 flow_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_flow_id(&has_bits);
          _impl_.flow_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.CommonError common_error = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::CommonError_IsValid(static_cast<int>(val)))) {
            _internal_set_common_error(static_cast<::location::nearby::errorcode::proto::CommonError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.StartAdvertisingError start_advertising_error = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::StartAdvertisingError_IsValid(static_cast<int>(val)))) {
            _internal_set_start_advertising_error(static_cast<::location::nearby::errorcode::proto::StartAdvertisingError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.StartDiscoveringError start_discovering_error = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::StartDiscoveringError_IsValid(static_cast<int>(val)))) {
            _internal_set_start_discovering_error(static_cast<::location::nearby::errorcode::proto::StartDiscoveringError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.StopAdvertisingError stop_advertising_error = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::StopAdvertisingError_IsValid(static_cast<int>(val)))) {
            _internal_set_stop_advertising_error(static_cast<::location::nearby::errorcode::proto::StopAdvertisingError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.StopDiscoveringError stop_discovering_error = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::StopDiscoveringError_IsValid(static_cast<int>(val)))) {
            _internal_set_stop_discovering_error(static_cast<::location::nearby::errorcode::proto::StopDiscoveringError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.StartListeningIncomingConnectionError start_listening_incoming_connection_error = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::StartListeningIncomingConnectionError_IsValid(static_cast<int>(val)))) {
            _internal_set_start_listening_incoming_connection_error(static_cast<::location::nearby::errorcode::proto::StartListeningIncomingConnectionError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.StopListeningIncomingConnectionError stop_listening_incoming_connection_error = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::StopListeningIncomingConnectionError_IsValid(static_cast<int>(val)))) {
            _internal_set_stop_listening_incoming_connection_error(static_cast<::location::nearby::errorcode::proto::StopListeningIncomingConnectionError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.ConnectError connect_error = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::ConnectError_IsValid(static_cast<int>(val)))) {
            _internal_set_connect_error(static_cast<::location::nearby::errorcode::proto::ConnectError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.DisconnectError disconnect_error = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::DisconnectError_IsValid(static_cast<int>(val)))) {
            _internal_set_disconnect_error(static_cast<::location::nearby::errorcode::proto::DisconnectError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string connection_token = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_connection_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.SendPayloadError send_payload_error = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 136)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::SendPayloadError_IsValid(static_cast<int>(val)))) {
            _internal_set_send_payload_error(static_cast<::location::nearby::errorcode::proto::SendPayloadError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.ReceivePayloadError receive_payload_error = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 144)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::ReceivePayloadError_IsValid(static_cast<int>(val)))) {
            _internal_set_receive_payload_error(static_cast<::location::nearby::errorcode::proto::ReceivePayloadError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.UpgradeError upgrade_error = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 152)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::UpgradeError_IsValid(static_cast<int>(val)))) {
            _internal_set_upgrade_error(static_cast<::location::nearby::errorcode::proto::UpgradeError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.AcceptConnectionError accept_connection_error = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 160)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::AcceptConnectionError_IsValid(static_cast<int>(val)))) {
            _internal_set_accept_connection_error(static_cast<::location::nearby::errorcode::proto::AcceptConnectionError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.errorcode.proto.RejectConnectionError reject_connection_error = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 168)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::errorcode::proto::RejectConnectionError_IsValid(static_cast<int>(val)))) {
            _internal_set_reject_connection_error(static_cast<::location::nearby::errorcode::proto::RejectConnectionError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_ErrorCode::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_direction(), target);
  }

  // optional string service_id = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_service_id();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .location.nearby.proto.connections.Medium medium = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_medium(), target);
  }

  // optional .location.nearby.errorcode.proto.Event event = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_event(), target);
  }

  // optional .location.nearby.errorcode.proto.Description description = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_description(), target);
  }

  // optional int64 flow_id = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_flow_id(), target);
  }

  switch (ErrorCodeDetail_case()) {
    case kCommonError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          7, this->_internal_common_error(), target);
      break;
    }
    case kStartAdvertisingError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          8, this->_internal_start_advertising_error(), target);
      break;
    }
    case kStartDiscoveringError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          9, this->_internal_start_discovering_error(), target);
      break;
    }
    case kStopAdvertisingError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          10, this->_internal_stop_advertising_error(), target);
      break;
    }
    case kStopDiscoveringError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          11, this->_internal_stop_discovering_error(), target);
      break;
    }
    case kStartListeningIncomingConnectionError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          12, this->_internal_start_listening_incoming_connection_error(), target);
      break;
    }
    case kStopListeningIncomingConnectionError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          13, this->_internal_stop_listening_incoming_connection_error(), target);
      break;
    }
    case kConnectError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          14, this->_internal_connect_error(), target);
      break;
    }
    case kDisconnectError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          15, this->_internal_disconnect_error(), target);
      break;
    }
    default: ;
  }
  // optional string connection_token = 16;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_connection_token();
    target = stream->WriteStringMaybeAliased(16, _s, target);
  }

  switch (ErrorCodeDetail_case()) {
    case kSendPayloadError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          17, this->_internal_send_payload_error(), target);
      break;
    }
    case kReceivePayloadError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          18, this->_internal_receive_payload_error(), target);
      break;
    }
    case kUpgradeError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          19, this->_internal_upgrade_error(), target);
      break;
    }
    case kAcceptConnectionError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          20, this->_internal_accept_connection_error(), target);
      break;
    }
    case kRejectConnectionError: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          21, this->_internal_reject_connection_error(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  return target;
}

::size_t ConnectionsLog_ErrorCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string service_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_service_id());
    }

    // optional string connection_token = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_connection_token());
    }

    // optional .location.nearby.proto.connections.ConnectionAttemptDirection direction = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
    }

    // optional .location.nearby.proto.connections.Medium medium = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_medium());
    }

    // optional .location.nearby.errorcode.proto.Event event = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_event());
    }

    // optional .location.nearby.errorcode.proto.Description description = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_description());
    }

    // optional int64 flow_id = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_flow_id());
    }

  }
  switch (ErrorCodeDetail_case()) {
    // .location.nearby.errorcode.proto.CommonError common_error = 7;
    case kCommonError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_common_error());
      break;
    }
    // .location.nearby.errorcode.proto.StartAdvertisingError start_advertising_error = 8;
    case kStartAdvertisingError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_start_advertising_error());
      break;
    }
    // .location.nearby.errorcode.proto.StartDiscoveringError start_discovering_error = 9;
    case kStartDiscoveringError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_start_discovering_error());
      break;
    }
    // .location.nearby.errorcode.proto.StopAdvertisingError stop_advertising_error = 10;
    case kStopAdvertisingError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_stop_advertising_error());
      break;
    }
    // .location.nearby.errorcode.proto.StopDiscoveringError stop_discovering_error = 11;
    case kStopDiscoveringError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_stop_discovering_error());
      break;
    }
    // .location.nearby.errorcode.proto.StartListeningIncomingConnectionError start_listening_incoming_connection_error = 12;
    case kStartListeningIncomingConnectionError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_start_listening_incoming_connection_error());
      break;
    }
    // .location.nearby.errorcode.proto.StopListeningIncomingConnectionError stop_listening_incoming_connection_error = 13;
    case kStopListeningIncomingConnectionError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_stop_listening_incoming_connection_error());
      break;
    }
    // .location.nearby.errorcode.proto.ConnectError connect_error = 14;
    case kConnectError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_connect_error());
      break;
    }
    // .location.nearby.errorcode.proto.DisconnectError disconnect_error = 15;
    case kDisconnectError: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_disconnect_error());
      break;
    }
    // .location.nearby.errorcode.proto.SendPayloadError send_payload_error = 17;
    case kSendPayloadError: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_send_payload_error());
      break;
    }
    // .location.nearby.errorcode.proto.ReceivePayloadError receive_payload_error = 18;
    case kReceivePayloadError: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_receive_payload_error());
      break;
    }
    // .location.nearby.errorcode.proto.UpgradeError upgrade_error = 19;
    case kUpgradeError: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_upgrade_error());
      break;
    }
    // .location.nearby.errorcode.proto.AcceptConnectionError accept_connection_error = 20;
    case kAcceptConnectionError: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_accept_connection_error());
      break;
    }
    // .location.nearby.errorcode.proto.RejectConnectionError reject_connection_error = 21;
    case kRejectConnectionError: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_reject_connection_error());
      break;
    }
    case ERRORCODEDETAIL_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_ErrorCode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_ErrorCode*>(
      &from));
}

void ConnectionsLog_ErrorCode::MergeFrom(const ConnectionsLog_ErrorCode& from) {
  ConnectionsLog_ErrorCode* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_service_id(from._internal_service_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_connection_token(from._internal_connection_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.medium_ = from._impl_.medium_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.event_ = from._impl_.event_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.description_ = from._impl_.description_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.flow_id_ = from._impl_.flow_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.ErrorCodeDetail_case()) {
    case kCommonError: {
      _this->_internal_set_common_error(from._internal_common_error());
      break;
    }
    case kStartAdvertisingError: {
      _this->_internal_set_start_advertising_error(from._internal_start_advertising_error());
      break;
    }
    case kStartDiscoveringError: {
      _this->_internal_set_start_discovering_error(from._internal_start_discovering_error());
      break;
    }
    case kStopAdvertisingError: {
      _this->_internal_set_stop_advertising_error(from._internal_stop_advertising_error());
      break;
    }
    case kStopDiscoveringError: {
      _this->_internal_set_stop_discovering_error(from._internal_stop_discovering_error());
      break;
    }
    case kStartListeningIncomingConnectionError: {
      _this->_internal_set_start_listening_incoming_connection_error(from._internal_start_listening_incoming_connection_error());
      break;
    }
    case kStopListeningIncomingConnectionError: {
      _this->_internal_set_stop_listening_incoming_connection_error(from._internal_stop_listening_incoming_connection_error());
      break;
    }
    case kConnectError: {
      _this->_internal_set_connect_error(from._internal_connect_error());
      break;
    }
    case kDisconnectError: {
      _this->_internal_set_disconnect_error(from._internal_disconnect_error());
      break;
    }
    case kSendPayloadError: {
      _this->_internal_set_send_payload_error(from._internal_send_payload_error());
      break;
    }
    case kReceivePayloadError: {
      _this->_internal_set_receive_payload_error(from._internal_receive_payload_error());
      break;
    }
    case kUpgradeError: {
      _this->_internal_set_upgrade_error(from._internal_upgrade_error());
      break;
    }
    case kAcceptConnectionError: {
      _this->_internal_set_accept_connection_error(from._internal_accept_connection_error());
      break;
    }
    case kRejectConnectionError: {
      _this->_internal_set_reject_connection_error(from._internal_reject_connection_error());
      break;
    }
    case ERRORCODEDETAIL_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_ErrorCode::CopyFrom(const ConnectionsLog_ErrorCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.ErrorCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_ErrorCode::IsInitialized() const {
  return true;
}

void ConnectionsLog_ErrorCode::InternalSwap(ConnectionsLog_ErrorCode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_id_, lhs_arena,
                                       &other->_impl_.service_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connection_token_, lhs_arena,
                                       &other->_impl_.connection_token_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_ErrorCode, _impl_.flow_id_)
      + sizeof(ConnectionsLog_ErrorCode::_impl_.flow_id_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_ErrorCode, _impl_.direction_)>(
          reinterpret_cast<char*>(&_impl_.direction_),
          reinterpret_cast<char*>(&other->_impl_.direction_));
  swap(_impl_.ErrorCodeDetail_, other->_impl_.ErrorCodeDetail_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ConnectionsLog_ErrorCode::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.ErrorCode";
}

// ===================================================================

class ConnectionsLog_AdvertisingMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_AdvertisingMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_AdvertisingMetadata, _impl_._has_bits_);
  static void set_has_supports_extended_ble_advertisements(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_connected_ap_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_nfc_technology(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_multiple_advertisement_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_power_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ConnectionsLog_AdvertisingMetadata::ConnectionsLog_AdvertisingMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
}
ConnectionsLog_AdvertisingMetadata::ConnectionsLog_AdvertisingMetadata(const ConnectionsLog_AdvertisingMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
}

inline void ConnectionsLog_AdvertisingMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connected_ap_frequency_) { 0 }

    , decltype(_impl_.supports_extended_ble_advertisements_) { false }

    , decltype(_impl_.supports_nfc_technology_) { false }

    , decltype(_impl_.multiple_advertisement_supported_) { false }

    , decltype(_impl_.power_level_) { -1 }

  };
}

ConnectionsLog_AdvertisingMetadata::~ConnectionsLog_AdvertisingMetadata() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_AdvertisingMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionsLog_AdvertisingMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_AdvertisingMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.connected_ap_frequency_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.multiple_advertisement_supported_) -
        reinterpret_cast<char*>(&_impl_.connected_ap_frequency_)) + sizeof(_impl_.multiple_advertisement_supported_));
    _impl_.power_level_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_AdvertisingMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool supports_extended_ble_advertisements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_supports_extended_ble_advertisements(&has_bits);
          _impl_.supports_extended_ble_advertisements_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 connected_ap_frequency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_connected_ap_frequency(&has_bits);
          _impl_.connected_ap_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool supports_nfc_technology = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_supports_nfc_technology(&has_bits);
          _impl_.supports_nfc_technology_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool multiple_advertisement_supported = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_multiple_advertisement_supported(&has_bits);
          _impl_.multiple_advertisement_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.PowerLevel power_level = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::PowerLevel_IsValid(static_cast<int>(val)))) {
            _internal_set_power_level(static_cast<::location::nearby::proto::connections::PowerLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_AdvertisingMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool supports_extended_ble_advertisements = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_supports_extended_ble_advertisements(), target);
  }

  // optional int32 connected_ap_frequency = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_connected_ap_frequency(), target);
  }

  // optional bool supports_nfc_technology = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_supports_nfc_technology(), target);
  }

  // optional bool multiple_advertisement_supported = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_multiple_advertisement_supported(), target);
  }

  // optional .location.nearby.proto.connections.PowerLevel power_level = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_power_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  return target;
}

::size_t ConnectionsLog_AdvertisingMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 connected_ap_frequency = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_connected_ap_frequency());
    }

    // optional bool supports_extended_ble_advertisements = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

    // optional bool supports_nfc_technology = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

    // optional bool multiple_advertisement_supported = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

    // optional .location.nearby.proto.connections.PowerLevel power_level = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_power_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_AdvertisingMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_AdvertisingMetadata*>(
      &from));
}

void ConnectionsLog_AdvertisingMetadata::MergeFrom(const ConnectionsLog_AdvertisingMetadata& from) {
  ConnectionsLog_AdvertisingMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.connected_ap_frequency_ = from._impl_.connected_ap_frequency_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.supports_extended_ble_advertisements_ = from._impl_.supports_extended_ble_advertisements_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.supports_nfc_technology_ = from._impl_.supports_nfc_technology_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.multiple_advertisement_supported_ = from._impl_.multiple_advertisement_supported_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.power_level_ = from._impl_.power_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_AdvertisingMetadata::CopyFrom(const ConnectionsLog_AdvertisingMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_AdvertisingMetadata::IsInitialized() const {
  return true;
}

void ConnectionsLog_AdvertisingMetadata::InternalSwap(ConnectionsLog_AdvertisingMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_AdvertisingMetadata, _impl_.power_level_)
      + sizeof(ConnectionsLog_AdvertisingMetadata::_impl_.power_level_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_AdvertisingMetadata, _impl_.connected_ap_frequency_)>(
          reinterpret_cast<char*>(&_impl_.connected_ap_frequency_),
          reinterpret_cast<char*>(&other->_impl_.connected_ap_frequency_));
}

std::string ConnectionsLog_AdvertisingMetadata::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.AdvertisingMetadata";
}

// ===================================================================

class ConnectionsLog_DiscoveryMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_DiscoveryMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveryMetadata, _impl_._has_bits_);
  static void set_has_supports_extended_ble_advertisements(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_connected_ap_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_nfc_technology(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_power_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ConnectionsLog_DiscoveryMetadata::ConnectionsLog_DiscoveryMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
}
ConnectionsLog_DiscoveryMetadata::ConnectionsLog_DiscoveryMetadata(const ConnectionsLog_DiscoveryMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
}

inline void ConnectionsLog_DiscoveryMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.connected_ap_frequency_) { 0 }

    , decltype(_impl_.supports_extended_ble_advertisements_) { false }

    , decltype(_impl_.supports_nfc_technology_) { false }

    , decltype(_impl_.power_level_) { -1 }

  };
}

ConnectionsLog_DiscoveryMetadata::~ConnectionsLog_DiscoveryMetadata() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_DiscoveryMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConnectionsLog_DiscoveryMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_DiscoveryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.connected_ap_frequency_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.supports_nfc_technology_) -
        reinterpret_cast<char*>(&_impl_.connected_ap_frequency_)) + sizeof(_impl_.supports_nfc_technology_));
    _impl_.power_level_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_DiscoveryMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool supports_extended_ble_advertisements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_supports_extended_ble_advertisements(&has_bits);
          _impl_.supports_extended_ble_advertisements_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 connected_ap_frequency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_connected_ap_frequency(&has_bits);
          _impl_.connected_ap_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool supports_nfc_technology = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_supports_nfc_technology(&has_bits);
          _impl_.supports_nfc_technology_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.PowerLevel power_level = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::PowerLevel_IsValid(static_cast<int>(val)))) {
            _internal_set_power_level(static_cast<::location::nearby::proto::connections::PowerLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_DiscoveryMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool supports_extended_ble_advertisements = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_supports_extended_ble_advertisements(), target);
  }

  // optional int32 connected_ap_frequency = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_connected_ap_frequency(), target);
  }

  // optional bool supports_nfc_technology = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_supports_nfc_technology(), target);
  }

  // optional .location.nearby.proto.connections.PowerLevel power_level = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_power_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  return target;
}

::size_t ConnectionsLog_DiscoveryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 connected_ap_frequency = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_connected_ap_frequency());
    }

    // optional bool supports_extended_ble_advertisements = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

    // optional bool supports_nfc_technology = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

    // optional .location.nearby.proto.connections.PowerLevel power_level = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_power_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_DiscoveryMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_DiscoveryMetadata*>(
      &from));
}

void ConnectionsLog_DiscoveryMetadata::MergeFrom(const ConnectionsLog_DiscoveryMetadata& from) {
  ConnectionsLog_DiscoveryMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.connected_ap_frequency_ = from._impl_.connected_ap_frequency_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.supports_extended_ble_advertisements_ = from._impl_.supports_extended_ble_advertisements_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.supports_nfc_technology_ = from._impl_.supports_nfc_technology_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.power_level_ = from._impl_.power_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_DiscoveryMetadata::CopyFrom(const ConnectionsLog_DiscoveryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_DiscoveryMetadata::IsInitialized() const {
  return true;
}

void ConnectionsLog_DiscoveryMetadata::InternalSwap(ConnectionsLog_DiscoveryMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveryMetadata, _impl_.power_level_)
      + sizeof(ConnectionsLog_DiscoveryMetadata::_impl_.power_level_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_DiscoveryMetadata, _impl_.connected_ap_frequency_)>(
          reinterpret_cast<char*>(&_impl_.connected_ap_frequency_),
          reinterpret_cast<char*>(&other->_impl_.connected_ap_frequency_));
}

std::string ConnectionsLog_DiscoveryMetadata::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.DiscoveryMetadata";
}

// ===================================================================

class ConnectionsLog_ConnectionAttemptMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog_ConnectionAttemptMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionAttemptMetadata, _impl_._has_bits_);
  static void set_has_technology(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_band(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_network_operator(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_tdls_used(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_try_counts(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_wifi_hotspot_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_tx_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_rx_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_wifi_channel_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_send_buffer_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_receive_buffer_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_connected_ap_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_mcc_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

ConnectionsLog_ConnectionAttemptMetadata::ConnectionsLog_ConnectionAttemptMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
}
ConnectionsLog_ConnectionAttemptMetadata::ConnectionsLog_ConnectionAttemptMetadata(const ConnectionsLog_ConnectionAttemptMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog_ConnectionAttemptMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.network_operator_) {}

    , decltype(_impl_.country_code_) {}

    , decltype(_impl_.technology_) {}

    , decltype(_impl_.band_) {}

    , decltype(_impl_.frequency_) {}

    , decltype(_impl_.try_counts_) {}

    , decltype(_impl_.max_tx_speed_) {}

    , decltype(_impl_.is_tdls_used_) {}

    , decltype(_impl_.wifi_hotspot_status_) {}

    , decltype(_impl_.is_mcc_mode_) {}

    , decltype(_impl_.max_rx_speed_) {}

    , decltype(_impl_.wifi_channel_width_) {}

    , decltype(_impl_.send_buffer_size_) {}

    , decltype(_impl_.receive_buffer_size_) {}

    , decltype(_impl_.connected_ap_frequency_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.network_operator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.network_operator_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.network_operator_.Set(from._internal_network_operator(), _this->GetArenaForAllocation());
  }
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.country_code_.Set(from._internal_country_code(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.technology_, &from._impl_.technology_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.connected_ap_frequency_) -
    reinterpret_cast<char*>(&_impl_.technology_)) + sizeof(_impl_.connected_ap_frequency_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
}

inline void ConnectionsLog_ConnectionAttemptMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.network_operator_) {}

    , decltype(_impl_.country_code_) {}

    , decltype(_impl_.technology_) { 0 }

    , decltype(_impl_.band_) { 0 }

    , decltype(_impl_.frequency_) { 0 }

    , decltype(_impl_.try_counts_) { 0 }

    , decltype(_impl_.max_tx_speed_) { 0 }

    , decltype(_impl_.is_tdls_used_) { false }

    , decltype(_impl_.wifi_hotspot_status_) { false }

    , decltype(_impl_.is_mcc_mode_) { false }

    , decltype(_impl_.max_rx_speed_) { 0 }

    , decltype(_impl_.wifi_channel_width_) { 0 }

    , decltype(_impl_.send_buffer_size_) { 0 }

    , decltype(_impl_.receive_buffer_size_) { 0 }

    , decltype(_impl_.connected_ap_frequency_) { 0 }

  };
  _impl_.network_operator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.network_operator_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectionsLog_ConnectionAttemptMetadata::~ConnectionsLog_ConnectionAttemptMetadata() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog_ConnectionAttemptMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.network_operator_.Destroy();
  _impl_.country_code_.Destroy();
}

void ConnectionsLog_ConnectionAttemptMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog_ConnectionAttemptMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.network_operator_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.country_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.technology_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_tdls_used_) -
        reinterpret_cast<char*>(&_impl_.technology_)) + sizeof(_impl_.is_tdls_used_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.wifi_hotspot_status_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.connected_ap_frequency_) -
        reinterpret_cast<char*>(&_impl_.wifi_hotspot_status_)) + sizeof(_impl_.connected_ap_frequency_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog_ConnectionAttemptMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.proto.connections.ConnectionTechnology technology = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionTechnology_IsValid(static_cast<int>(val)))) {
            _internal_set_technology(static_cast<::location::nearby::proto::connections::ConnectionTechnology>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.ConnectionBand band = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::ConnectionBand_IsValid(static_cast<int>(val)))) {
            _internal_set_band(static_cast<::location::nearby::proto::connections::ConnectionBand>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 frequency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_frequency(&has_bits);
          _impl_.frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string network_operator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_network_operator();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string country_code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_tdls_used = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_is_tdls_used(&has_bits);
          _impl_.is_tdls_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 try_counts = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_try_counts(&has_bits);
          _impl_.try_counts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool wifi_hotspot_status = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_wifi_hotspot_status(&has_bits);
          _impl_.wifi_hotspot_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 max_tx_speed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _Internal::set_has_max_tx_speed(&has_bits);
          _impl_.max_tx_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 max_rx_speed = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_max_rx_speed(&has_bits);
          _impl_.max_rx_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 wifi_channel_width = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          _Internal::set_has_wifi_channel_width(&has_bits);
          _impl_.wifi_channel_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 send_buffer_size = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 96)) {
          _Internal::set_has_send_buffer_size(&has_bits);
          _impl_.send_buffer_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 receive_buffer_size = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _Internal::set_has_receive_buffer_size(&has_bits);
          _impl_.receive_buffer_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 connected_ap_frequency = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          _Internal::set_has_connected_ap_frequency(&has_bits);
          _impl_.connected_ap_frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_mcc_mode = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 120)) {
          _Internal::set_has_is_mcc_mode(&has_bits);
          _impl_.is_mcc_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog_ConnectionAttemptMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.proto.connections.ConnectionTechnology technology = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_technology(), target);
  }

  // optional .location.nearby.proto.connections.ConnectionBand band = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_band(), target);
  }

  // optional int32 frequency = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_frequency(), target);
  }

  // optional string network_operator = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_network_operator();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string country_code = 5;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_country_code();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional bool is_tdls_used = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_is_tdls_used(), target);
  }

  // optional int32 try_counts = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        7, this->_internal_try_counts(), target);
  }

  // optional bool wifi_hotspot_status = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_wifi_hotspot_status(), target);
  }

  // optional int32 max_tx_speed = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        9, this->_internal_max_tx_speed(), target);
  }

  // optional int32 max_rx_speed = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        10, this->_internal_max_rx_speed(), target);
  }

  // optional int32 wifi_channel_width = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        11, this->_internal_wifi_channel_width(), target);
  }

  // optional int32 send_buffer_size = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        12, this->_internal_send_buffer_size(), target);
  }

  // optional int32 receive_buffer_size = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_receive_buffer_size(), target);
  }

  // optional int32 connected_ap_frequency = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        14, this->_internal_connected_ap_frequency(), target);
  }

  // optional bool is_mcc_mode = 15;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        15, this->_internal_is_mcc_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  return target;
}

::size_t ConnectionsLog_ConnectionAttemptMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string network_operator = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_network_operator());
    }

    // optional string country_code = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_country_code());
    }

    // optional .location.nearby.proto.connections.ConnectionTechnology technology = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_technology());
    }

    // optional .location.nearby.proto.connections.ConnectionBand band = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_band());
    }

    // optional int32 frequency = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_frequency());
    }

    // optional int32 try_counts = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_try_counts());
    }

    // optional int32 max_tx_speed = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_max_tx_speed());
    }

    // optional bool is_tdls_used = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool wifi_hotspot_status = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2;
    }

    // optional bool is_mcc_mode = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2;
    }

    // optional int32 max_rx_speed = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_max_rx_speed());
    }

    // optional int32 wifi_channel_width = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_wifi_channel_width());
    }

    // optional int32 send_buffer_size = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_send_buffer_size());
    }

    // optional int32 receive_buffer_size = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_receive_buffer_size());
    }

    // optional int32 connected_ap_frequency = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_connected_ap_frequency());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog_ConnectionAttemptMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog_ConnectionAttemptMetadata*>(
      &from));
}

void ConnectionsLog_ConnectionAttemptMetadata::MergeFrom(const ConnectionsLog_ConnectionAttemptMetadata& from) {
  ConnectionsLog_ConnectionAttemptMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_network_operator(from._internal_network_operator());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_country_code(from._internal_country_code());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.technology_ = from._impl_.technology_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.band_ = from._impl_.band_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.frequency_ = from._impl_.frequency_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.try_counts_ = from._impl_.try_counts_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_tx_speed_ = from._impl_.max_tx_speed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_tdls_used_ = from._impl_.is_tdls_used_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.wifi_hotspot_status_ = from._impl_.wifi_hotspot_status_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_mcc_mode_ = from._impl_.is_mcc_mode_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.max_rx_speed_ = from._impl_.max_rx_speed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.wifi_channel_width_ = from._impl_.wifi_channel_width_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.send_buffer_size_ = from._impl_.send_buffer_size_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.receive_buffer_size_ = from._impl_.receive_buffer_size_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.connected_ap_frequency_ = from._impl_.connected_ap_frequency_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog_ConnectionAttemptMetadata::CopyFrom(const ConnectionsLog_ConnectionAttemptMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog_ConnectionAttemptMetadata::IsInitialized() const {
  return true;
}

void ConnectionsLog_ConnectionAttemptMetadata::InternalSwap(ConnectionsLog_ConnectionAttemptMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.network_operator_, lhs_arena,
                                       &other->_impl_.network_operator_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.country_code_, lhs_arena,
                                       &other->_impl_.country_code_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionAttemptMetadata, _impl_.connected_ap_frequency_)
      + sizeof(ConnectionsLog_ConnectionAttemptMetadata::_impl_.connected_ap_frequency_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog_ConnectionAttemptMetadata, _impl_.technology_)>(
          reinterpret_cast<char*>(&_impl_.technology_),
          reinterpret_cast<char*>(&other->_impl_.technology_));
}

std::string ConnectionsLog_ConnectionAttemptMetadata::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog.ConnectionAttemptMetadata";
}

// ===================================================================

class ConnectionsLog::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionsLog>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionsLog, _impl_._has_bits_);
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::location::nearby::analytics::proto::ConnectionsLog_ClientSession& client_session(const ConnectionsLog* msg);
  static void set_has_client_session(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::location::nearby::analytics::proto::ConnectionsLog_ErrorCode& error_code(const ConnectionsLog* msg);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_log_source(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_files_migration_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::location::nearby::analytics::proto::ConnectionsLog_ClientSession&
ConnectionsLog::_Internal::client_session(const ConnectionsLog* msg) {
  return *msg->_impl_.client_session_;
}
const ::location::nearby::analytics::proto::ConnectionsLog_ErrorCode&
ConnectionsLog::_Internal::error_code(const ConnectionsLog* msg) {
  return *msg->_impl_.error_code_;
}
ConnectionsLog::ConnectionsLog(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.analytics.proto.ConnectionsLog)
}
ConnectionsLog::ConnectionsLog(const ConnectionsLog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionsLog* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_) {}

    , decltype(_impl_.files_migration_phase_) {}

    , decltype(_impl_.client_session_){nullptr}
    , decltype(_impl_.error_code_){nullptr}
    , decltype(_impl_.event_type_) {}

    , decltype(_impl_.log_source_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
  }
  _impl_.files_migration_phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.files_migration_phase_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.files_migration_phase_.Set(from._internal_files_migration_phase(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.client_session_ = new ::location::nearby::analytics::proto::ConnectionsLog_ClientSession(*from._impl_.client_session_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.error_code_ = new ::location::nearby::analytics::proto::ConnectionsLog_ErrorCode(*from._impl_.error_code_);
  }
  ::memcpy(&_impl_.event_type_, &from._impl_.event_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.log_source_) -
    reinterpret_cast<char*>(&_impl_.event_type_)) + sizeof(_impl_.log_source_));
  // @@protoc_insertion_point(copy_constructor:location.nearby.analytics.proto.ConnectionsLog)
}

inline void ConnectionsLog::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.version_) {}

    , decltype(_impl_.files_migration_phase_) {}

    , decltype(_impl_.client_session_){nullptr}
    , decltype(_impl_.error_code_){nullptr}
    , decltype(_impl_.event_type_) { 0 }

    , decltype(_impl_.log_source_) { 0 }

  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.files_migration_phase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.files_migration_phase_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConnectionsLog::~ConnectionsLog() {
  // @@protoc_insertion_point(destructor:location.nearby.analytics.proto.ConnectionsLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionsLog::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.Destroy();
  _impl_.files_migration_phase_.Destroy();
  if (this != internal_default_instance()) delete _impl_.client_session_;
  if (this != internal_default_instance()) delete _impl_.error_code_;
}

void ConnectionsLog::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionsLog::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.analytics.proto.ConnectionsLog)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.files_migration_phase_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.client_session_ != nullptr);
      _impl_.client_session_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.error_code_ != nullptr);
      _impl_.error_code_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.event_type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.log_source_) -
        reinterpret_cast<char*>(&_impl_.event_type_)) + sizeof(_impl_.log_source_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionsLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.proto.connections.EventType event_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::EventType_IsValid(static_cast<int>(val)))) {
            _internal_set_event_type(static_cast<::location::nearby::proto::connections::EventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.analytics.proto.ConnectionsLog.ClientSession client_session = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_session(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.analytics.proto.ConnectionsLog.ErrorCode error_code = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_error_code(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.connections.LogSource log_source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::connections::LogSource_IsValid(static_cast<int>(val)))) {
            _internal_set_log_source(static_cast<::location::nearby::proto::connections::LogSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string files_migration_phase = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_files_migration_phase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionsLog::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.analytics.proto.ConnectionsLog)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.proto.connections.EventType event_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_event_type(), target);
  }

  // optional .location.nearby.analytics.proto.ConnectionsLog.ClientSession client_session = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::client_session(this),
        _Internal::client_session(this).GetCachedSize(), target, stream);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_version();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional .location.nearby.analytics.proto.ConnectionsLog.ErrorCode error_code = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::error_code(this),
        _Internal::error_code(this).GetCachedSize(), target, stream);
  }

  // optional .location.nearby.proto.connections.LogSource log_source = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_log_source(), target);
  }

  // optional string files_migration_phase = 6;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_files_migration_phase();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.analytics.proto.ConnectionsLog)
  return target;
}

::size_t ConnectionsLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.analytics.proto.ConnectionsLog)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string version = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_version());
    }

    // optional string files_migration_phase = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_files_migration_phase());
    }

    // optional .location.nearby.analytics.proto.ConnectionsLog.ClientSession client_session = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_session_);
    }

    // optional .location.nearby.analytics.proto.ConnectionsLog.ErrorCode error_code = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.error_code_);
    }

    // optional .location.nearby.proto.connections.EventType event_type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional .location.nearby.proto.connections.LogSource log_source = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_log_source());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionsLog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionsLog*>(
      &from));
}

void ConnectionsLog::MergeFrom(const ConnectionsLog& from) {
  ConnectionsLog* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.analytics.proto.ConnectionsLog)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_files_migration_phase(from._internal_files_migration_phase());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_client_session()->::location::nearby::analytics::proto::ConnectionsLog_ClientSession::MergeFrom(
          from._internal_client_session());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_error_code()->::location::nearby::analytics::proto::ConnectionsLog_ErrorCode::MergeFrom(
          from._internal_error_code());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.log_source_ = from._impl_.log_source_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionsLog::CopyFrom(const ConnectionsLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.analytics.proto.ConnectionsLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionsLog::IsInitialized() const {
  return true;
}

void ConnectionsLog::InternalSwap(ConnectionsLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena,
                                       &other->_impl_.version_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.files_migration_phase_, lhs_arena,
                                       &other->_impl_.files_migration_phase_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionsLog, _impl_.log_source_)
      + sizeof(ConnectionsLog::_impl_.log_source_)
      - PROTOBUF_FIELD_OFFSET(ConnectionsLog, _impl_.client_session_)>(
          reinterpret_cast<char*>(&_impl_.client_session_),
          reinterpret_cast<char*>(&other->_impl_.client_session_));
}

std::string ConnectionsLog::GetTypeName() const {
  return "location.nearby.analytics.proto.ConnectionsLog";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace analytics
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_ClientSession*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_ClientSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_ClientSession >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_StrategySession*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_StrategySession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_StrategySession >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryPhase*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryPhase >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryPhase >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_DiscoveredEndpoint*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_DiscoveredEndpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_DiscoveredEndpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_UwbRangingProcess*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_UwbRangingProcess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_UwbRangingProcess >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_RawUwbRangingEvent*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_RawUwbRangingEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_RawUwbRangingEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingPhase*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingPhase >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingPhase >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_ConnectionRequest*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_ConnectionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_ConnectionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttempt*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttempt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttempt >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_EstablishedConnection*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_EstablishedConnection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_EstablishedConnection >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_Payload*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_Payload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_Payload >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_BandwidthUpgradeAttempt*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_BandwidthUpgradeAttempt >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_BandwidthUpgradeAttempt >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_ErrorCode*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_ErrorCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_ErrorCode >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_AdvertisingMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_DiscoveryMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog_ConnectionAttemptMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::analytics::proto::ConnectionsLog*
Arena::CreateMaybeMessage< ::location::nearby::analytics::proto::ConnectionsLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::analytics::proto::ConnectionsLog >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
