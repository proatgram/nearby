// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connections/implementation/proto/offline_wire_formats.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto {
  static const ::uint32_t offsets[];
};
namespace location {
namespace nearby {
namespace connections {
class AuthenticationMessageFrame;
struct AuthenticationMessageFrameDefaultTypeInternal;
extern AuthenticationMessageFrameDefaultTypeInternal _AuthenticationMessageFrame_default_instance_;
class AuthenticationResultFrame;
struct AuthenticationResultFrameDefaultTypeInternal;
extern AuthenticationResultFrameDefaultTypeInternal _AuthenticationResultFrame_default_instance_;
class AutoReconnectFrame;
struct AutoReconnectFrameDefaultTypeInternal;
extern AutoReconnectFrameDefaultTypeInternal _AutoReconnectFrame_default_instance_;
class AutoResumeFrame;
struct AutoResumeFrameDefaultTypeInternal;
extern AutoResumeFrameDefaultTypeInternal _AutoResumeFrame_default_instance_;
class AvailableChannels;
struct AvailableChannelsDefaultTypeInternal;
extern AvailableChannelsDefaultTypeInternal _AvailableChannels_default_instance_;
class BandwidthUpgradeNegotiationFrame;
struct BandwidthUpgradeNegotiationFrameDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrameDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_default_instance_;
class BandwidthUpgradeNegotiationFrame_ClientIntroduction;
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_ClientIntroductionDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_;
class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck;
struct BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_ClientIntroductionAckDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfoDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentialsDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_;
class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket;
struct BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal;
extern BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocketDefaultTypeInternal _BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_;
class BandwidthUpgradeRetryFrame;
struct BandwidthUpgradeRetryFrameDefaultTypeInternal;
extern BandwidthUpgradeRetryFrameDefaultTypeInternal _BandwidthUpgradeRetryFrame_default_instance_;
class ConnectionRequestFrame;
struct ConnectionRequestFrameDefaultTypeInternal;
extern ConnectionRequestFrameDefaultTypeInternal _ConnectionRequestFrame_default_instance_;
class ConnectionResponseFrame;
struct ConnectionResponseFrameDefaultTypeInternal;
extern ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
class ConnectionsDevice;
struct ConnectionsDeviceDefaultTypeInternal;
extern ConnectionsDeviceDefaultTypeInternal _ConnectionsDevice_default_instance_;
class DisconnectionFrame;
struct DisconnectionFrameDefaultTypeInternal;
extern DisconnectionFrameDefaultTypeInternal _DisconnectionFrame_default_instance_;
class KeepAliveFrame;
struct KeepAliveFrameDefaultTypeInternal;
extern KeepAliveFrameDefaultTypeInternal _KeepAliveFrame_default_instance_;
class LocationHint;
struct LocationHintDefaultTypeInternal;
extern LocationHintDefaultTypeInternal _LocationHint_default_instance_;
class LocationStandard;
struct LocationStandardDefaultTypeInternal;
extern LocationStandardDefaultTypeInternal _LocationStandard_default_instance_;
class MediumMetadata;
struct MediumMetadataDefaultTypeInternal;
extern MediumMetadataDefaultTypeInternal _MediumMetadata_default_instance_;
class OfflineFrame;
struct OfflineFrameDefaultTypeInternal;
extern OfflineFrameDefaultTypeInternal _OfflineFrame_default_instance_;
class OsInfo;
struct OsInfoDefaultTypeInternal;
extern OsInfoDefaultTypeInternal _OsInfo_default_instance_;
class PairedKeyEncryptionFrame;
struct PairedKeyEncryptionFrameDefaultTypeInternal;
extern PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
class PayloadTransferFrame;
struct PayloadTransferFrameDefaultTypeInternal;
extern PayloadTransferFrameDefaultTypeInternal _PayloadTransferFrame_default_instance_;
class PayloadTransferFrame_ControlMessage;
struct PayloadTransferFrame_ControlMessageDefaultTypeInternal;
extern PayloadTransferFrame_ControlMessageDefaultTypeInternal _PayloadTransferFrame_ControlMessage_default_instance_;
class PayloadTransferFrame_PayloadChunk;
struct PayloadTransferFrame_PayloadChunkDefaultTypeInternal;
extern PayloadTransferFrame_PayloadChunkDefaultTypeInternal _PayloadTransferFrame_PayloadChunk_default_instance_;
class PayloadTransferFrame_PayloadHeader;
struct PayloadTransferFrame_PayloadHeaderDefaultTypeInternal;
extern PayloadTransferFrame_PayloadHeaderDefaultTypeInternal _PayloadTransferFrame_PayloadHeader_default_instance_;
class PresenceDevice;
struct PresenceDeviceDefaultTypeInternal;
extern PresenceDeviceDefaultTypeInternal _PresenceDevice_default_instance_;
class V1Frame;
struct V1FrameDefaultTypeInternal;
extern V1FrameDefaultTypeInternal _V1Frame_default_instance_;
class WifiAwareUsableChannels;
struct WifiAwareUsableChannelsDefaultTypeInternal;
extern WifiAwareUsableChannelsDefaultTypeInternal _WifiAwareUsableChannels_default_instance_;
class WifiDirectCliUsableChannels;
struct WifiDirectCliUsableChannelsDefaultTypeInternal;
extern WifiDirectCliUsableChannelsDefaultTypeInternal _WifiDirectCliUsableChannels_default_instance_;
class WifiHotspotStaUsableChannels;
struct WifiHotspotStaUsableChannelsDefaultTypeInternal;
extern WifiHotspotStaUsableChannelsDefaultTypeInternal _WifiHotspotStaUsableChannels_default_instance_;
class WifiLanUsableChannels;
struct WifiLanUsableChannelsDefaultTypeInternal;
extern WifiLanUsableChannelsDefaultTypeInternal _WifiLanUsableChannels_default_instance_;
}  // namespace connections
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template <>
::location::nearby::connections::AuthenticationMessageFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AuthenticationMessageFrame>(Arena*);
template <>
::location::nearby::connections::AuthenticationResultFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AuthenticationResultFrame>(Arena*);
template <>
::location::nearby::connections::AutoReconnectFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AutoReconnectFrame>(Arena*);
template <>
::location::nearby::connections::AutoResumeFrame* Arena::CreateMaybeMessage<::location::nearby::connections::AutoResumeFrame>(Arena*);
template <>
::location::nearby::connections::AvailableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::AvailableChannels>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(Arena*);
template <>
::location::nearby::connections::BandwidthUpgradeRetryFrame* Arena::CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeRetryFrame>(Arena*);
template <>
::location::nearby::connections::ConnectionRequestFrame* Arena::CreateMaybeMessage<::location::nearby::connections::ConnectionRequestFrame>(Arena*);
template <>
::location::nearby::connections::ConnectionResponseFrame* Arena::CreateMaybeMessage<::location::nearby::connections::ConnectionResponseFrame>(Arena*);
template <>
::location::nearby::connections::ConnectionsDevice* Arena::CreateMaybeMessage<::location::nearby::connections::ConnectionsDevice>(Arena*);
template <>
::location::nearby::connections::DisconnectionFrame* Arena::CreateMaybeMessage<::location::nearby::connections::DisconnectionFrame>(Arena*);
template <>
::location::nearby::connections::KeepAliveFrame* Arena::CreateMaybeMessage<::location::nearby::connections::KeepAliveFrame>(Arena*);
template <>
::location::nearby::connections::LocationHint* Arena::CreateMaybeMessage<::location::nearby::connections::LocationHint>(Arena*);
template <>
::location::nearby::connections::LocationStandard* Arena::CreateMaybeMessage<::location::nearby::connections::LocationStandard>(Arena*);
template <>
::location::nearby::connections::MediumMetadata* Arena::CreateMaybeMessage<::location::nearby::connections::MediumMetadata>(Arena*);
template <>
::location::nearby::connections::OfflineFrame* Arena::CreateMaybeMessage<::location::nearby::connections::OfflineFrame>(Arena*);
template <>
::location::nearby::connections::OsInfo* Arena::CreateMaybeMessage<::location::nearby::connections::OsInfo>(Arena*);
template <>
::location::nearby::connections::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage<::location::nearby::connections::PairedKeyEncryptionFrame>(Arena*);
template <>
::location::nearby::connections::PayloadTransferFrame* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame>(Arena*);
template <>
::location::nearby::connections::PayloadTransferFrame_ControlMessage* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_ControlMessage>(Arena*);
template <>
::location::nearby::connections::PayloadTransferFrame_PayloadChunk* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>(Arena*);
template <>
::location::nearby::connections::PayloadTransferFrame_PayloadHeader* Arena::CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>(Arena*);
template <>
::location::nearby::connections::PresenceDevice* Arena::CreateMaybeMessage<::location::nearby::connections::PresenceDevice>(Arena*);
template <>
::location::nearby::connections::V1Frame* Arena::CreateMaybeMessage<::location::nearby::connections::V1Frame>(Arena*);
template <>
::location::nearby::connections::WifiAwareUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiAwareUsableChannels>(Arena*);
template <>
::location::nearby::connections::WifiDirectCliUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiDirectCliUsableChannels>(Arena*);
template <>
::location::nearby::connections::WifiHotspotStaUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiHotspotStaUsableChannels>(Arena*);
template <>
::location::nearby::connections::WifiLanUsableChannels* Arena::CreateMaybeMessage<::location::nearby::connections::WifiLanUsableChannels>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace location {
namespace nearby {
namespace connections {
enum OfflineFrame_Version : int {
  OfflineFrame_Version_UNKNOWN_VERSION = 0,
  OfflineFrame_Version_V1 = 1,
};

bool OfflineFrame_Version_IsValid(int value);
constexpr OfflineFrame_Version OfflineFrame_Version_Version_MIN = static_cast<OfflineFrame_Version>(0);
constexpr OfflineFrame_Version OfflineFrame_Version_Version_MAX = static_cast<OfflineFrame_Version>(1);
constexpr int OfflineFrame_Version_Version_ARRAYSIZE = 1 + 1;
const std::string& OfflineFrame_Version_Name(OfflineFrame_Version value);
template <typename T>
const std::string& OfflineFrame_Version_Name(T value) {
  static_assert(std::is_same<T, OfflineFrame_Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return OfflineFrame_Version_Name(static_cast<OfflineFrame_Version>(value));
}
const std::string& OfflineFrame_Version_Name(OfflineFrame_Version value);
bool OfflineFrame_Version_Parse(absl::string_view name, OfflineFrame_Version* value);
enum V1Frame_FrameType : int {
  V1Frame_FrameType_UNKNOWN_FRAME_TYPE = 0,
  V1Frame_FrameType_CONNECTION_REQUEST = 1,
  V1Frame_FrameType_CONNECTION_RESPONSE = 2,
  V1Frame_FrameType_PAYLOAD_TRANSFER = 3,
  V1Frame_FrameType_BANDWIDTH_UPGRADE_NEGOTIATION = 4,
  V1Frame_FrameType_KEEP_ALIVE = 5,
  V1Frame_FrameType_DISCONNECTION = 6,
  V1Frame_FrameType_PAIRED_KEY_ENCRYPTION = 7,
  V1Frame_FrameType_AUTHENTICATION_MESSAGE = 8,
  V1Frame_FrameType_AUTHENTICATION_RESULT = 9,
  V1Frame_FrameType_AUTO_RESUME = 10,
  V1Frame_FrameType_AUTO_RECONNECT = 11,
  V1Frame_FrameType_BANDWIDTH_UPGRADE_RETRY = 12,
};

bool V1Frame_FrameType_IsValid(int value);
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MIN = static_cast<V1Frame_FrameType>(0);
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MAX = static_cast<V1Frame_FrameType>(12);
constexpr int V1Frame_FrameType_FrameType_ARRAYSIZE = 12 + 1;
const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value);
template <typename T>
const std::string& V1Frame_FrameType_Name(T value) {
  static_assert(std::is_same<T, V1Frame_FrameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FrameType_Name().");
  return V1Frame_FrameType_Name(static_cast<V1Frame_FrameType>(value));
}
const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value);
bool V1Frame_FrameType_Parse(absl::string_view name, V1Frame_FrameType* value);
enum ConnectionRequestFrame_Medium : int {
  ConnectionRequestFrame_Medium_UNKNOWN_MEDIUM = 0,
  ConnectionRequestFrame_Medium_MDNS [[deprecated]] = 1,
  ConnectionRequestFrame_Medium_BLUETOOTH = 2,
  ConnectionRequestFrame_Medium_WIFI_HOTSPOT = 3,
  ConnectionRequestFrame_Medium_BLE = 4,
  ConnectionRequestFrame_Medium_WIFI_LAN = 5,
  ConnectionRequestFrame_Medium_WIFI_AWARE = 6,
  ConnectionRequestFrame_Medium_NFC = 7,
  ConnectionRequestFrame_Medium_WIFI_DIRECT = 8,
  ConnectionRequestFrame_Medium_WEB_RTC = 9,
  ConnectionRequestFrame_Medium_BLE_L2CAP = 10,
  ConnectionRequestFrame_Medium_USB = 11,
};

bool ConnectionRequestFrame_Medium_IsValid(int value);
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame_Medium_Medium_MIN = static_cast<ConnectionRequestFrame_Medium>(0);
constexpr ConnectionRequestFrame_Medium ConnectionRequestFrame_Medium_Medium_MAX = static_cast<ConnectionRequestFrame_Medium>(11);
constexpr int ConnectionRequestFrame_Medium_Medium_ARRAYSIZE = 11 + 1;
const std::string& ConnectionRequestFrame_Medium_Name(ConnectionRequestFrame_Medium value);
template <typename T>
const std::string& ConnectionRequestFrame_Medium_Name(T value) {
  static_assert(std::is_same<T, ConnectionRequestFrame_Medium>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Medium_Name().");
  return ConnectionRequestFrame_Medium_Name(static_cast<ConnectionRequestFrame_Medium>(value));
}
const std::string& ConnectionRequestFrame_Medium_Name(ConnectionRequestFrame_Medium value);
bool ConnectionRequestFrame_Medium_Parse(absl::string_view name, ConnectionRequestFrame_Medium* value);
enum ConnectionResponseFrame_ResponseStatus : int {
  ConnectionResponseFrame_ResponseStatus_UNKNOWN_RESPONSE_STATUS = 0,
  ConnectionResponseFrame_ResponseStatus_ACCEPT = 1,
  ConnectionResponseFrame_ResponseStatus_REJECT = 2,
};

bool ConnectionResponseFrame_ResponseStatus_IsValid(int value);
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame_ResponseStatus_ResponseStatus_MIN = static_cast<ConnectionResponseFrame_ResponseStatus>(0);
constexpr ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame_ResponseStatus_ResponseStatus_MAX = static_cast<ConnectionResponseFrame_ResponseStatus>(2);
constexpr int ConnectionResponseFrame_ResponseStatus_ResponseStatus_ARRAYSIZE = 2 + 1;
const std::string& ConnectionResponseFrame_ResponseStatus_Name(ConnectionResponseFrame_ResponseStatus value);
template <typename T>
const std::string& ConnectionResponseFrame_ResponseStatus_Name(T value) {
  static_assert(std::is_same<T, ConnectionResponseFrame_ResponseStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseStatus_Name().");
  return ConnectionResponseFrame_ResponseStatus_Name(static_cast<ConnectionResponseFrame_ResponseStatus>(value));
}
const std::string& ConnectionResponseFrame_ResponseStatus_Name(ConnectionResponseFrame_ResponseStatus value);
bool ConnectionResponseFrame_ResponseStatus_Parse(absl::string_view name, ConnectionResponseFrame_ResponseStatus* value);
enum PayloadTransferFrame_PayloadHeader_PayloadType : int {
  PayloadTransferFrame_PayloadHeader_PayloadType_UNKNOWN_PAYLOAD_TYPE = 0,
  PayloadTransferFrame_PayloadHeader_PayloadType_BYTES = 1,
  PayloadTransferFrame_PayloadHeader_PayloadType_FILE = 2,
  PayloadTransferFrame_PayloadHeader_PayloadType_STREAM = 3,
};

bool PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(int value);
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MIN = static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(0);
constexpr PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MAX = static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(3);
constexpr int PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_ARRAYSIZE = 3 + 1;
const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(PayloadTransferFrame_PayloadHeader_PayloadType value);
template <typename T>
const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(T value) {
  static_assert(std::is_same<T, PayloadTransferFrame_PayloadHeader_PayloadType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PayloadType_Name().");
  return PayloadTransferFrame_PayloadHeader_PayloadType_Name(static_cast<PayloadTransferFrame_PayloadHeader_PayloadType>(value));
}
const std::string& PayloadTransferFrame_PayloadHeader_PayloadType_Name(PayloadTransferFrame_PayloadHeader_PayloadType value);
bool PayloadTransferFrame_PayloadHeader_PayloadType_Parse(absl::string_view name, PayloadTransferFrame_PayloadHeader_PayloadType* value);
enum PayloadTransferFrame_PayloadChunk_Flags : int {
  PayloadTransferFrame_PayloadChunk_Flags_LAST_CHUNK = 1,
};

bool PayloadTransferFrame_PayloadChunk_Flags_IsValid(int value);
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk_Flags_Flags_MIN = static_cast<PayloadTransferFrame_PayloadChunk_Flags>(1);
constexpr PayloadTransferFrame_PayloadChunk_Flags PayloadTransferFrame_PayloadChunk_Flags_Flags_MAX = static_cast<PayloadTransferFrame_PayloadChunk_Flags>(1);
constexpr int PayloadTransferFrame_PayloadChunk_Flags_Flags_ARRAYSIZE = 1 + 1;
const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(PayloadTransferFrame_PayloadChunk_Flags value);
template <typename T>
const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(T value) {
  static_assert(std::is_same<T, PayloadTransferFrame_PayloadChunk_Flags>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Flags_Name().");
  return PayloadTransferFrame_PayloadChunk_Flags_Name(static_cast<PayloadTransferFrame_PayloadChunk_Flags>(value));
}
const std::string& PayloadTransferFrame_PayloadChunk_Flags_Name(PayloadTransferFrame_PayloadChunk_Flags value);
bool PayloadTransferFrame_PayloadChunk_Flags_Parse(absl::string_view name, PayloadTransferFrame_PayloadChunk_Flags* value);
enum PayloadTransferFrame_ControlMessage_EventType : int {
  PayloadTransferFrame_ControlMessage_EventType_UNKNOWN_EVENT_TYPE = 0,
  PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_ERROR = 1,
  PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_CANCELED = 2,
  PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_RECEIVED_ACK = 3,
};

bool PayloadTransferFrame_ControlMessage_EventType_IsValid(int value);
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage_EventType_EventType_MIN = static_cast<PayloadTransferFrame_ControlMessage_EventType>(0);
constexpr PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage_EventType_EventType_MAX = static_cast<PayloadTransferFrame_ControlMessage_EventType>(3);
constexpr int PayloadTransferFrame_ControlMessage_EventType_EventType_ARRAYSIZE = 3 + 1;
const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(PayloadTransferFrame_ControlMessage_EventType value);
template <typename T>
const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(T value) {
  static_assert(std::is_same<T, PayloadTransferFrame_ControlMessage_EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return PayloadTransferFrame_ControlMessage_EventType_Name(static_cast<PayloadTransferFrame_ControlMessage_EventType>(value));
}
const std::string& PayloadTransferFrame_ControlMessage_EventType_Name(PayloadTransferFrame_ControlMessage_EventType value);
bool PayloadTransferFrame_ControlMessage_EventType_Parse(absl::string_view name, PayloadTransferFrame_ControlMessage_EventType* value);
enum PayloadTransferFrame_PacketType : int {
  PayloadTransferFrame_PacketType_UNKNOWN_PACKET_TYPE = 0,
  PayloadTransferFrame_PacketType_DATA = 1,
  PayloadTransferFrame_PacketType_CONTROL = 2,
};

bool PayloadTransferFrame_PacketType_IsValid(int value);
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame_PacketType_PacketType_MIN = static_cast<PayloadTransferFrame_PacketType>(0);
constexpr PayloadTransferFrame_PacketType PayloadTransferFrame_PacketType_PacketType_MAX = static_cast<PayloadTransferFrame_PacketType>(2);
constexpr int PayloadTransferFrame_PacketType_PacketType_ARRAYSIZE = 2 + 1;
const std::string& PayloadTransferFrame_PacketType_Name(PayloadTransferFrame_PacketType value);
template <typename T>
const std::string& PayloadTransferFrame_PacketType_Name(T value) {
  static_assert(std::is_same<T, PayloadTransferFrame_PacketType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PacketType_Name().");
  return PayloadTransferFrame_PacketType_Name(static_cast<PayloadTransferFrame_PacketType>(value));
}
const std::string& PayloadTransferFrame_PacketType_Name(PayloadTransferFrame_PacketType value);
bool PayloadTransferFrame_PacketType_Parse(absl::string_view name, PayloadTransferFrame_PacketType* value);
enum BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium : int {
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_UNKNOWN_MEDIUM = 0,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_MDNS [[deprecated]] = 1,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLUETOOTH = 2,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_HOTSPOT = 3,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLE = 4,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_LAN = 5,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_AWARE = 6,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_NFC = 7,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_DIRECT = 8,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WEB_RTC = 9,
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_USB = 11,
};

bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(int value);
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MIN = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(0);
constexpr BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MAX = static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(11);
constexpr int BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_ARRAYSIZE = 11 + 1;
const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);
template <typename T>
const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(T value) {
  static_assert(std::is_same<T, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Medium_Name().");
  return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(static_cast<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(value));
}
const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);
bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(absl::string_view name, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium* value);
enum BandwidthUpgradeNegotiationFrame_EventType : int {
  BandwidthUpgradeNegotiationFrame_EventType_UNKNOWN_EVENT_TYPE = 0,
  BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_PATH_AVAILABLE = 1,
  BandwidthUpgradeNegotiationFrame_EventType_LAST_WRITE_TO_PRIOR_CHANNEL = 2,
  BandwidthUpgradeNegotiationFrame_EventType_SAFE_TO_CLOSE_PRIOR_CHANNEL = 3,
  BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION = 4,
  BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_FAILURE = 5,
  BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION_ACK = 6,
};

bool BandwidthUpgradeNegotiationFrame_EventType_IsValid(int value);
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame_EventType_EventType_MIN = static_cast<BandwidthUpgradeNegotiationFrame_EventType>(0);
constexpr BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame_EventType_EventType_MAX = static_cast<BandwidthUpgradeNegotiationFrame_EventType>(6);
constexpr int BandwidthUpgradeNegotiationFrame_EventType_EventType_ARRAYSIZE = 6 + 1;
const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(BandwidthUpgradeNegotiationFrame_EventType value);
template <typename T>
const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(T value) {
  static_assert(std::is_same<T, BandwidthUpgradeNegotiationFrame_EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return BandwidthUpgradeNegotiationFrame_EventType_Name(static_cast<BandwidthUpgradeNegotiationFrame_EventType>(value));
}
const std::string& BandwidthUpgradeNegotiationFrame_EventType_Name(BandwidthUpgradeNegotiationFrame_EventType value);
bool BandwidthUpgradeNegotiationFrame_EventType_Parse(absl::string_view name, BandwidthUpgradeNegotiationFrame_EventType* value);
enum BandwidthUpgradeRetryFrame_Medium : int {
  BandwidthUpgradeRetryFrame_Medium_UNKNOWN_MEDIUM = 0,
  BandwidthUpgradeRetryFrame_Medium_BLUETOOTH = 2,
  BandwidthUpgradeRetryFrame_Medium_WIFI_HOTSPOT = 3,
  BandwidthUpgradeRetryFrame_Medium_BLE = 4,
  BandwidthUpgradeRetryFrame_Medium_WIFI_LAN = 5,
  BandwidthUpgradeRetryFrame_Medium_WIFI_AWARE = 6,
  BandwidthUpgradeRetryFrame_Medium_NFC = 7,
  BandwidthUpgradeRetryFrame_Medium_WIFI_DIRECT = 8,
  BandwidthUpgradeRetryFrame_Medium_WEB_RTC = 9,
  BandwidthUpgradeRetryFrame_Medium_BLE_L2CAP = 10,
  BandwidthUpgradeRetryFrame_Medium_USB = 11,
};

bool BandwidthUpgradeRetryFrame_Medium_IsValid(int value);
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame_Medium_Medium_MIN = static_cast<BandwidthUpgradeRetryFrame_Medium>(0);
constexpr BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame_Medium_Medium_MAX = static_cast<BandwidthUpgradeRetryFrame_Medium>(11);
constexpr int BandwidthUpgradeRetryFrame_Medium_Medium_ARRAYSIZE = 11 + 1;
const std::string& BandwidthUpgradeRetryFrame_Medium_Name(BandwidthUpgradeRetryFrame_Medium value);
template <typename T>
const std::string& BandwidthUpgradeRetryFrame_Medium_Name(T value) {
  static_assert(std::is_same<T, BandwidthUpgradeRetryFrame_Medium>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Medium_Name().");
  return BandwidthUpgradeRetryFrame_Medium_Name(static_cast<BandwidthUpgradeRetryFrame_Medium>(value));
}
const std::string& BandwidthUpgradeRetryFrame_Medium_Name(BandwidthUpgradeRetryFrame_Medium value);
bool BandwidthUpgradeRetryFrame_Medium_Parse(absl::string_view name, BandwidthUpgradeRetryFrame_Medium* value);
enum AutoResumeFrame_EventType : int {
  AutoResumeFrame_EventType_UNKNOWN_AUTO_RESUME_EVENT_TYPE = 0,
  AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_START = 1,
  AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_ACK = 2,
};

bool AutoResumeFrame_EventType_IsValid(int value);
constexpr AutoResumeFrame_EventType AutoResumeFrame_EventType_EventType_MIN = static_cast<AutoResumeFrame_EventType>(0);
constexpr AutoResumeFrame_EventType AutoResumeFrame_EventType_EventType_MAX = static_cast<AutoResumeFrame_EventType>(2);
constexpr int AutoResumeFrame_EventType_EventType_ARRAYSIZE = 2 + 1;
const std::string& AutoResumeFrame_EventType_Name(AutoResumeFrame_EventType value);
template <typename T>
const std::string& AutoResumeFrame_EventType_Name(T value) {
  static_assert(std::is_same<T, AutoResumeFrame_EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return AutoResumeFrame_EventType_Name(static_cast<AutoResumeFrame_EventType>(value));
}
const std::string& AutoResumeFrame_EventType_Name(AutoResumeFrame_EventType value);
bool AutoResumeFrame_EventType_Parse(absl::string_view name, AutoResumeFrame_EventType* value);
enum AutoReconnectFrame_EventType : int {
  AutoReconnectFrame_EventType_UNKNOWN_EVENT_TYPE = 0,
  AutoReconnectFrame_EventType_CLIENT_INTRODUCTION = 1,
  AutoReconnectFrame_EventType_CLIENT_INTRODUCTION_ACK = 2,
};

bool AutoReconnectFrame_EventType_IsValid(int value);
constexpr AutoReconnectFrame_EventType AutoReconnectFrame_EventType_EventType_MIN = static_cast<AutoReconnectFrame_EventType>(0);
constexpr AutoReconnectFrame_EventType AutoReconnectFrame_EventType_EventType_MAX = static_cast<AutoReconnectFrame_EventType>(2);
constexpr int AutoReconnectFrame_EventType_EventType_ARRAYSIZE = 2 + 1;
const std::string& AutoReconnectFrame_EventType_Name(AutoReconnectFrame_EventType value);
template <typename T>
const std::string& AutoReconnectFrame_EventType_Name(T value) {
  static_assert(std::is_same<T, AutoReconnectFrame_EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return AutoReconnectFrame_EventType_Name(static_cast<AutoReconnectFrame_EventType>(value));
}
const std::string& AutoReconnectFrame_EventType_Name(AutoReconnectFrame_EventType value);
bool AutoReconnectFrame_EventType_Parse(absl::string_view name, AutoReconnectFrame_EventType* value);
enum LocationStandard_Format : int {
  LocationStandard_Format_UNKNOWN = 0,
  LocationStandard_Format_E164_CALLING = 1,
  LocationStandard_Format_ISO_3166_1_ALPHA_2 = 2,
};

bool LocationStandard_Format_IsValid(int value);
constexpr LocationStandard_Format LocationStandard_Format_Format_MIN = static_cast<LocationStandard_Format>(0);
constexpr LocationStandard_Format LocationStandard_Format_Format_MAX = static_cast<LocationStandard_Format>(2);
constexpr int LocationStandard_Format_Format_ARRAYSIZE = 2 + 1;
const std::string& LocationStandard_Format_Name(LocationStandard_Format value);
template <typename T>
const std::string& LocationStandard_Format_Name(T value) {
  static_assert(std::is_same<T, LocationStandard_Format>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Format_Name().");
  return LocationStandard_Format_Name(static_cast<LocationStandard_Format>(value));
}
const std::string& LocationStandard_Format_Name(LocationStandard_Format value);
bool LocationStandard_Format_Parse(absl::string_view name, LocationStandard_Format* value);
enum OsInfo_OsType : int {
  OsInfo_OsType_UNKNOWN_OS_TYPE = 0,
  OsInfo_OsType_ANDROID = 1,
  OsInfo_OsType_CHROME_OS = 2,
  OsInfo_OsType_WINDOWS = 3,
  OsInfo_OsType_APPLE = 4,
  OsInfo_OsType_LINUX = 100,
};

bool OsInfo_OsType_IsValid(int value);
constexpr OsInfo_OsType OsInfo_OsType_OsType_MIN = static_cast<OsInfo_OsType>(0);
constexpr OsInfo_OsType OsInfo_OsType_OsType_MAX = static_cast<OsInfo_OsType>(100);
constexpr int OsInfo_OsType_OsType_ARRAYSIZE = 100 + 1;
const std::string& OsInfo_OsType_Name(OsInfo_OsType value);
template <typename T>
const std::string& OsInfo_OsType_Name(T value) {
  static_assert(std::is_same<T, OsInfo_OsType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OsType_Name().");
  return OsInfo_OsType_Name(static_cast<OsInfo_OsType>(value));
}
const std::string& OsInfo_OsType_Name(OsInfo_OsType value);
bool OsInfo_OsType_Parse(absl::string_view name, OsInfo_OsType* value);
enum PresenceDevice_DeviceType : int {
  PresenceDevice_DeviceType_UNKNOWN = 0,
  PresenceDevice_DeviceType_PHONE = 1,
  PresenceDevice_DeviceType_TABLET = 2,
  PresenceDevice_DeviceType_DISPLAY = 3,
  PresenceDevice_DeviceType_LAPTOP = 4,
  PresenceDevice_DeviceType_TV = 5,
  PresenceDevice_DeviceType_WATCH = 6,
};

bool PresenceDevice_DeviceType_IsValid(int value);
constexpr PresenceDevice_DeviceType PresenceDevice_DeviceType_DeviceType_MIN = static_cast<PresenceDevice_DeviceType>(0);
constexpr PresenceDevice_DeviceType PresenceDevice_DeviceType_DeviceType_MAX = static_cast<PresenceDevice_DeviceType>(6);
constexpr int PresenceDevice_DeviceType_DeviceType_ARRAYSIZE = 6 + 1;
const std::string& PresenceDevice_DeviceType_Name(PresenceDevice_DeviceType value);
template <typename T>
const std::string& PresenceDevice_DeviceType_Name(T value) {
  static_assert(std::is_same<T, PresenceDevice_DeviceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceType_Name().");
  return PresenceDevice_DeviceType_Name(static_cast<PresenceDevice_DeviceType>(value));
}
const std::string& PresenceDevice_DeviceType_Name(PresenceDevice_DeviceType value);
bool PresenceDevice_DeviceType_Parse(absl::string_view name, PresenceDevice_DeviceType* value);
enum EndpointType : int {
  UNKNOWN_ENDPOINT = 0,
  CONNECTIONS_ENDPOINT = 1,
  PRESENCE_ENDPOINT = 2,
};

bool EndpointType_IsValid(int value);
constexpr EndpointType EndpointType_MIN = static_cast<EndpointType>(0);
constexpr EndpointType EndpointType_MAX = static_cast<EndpointType>(2);
constexpr int EndpointType_ARRAYSIZE = 2 + 1;
const std::string& EndpointType_Name(EndpointType value);
template <typename T>
const std::string& EndpointType_Name(T value) {
  static_assert(std::is_same<T, EndpointType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EndpointType_Name().");
  return EndpointType_Name(static_cast<EndpointType>(value));
}
const std::string& EndpointType_Name(EndpointType value);
bool EndpointType_Parse(absl::string_view name, EndpointType* value);

// ===================================================================


// -------------------------------------------------------------------

class OfflineFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.OfflineFrame) */ {
 public:
  inline OfflineFrame() : OfflineFrame(nullptr) {}
  ~OfflineFrame() override;
  explicit PROTOBUF_CONSTEXPR OfflineFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfflineFrame(const OfflineFrame& from);
  OfflineFrame(OfflineFrame&& from) noexcept
    : OfflineFrame() {
    *this = ::std::move(from);
  }

  inline OfflineFrame& operator=(const OfflineFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineFrame& operator=(OfflineFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OfflineFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineFrame* internal_default_instance() {
    return reinterpret_cast<const OfflineFrame*>(
               &_OfflineFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OfflineFrame& a, OfflineFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(OfflineFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfflineFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OfflineFrame& from);
  void MergeFrom(const OfflineFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OfflineFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.OfflineFrame";
  }
  protected:
  explicit OfflineFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Version = OfflineFrame_Version;
  static constexpr Version UNKNOWN_VERSION = OfflineFrame_Version_UNKNOWN_VERSION;
  static constexpr Version V1 = OfflineFrame_Version_V1;
  static inline bool Version_IsValid(int value) {
    return OfflineFrame_Version_IsValid(value);
  }
  static constexpr Version Version_MIN = OfflineFrame_Version_Version_MIN;
  static constexpr Version Version_MAX = OfflineFrame_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE = OfflineFrame_Version_Version_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Version_Name(T value) {
    return OfflineFrame_Version_Name(value);
  }
  static inline bool Version_Parse(absl::string_view name, Version* value) {
    return OfflineFrame_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // optional .location.nearby.connections.V1Frame v1 = 2;
  bool has_v1() const;
  void clear_v1() ;
  const ::location::nearby::connections::V1Frame& v1() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::V1Frame* release_v1();
  ::location::nearby::connections::V1Frame* mutable_v1();
  void set_allocated_v1(::location::nearby::connections::V1Frame* v1);
  private:
  const ::location::nearby::connections::V1Frame& _internal_v1() const;
  ::location::nearby::connections::V1Frame* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::location::nearby::connections::V1Frame* v1);
  ::location::nearby::connections::V1Frame* unsafe_arena_release_v1();
  // optional .location.nearby.connections.OfflineFrame.Version version = 1;
  bool has_version() const;
  void clear_version() ;
  ::location::nearby::connections::OfflineFrame_Version version() const;
  void set_version(::location::nearby::connections::OfflineFrame_Version value);

  private:
  ::location::nearby::connections::OfflineFrame_Version _internal_version() const;
  void _internal_set_version(::location::nearby::connections::OfflineFrame_Version value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.OfflineFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::location::nearby::connections::V1Frame* v1_;
    int version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class V1Frame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.V1Frame) */ {
 public:
  inline V1Frame() : V1Frame(nullptr) {}
  ~V1Frame() override;
  explicit PROTOBUF_CONSTEXPR V1Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V1Frame(const V1Frame& from);
  V1Frame(V1Frame&& from) noexcept
    : V1Frame() {
    *this = ::std::move(from);
  }

  inline V1Frame& operator=(const V1Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline V1Frame& operator=(V1Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V1Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const V1Frame* internal_default_instance() {
    return reinterpret_cast<const V1Frame*>(
               &_V1Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(V1Frame& a, V1Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(V1Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V1Frame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V1Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V1Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V1Frame& from);
  void MergeFrom(const V1Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V1Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.V1Frame";
  }
  protected:
  explicit V1Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using FrameType = V1Frame_FrameType;
  static constexpr FrameType UNKNOWN_FRAME_TYPE = V1Frame_FrameType_UNKNOWN_FRAME_TYPE;
  static constexpr FrameType CONNECTION_REQUEST = V1Frame_FrameType_CONNECTION_REQUEST;
  static constexpr FrameType CONNECTION_RESPONSE = V1Frame_FrameType_CONNECTION_RESPONSE;
  static constexpr FrameType PAYLOAD_TRANSFER = V1Frame_FrameType_PAYLOAD_TRANSFER;
  static constexpr FrameType BANDWIDTH_UPGRADE_NEGOTIATION = V1Frame_FrameType_BANDWIDTH_UPGRADE_NEGOTIATION;
  static constexpr FrameType KEEP_ALIVE = V1Frame_FrameType_KEEP_ALIVE;
  static constexpr FrameType DISCONNECTION = V1Frame_FrameType_DISCONNECTION;
  static constexpr FrameType PAIRED_KEY_ENCRYPTION = V1Frame_FrameType_PAIRED_KEY_ENCRYPTION;
  static constexpr FrameType AUTHENTICATION_MESSAGE = V1Frame_FrameType_AUTHENTICATION_MESSAGE;
  static constexpr FrameType AUTHENTICATION_RESULT = V1Frame_FrameType_AUTHENTICATION_RESULT;
  static constexpr FrameType AUTO_RESUME = V1Frame_FrameType_AUTO_RESUME;
  static constexpr FrameType AUTO_RECONNECT = V1Frame_FrameType_AUTO_RECONNECT;
  static constexpr FrameType BANDWIDTH_UPGRADE_RETRY = V1Frame_FrameType_BANDWIDTH_UPGRADE_RETRY;
  static inline bool FrameType_IsValid(int value) {
    return V1Frame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN = V1Frame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX = V1Frame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE = V1Frame_FrameType_FrameType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& FrameType_Name(T value) {
    return V1Frame_FrameType_Name(value);
  }
  static inline bool FrameType_Parse(absl::string_view name, FrameType* value) {
    return V1Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionRequestFieldNumber = 2,
    kConnectionResponseFieldNumber = 3,
    kPayloadTransferFieldNumber = 4,
    kBandwidthUpgradeNegotiationFieldNumber = 5,
    kKeepAliveFieldNumber = 6,
    kDisconnectionFieldNumber = 7,
    kPairedKeyEncryptionFieldNumber = 8,
    kAuthenticationMessageFieldNumber = 9,
    kAuthenticationResultFieldNumber = 10,
    kAutoResumeFieldNumber = 11,
    kAutoReconnectFieldNumber = 12,
    kBandwidthUpgradeRetryFieldNumber = 13,
    kTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
  bool has_connection_request() const;
  void clear_connection_request() ;
  const ::location::nearby::connections::ConnectionRequestFrame& connection_request() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::ConnectionRequestFrame* release_connection_request();
  ::location::nearby::connections::ConnectionRequestFrame* mutable_connection_request();
  void set_allocated_connection_request(::location::nearby::connections::ConnectionRequestFrame* connection_request);
  private:
  const ::location::nearby::connections::ConnectionRequestFrame& _internal_connection_request() const;
  ::location::nearby::connections::ConnectionRequestFrame* _internal_mutable_connection_request();
  public:
  void unsafe_arena_set_allocated_connection_request(
      ::location::nearby::connections::ConnectionRequestFrame* connection_request);
  ::location::nearby::connections::ConnectionRequestFrame* unsafe_arena_release_connection_request();
  // optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
  bool has_connection_response() const;
  void clear_connection_response() ;
  const ::location::nearby::connections::ConnectionResponseFrame& connection_response() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::ConnectionResponseFrame* release_connection_response();
  ::location::nearby::connections::ConnectionResponseFrame* mutable_connection_response();
  void set_allocated_connection_response(::location::nearby::connections::ConnectionResponseFrame* connection_response);
  private:
  const ::location::nearby::connections::ConnectionResponseFrame& _internal_connection_response() const;
  ::location::nearby::connections::ConnectionResponseFrame* _internal_mutable_connection_response();
  public:
  void unsafe_arena_set_allocated_connection_response(
      ::location::nearby::connections::ConnectionResponseFrame* connection_response);
  ::location::nearby::connections::ConnectionResponseFrame* unsafe_arena_release_connection_response();
  // optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
  bool has_payload_transfer() const;
  void clear_payload_transfer() ;
  const ::location::nearby::connections::PayloadTransferFrame& payload_transfer() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame* release_payload_transfer();
  ::location::nearby::connections::PayloadTransferFrame* mutable_payload_transfer();
  void set_allocated_payload_transfer(::location::nearby::connections::PayloadTransferFrame* payload_transfer);
  private:
  const ::location::nearby::connections::PayloadTransferFrame& _internal_payload_transfer() const;
  ::location::nearby::connections::PayloadTransferFrame* _internal_mutable_payload_transfer();
  public:
  void unsafe_arena_set_allocated_payload_transfer(
      ::location::nearby::connections::PayloadTransferFrame* payload_transfer);
  ::location::nearby::connections::PayloadTransferFrame* unsafe_arena_release_payload_transfer();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
  bool has_bandwidth_upgrade_negotiation() const;
  void clear_bandwidth_upgrade_negotiation() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& bandwidth_upgrade_negotiation() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* release_bandwidth_upgrade_negotiation();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* mutable_bandwidth_upgrade_negotiation();
  void set_allocated_bandwidth_upgrade_negotiation(::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& _internal_bandwidth_upgrade_negotiation() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* _internal_mutable_bandwidth_upgrade_negotiation();
  public:
  void unsafe_arena_set_allocated_bandwidth_upgrade_negotiation(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* unsafe_arena_release_bandwidth_upgrade_negotiation();
  // optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
  bool has_keep_alive() const;
  void clear_keep_alive() ;
  const ::location::nearby::connections::KeepAliveFrame& keep_alive() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::KeepAliveFrame* release_keep_alive();
  ::location::nearby::connections::KeepAliveFrame* mutable_keep_alive();
  void set_allocated_keep_alive(::location::nearby::connections::KeepAliveFrame* keep_alive);
  private:
  const ::location::nearby::connections::KeepAliveFrame& _internal_keep_alive() const;
  ::location::nearby::connections::KeepAliveFrame* _internal_mutable_keep_alive();
  public:
  void unsafe_arena_set_allocated_keep_alive(
      ::location::nearby::connections::KeepAliveFrame* keep_alive);
  ::location::nearby::connections::KeepAliveFrame* unsafe_arena_release_keep_alive();
  // optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
  bool has_disconnection() const;
  void clear_disconnection() ;
  const ::location::nearby::connections::DisconnectionFrame& disconnection() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::DisconnectionFrame* release_disconnection();
  ::location::nearby::connections::DisconnectionFrame* mutable_disconnection();
  void set_allocated_disconnection(::location::nearby::connections::DisconnectionFrame* disconnection);
  private:
  const ::location::nearby::connections::DisconnectionFrame& _internal_disconnection() const;
  ::location::nearby::connections::DisconnectionFrame* _internal_mutable_disconnection();
  public:
  void unsafe_arena_set_allocated_disconnection(
      ::location::nearby::connections::DisconnectionFrame* disconnection);
  ::location::nearby::connections::DisconnectionFrame* unsafe_arena_release_disconnection();
  // optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
  bool has_paired_key_encryption() const;
  void clear_paired_key_encryption() ;
  const ::location::nearby::connections::PairedKeyEncryptionFrame& paired_key_encryption() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PairedKeyEncryptionFrame* release_paired_key_encryption();
  ::location::nearby::connections::PairedKeyEncryptionFrame* mutable_paired_key_encryption();
  void set_allocated_paired_key_encryption(::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption);
  private:
  const ::location::nearby::connections::PairedKeyEncryptionFrame& _internal_paired_key_encryption() const;
  ::location::nearby::connections::PairedKeyEncryptionFrame* _internal_mutable_paired_key_encryption();
  public:
  void unsafe_arena_set_allocated_paired_key_encryption(
      ::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption);
  ::location::nearby::connections::PairedKeyEncryptionFrame* unsafe_arena_release_paired_key_encryption();
  // optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
  bool has_authentication_message() const;
  void clear_authentication_message() ;
  const ::location::nearby::connections::AuthenticationMessageFrame& authentication_message() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AuthenticationMessageFrame* release_authentication_message();
  ::location::nearby::connections::AuthenticationMessageFrame* mutable_authentication_message();
  void set_allocated_authentication_message(::location::nearby::connections::AuthenticationMessageFrame* authentication_message);
  private:
  const ::location::nearby::connections::AuthenticationMessageFrame& _internal_authentication_message() const;
  ::location::nearby::connections::AuthenticationMessageFrame* _internal_mutable_authentication_message();
  public:
  void unsafe_arena_set_allocated_authentication_message(
      ::location::nearby::connections::AuthenticationMessageFrame* authentication_message);
  ::location::nearby::connections::AuthenticationMessageFrame* unsafe_arena_release_authentication_message();
  // optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
  bool has_authentication_result() const;
  void clear_authentication_result() ;
  const ::location::nearby::connections::AuthenticationResultFrame& authentication_result() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AuthenticationResultFrame* release_authentication_result();
  ::location::nearby::connections::AuthenticationResultFrame* mutable_authentication_result();
  void set_allocated_authentication_result(::location::nearby::connections::AuthenticationResultFrame* authentication_result);
  private:
  const ::location::nearby::connections::AuthenticationResultFrame& _internal_authentication_result() const;
  ::location::nearby::connections::AuthenticationResultFrame* _internal_mutable_authentication_result();
  public:
  void unsafe_arena_set_allocated_authentication_result(
      ::location::nearby::connections::AuthenticationResultFrame* authentication_result);
  ::location::nearby::connections::AuthenticationResultFrame* unsafe_arena_release_authentication_result();
  // optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
  bool has_auto_resume() const;
  void clear_auto_resume() ;
  const ::location::nearby::connections::AutoResumeFrame& auto_resume() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AutoResumeFrame* release_auto_resume();
  ::location::nearby::connections::AutoResumeFrame* mutable_auto_resume();
  void set_allocated_auto_resume(::location::nearby::connections::AutoResumeFrame* auto_resume);
  private:
  const ::location::nearby::connections::AutoResumeFrame& _internal_auto_resume() const;
  ::location::nearby::connections::AutoResumeFrame* _internal_mutable_auto_resume();
  public:
  void unsafe_arena_set_allocated_auto_resume(
      ::location::nearby::connections::AutoResumeFrame* auto_resume);
  ::location::nearby::connections::AutoResumeFrame* unsafe_arena_release_auto_resume();
  // optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
  bool has_auto_reconnect() const;
  void clear_auto_reconnect() ;
  const ::location::nearby::connections::AutoReconnectFrame& auto_reconnect() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AutoReconnectFrame* release_auto_reconnect();
  ::location::nearby::connections::AutoReconnectFrame* mutable_auto_reconnect();
  void set_allocated_auto_reconnect(::location::nearby::connections::AutoReconnectFrame* auto_reconnect);
  private:
  const ::location::nearby::connections::AutoReconnectFrame& _internal_auto_reconnect() const;
  ::location::nearby::connections::AutoReconnectFrame* _internal_mutable_auto_reconnect();
  public:
  void unsafe_arena_set_allocated_auto_reconnect(
      ::location::nearby::connections::AutoReconnectFrame* auto_reconnect);
  ::location::nearby::connections::AutoReconnectFrame* unsafe_arena_release_auto_reconnect();
  // optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
  bool has_bandwidth_upgrade_retry() const;
  void clear_bandwidth_upgrade_retry() ;
  const ::location::nearby::connections::BandwidthUpgradeRetryFrame& bandwidth_upgrade_retry() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeRetryFrame* release_bandwidth_upgrade_retry();
  ::location::nearby::connections::BandwidthUpgradeRetryFrame* mutable_bandwidth_upgrade_retry();
  void set_allocated_bandwidth_upgrade_retry(::location::nearby::connections::BandwidthUpgradeRetryFrame* bandwidth_upgrade_retry);
  private:
  const ::location::nearby::connections::BandwidthUpgradeRetryFrame& _internal_bandwidth_upgrade_retry() const;
  ::location::nearby::connections::BandwidthUpgradeRetryFrame* _internal_mutable_bandwidth_upgrade_retry();
  public:
  void unsafe_arena_set_allocated_bandwidth_upgrade_retry(
      ::location::nearby::connections::BandwidthUpgradeRetryFrame* bandwidth_upgrade_retry);
  ::location::nearby::connections::BandwidthUpgradeRetryFrame* unsafe_arena_release_bandwidth_upgrade_retry();
  // optional .location.nearby.connections.V1Frame.FrameType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::location::nearby::connections::V1Frame_FrameType type() const;
  void set_type(::location::nearby::connections::V1Frame_FrameType value);

  private:
  ::location::nearby::connections::V1Frame_FrameType _internal_type() const;
  void _internal_set_type(::location::nearby::connections::V1Frame_FrameType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.V1Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::location::nearby::connections::ConnectionRequestFrame* connection_request_;
    ::location::nearby::connections::ConnectionResponseFrame* connection_response_;
    ::location::nearby::connections::PayloadTransferFrame* payload_transfer_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation_;
    ::location::nearby::connections::KeepAliveFrame* keep_alive_;
    ::location::nearby::connections::DisconnectionFrame* disconnection_;
    ::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption_;
    ::location::nearby::connections::AuthenticationMessageFrame* authentication_message_;
    ::location::nearby::connections::AuthenticationResultFrame* authentication_result_;
    ::location::nearby::connections::AutoResumeFrame* auto_resume_;
    ::location::nearby::connections::AutoReconnectFrame* auto_reconnect_;
    ::location::nearby::connections::BandwidthUpgradeRetryFrame* bandwidth_upgrade_retry_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class ConnectionRequestFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.ConnectionRequestFrame) */ {
 public:
  inline ConnectionRequestFrame() : ConnectionRequestFrame(nullptr) {}
  ~ConnectionRequestFrame() override;
  explicit PROTOBUF_CONSTEXPR ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionRequestFrame(const ConnectionRequestFrame& from);
  ConnectionRequestFrame(ConnectionRequestFrame&& from) noexcept
    : ConnectionRequestFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionRequestFrame& operator=(const ConnectionRequestFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionRequestFrame& operator=(ConnectionRequestFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionRequestFrame& default_instance() {
    return *internal_default_instance();
  }
  enum DeviceCase {
    kConnectionsDevice = 12,
    kPresenceDevice = 13,
    DEVICE_NOT_SET = 0,
  };

  static inline const ConnectionRequestFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequestFrame*>(
               &_ConnectionRequestFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConnectionRequestFrame& a, ConnectionRequestFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionRequestFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionRequestFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionRequestFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionRequestFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionRequestFrame& from);
  void MergeFrom(const ConnectionRequestFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionRequestFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.ConnectionRequestFrame";
  }
  protected:
  explicit ConnectionRequestFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Medium = ConnectionRequestFrame_Medium;
  static constexpr Medium UNKNOWN_MEDIUM = ConnectionRequestFrame_Medium_UNKNOWN_MEDIUM;
  [[deprecated]] static constexpr Medium MDNS = ConnectionRequestFrame_Medium_MDNS;
  static constexpr Medium BLUETOOTH = ConnectionRequestFrame_Medium_BLUETOOTH;
  static constexpr Medium WIFI_HOTSPOT = ConnectionRequestFrame_Medium_WIFI_HOTSPOT;
  static constexpr Medium BLE = ConnectionRequestFrame_Medium_BLE;
  static constexpr Medium WIFI_LAN = ConnectionRequestFrame_Medium_WIFI_LAN;
  static constexpr Medium WIFI_AWARE = ConnectionRequestFrame_Medium_WIFI_AWARE;
  static constexpr Medium NFC = ConnectionRequestFrame_Medium_NFC;
  static constexpr Medium WIFI_DIRECT = ConnectionRequestFrame_Medium_WIFI_DIRECT;
  static constexpr Medium WEB_RTC = ConnectionRequestFrame_Medium_WEB_RTC;
  static constexpr Medium BLE_L2CAP = ConnectionRequestFrame_Medium_BLE_L2CAP;
  static constexpr Medium USB = ConnectionRequestFrame_Medium_USB;
  static inline bool Medium_IsValid(int value) {
    return ConnectionRequestFrame_Medium_IsValid(value);
  }
  static constexpr Medium Medium_MIN = ConnectionRequestFrame_Medium_Medium_MIN;
  static constexpr Medium Medium_MAX = ConnectionRequestFrame_Medium_Medium_MAX;
  static constexpr int Medium_ARRAYSIZE = ConnectionRequestFrame_Medium_Medium_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Medium_Name(T value) {
    return ConnectionRequestFrame_Medium_Name(value);
  }
  static inline bool Medium_Parse(absl::string_view name, Medium* value) {
    return ConnectionRequestFrame_Medium_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMediumsFieldNumber = 5,
    kEndpointIdFieldNumber = 1,
    kEndpointNameFieldNumber = 2,
    kHandshakeDataFieldNumber = 3,
    kEndpointInfoFieldNumber = 6,
    kDeviceInfoFieldNumber = 11,
    kMediumMetadataFieldNumber = 7,
    kNonceFieldNumber = 4,
    kKeepAliveIntervalMillisFieldNumber = 8,
    kKeepAliveTimeoutMillisFieldNumber = 9,
    kDeviceTypeFieldNumber = 10,
    kConnectionsDeviceFieldNumber = 12,
    kPresenceDeviceFieldNumber = 13,
  };
  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
  int mediums_size() const;
  private:
  int _internal_mediums_size() const;

  public:
  void clear_mediums() ;
  public:
  ::location::nearby::connections::ConnectionRequestFrame_Medium mediums(int index) const;
  void set_mediums(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value);
  void add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& mediums() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_mediums();

  private:
  ::location::nearby::connections::ConnectionRequestFrame_Medium _internal_mediums(int index) const;
  void _internal_add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_mediums() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_mediums();

  public:
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  void clear_endpoint_id() ;
  const std::string& endpoint_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* ptr);

  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(
      const std::string& value);
  std::string* _internal_mutable_endpoint_id();

  public:
  // optional string endpoint_name = 2;
  bool has_endpoint_name() const;
  void clear_endpoint_name() ;
  const std::string& endpoint_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_name(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_name();
  PROTOBUF_NODISCARD std::string* release_endpoint_name();
  void set_allocated_endpoint_name(std::string* ptr);

  private:
  const std::string& _internal_endpoint_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_name(
      const std::string& value);
  std::string* _internal_mutable_endpoint_name();

  public:
  // optional bytes handshake_data = 3;
  bool has_handshake_data() const;
  void clear_handshake_data() ;
  const std::string& handshake_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_handshake_data(Arg_&& arg, Args_... args);
  std::string* mutable_handshake_data();
  PROTOBUF_NODISCARD std::string* release_handshake_data();
  void set_allocated_handshake_data(std::string* ptr);

  private:
  const std::string& _internal_handshake_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handshake_data(
      const std::string& value);
  std::string* _internal_mutable_handshake_data();

  public:
  // optional bytes endpoint_info = 6;
  bool has_endpoint_info() const;
  void clear_endpoint_info() ;
  const std::string& endpoint_info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_info(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_info();
  PROTOBUF_NODISCARD std::string* release_endpoint_info();
  void set_allocated_endpoint_info(std::string* ptr);

  private:
  const std::string& _internal_endpoint_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_info(
      const std::string& value);
  std::string* _internal_mutable_endpoint_info();

  public:
  // optional bytes device_info = 11 [deprecated = true];
  [[deprecated]]  bool has_device_info() const;
  [[deprecated]]  void clear_device_info() ;
  [[deprecated]] const std::string& device_info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_device_info(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_device_info();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_device_info();
  [[deprecated]] void set_allocated_device_info(std::string* ptr);

  private:
  const std::string& _internal_device_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_info(
      const std::string& value);
  std::string* _internal_mutable_device_info();

  public:
  // optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
  bool has_medium_metadata() const;
  void clear_medium_metadata() ;
  const ::location::nearby::connections::MediumMetadata& medium_metadata() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::MediumMetadata* release_medium_metadata();
  ::location::nearby::connections::MediumMetadata* mutable_medium_metadata();
  void set_allocated_medium_metadata(::location::nearby::connections::MediumMetadata* medium_metadata);
  private:
  const ::location::nearby::connections::MediumMetadata& _internal_medium_metadata() const;
  ::location::nearby::connections::MediumMetadata* _internal_mutable_medium_metadata();
  public:
  void unsafe_arena_set_allocated_medium_metadata(
      ::location::nearby::connections::MediumMetadata* medium_metadata);
  ::location::nearby::connections::MediumMetadata* unsafe_arena_release_medium_metadata();
  // optional int32 nonce = 4;
  bool has_nonce() const;
  void clear_nonce() ;
  ::int32_t nonce() const;
  void set_nonce(::int32_t value);

  private:
  ::int32_t _internal_nonce() const;
  void _internal_set_nonce(::int32_t value);

  public:
  // optional int32 keep_alive_interval_millis = 8;
  bool has_keep_alive_interval_millis() const;
  void clear_keep_alive_interval_millis() ;
  ::int32_t keep_alive_interval_millis() const;
  void set_keep_alive_interval_millis(::int32_t value);

  private:
  ::int32_t _internal_keep_alive_interval_millis() const;
  void _internal_set_keep_alive_interval_millis(::int32_t value);

  public:
  // optional int32 keep_alive_timeout_millis = 9;
  bool has_keep_alive_timeout_millis() const;
  void clear_keep_alive_timeout_millis() ;
  ::int32_t keep_alive_timeout_millis() const;
  void set_keep_alive_timeout_millis(::int32_t value);

  private:
  ::int32_t _internal_keep_alive_timeout_millis() const;
  void _internal_set_keep_alive_timeout_millis(::int32_t value);

  public:
  // optional int32 device_type = 10 [default = 0, deprecated = true];
  [[deprecated]]  bool has_device_type() const;
  [[deprecated]]  void clear_device_type() ;
  [[deprecated]] ::int32_t device_type() const;
  [[deprecated]] void set_device_type(::int32_t value);

  private:
  ::int32_t _internal_device_type() const;
  void _internal_set_device_type(::int32_t value);

  public:
  // .location.nearby.connections.ConnectionsDevice connections_device = 12;
  bool has_connections_device() const;
  private:
  bool _internal_has_connections_device() const;

  public:
  void clear_connections_device() ;
  const ::location::nearby::connections::ConnectionsDevice& connections_device() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::ConnectionsDevice* release_connections_device();
  ::location::nearby::connections::ConnectionsDevice* mutable_connections_device();
  void set_allocated_connections_device(::location::nearby::connections::ConnectionsDevice* connections_device);
  private:
  const ::location::nearby::connections::ConnectionsDevice& _internal_connections_device() const;
  ::location::nearby::connections::ConnectionsDevice* _internal_mutable_connections_device();
  public:
  void unsafe_arena_set_allocated_connections_device(
      ::location::nearby::connections::ConnectionsDevice* connections_device);
  ::location::nearby::connections::ConnectionsDevice* unsafe_arena_release_connections_device();
  // .location.nearby.connections.PresenceDevice presence_device = 13;
  bool has_presence_device() const;
  private:
  bool _internal_has_presence_device() const;

  public:
  void clear_presence_device() ;
  const ::location::nearby::connections::PresenceDevice& presence_device() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PresenceDevice* release_presence_device();
  ::location::nearby::connections::PresenceDevice* mutable_presence_device();
  void set_allocated_presence_device(::location::nearby::connections::PresenceDevice* presence_device);
  private:
  const ::location::nearby::connections::PresenceDevice& _internal_presence_device() const;
  ::location::nearby::connections::PresenceDevice* _internal_mutable_presence_device();
  public:
  void unsafe_arena_set_allocated_presence_device(
      ::location::nearby::connections::PresenceDevice* presence_device);
  ::location::nearby::connections::PresenceDevice* unsafe_arena_release_presence_device();
  void clear_Device();
  DeviceCase Device_case() const;
  // @@protoc_insertion_point(class_scope:location.nearby.connections.ConnectionRequestFrame)
 private:
  class _Internal;
  void set_has_connections_device();
  void set_has_presence_device();

  inline bool has_Device() const;
  inline void clear_has_Device();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> mediums_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handshake_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_info_;
    ::location::nearby::connections::MediumMetadata* medium_metadata_;
    ::int32_t nonce_;
    ::int32_t keep_alive_interval_millis_;
    ::int32_t keep_alive_timeout_millis_;
    ::int32_t device_type_;
    union DeviceUnion {
      constexpr DeviceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::location::nearby::connections::ConnectionsDevice* connections_device_;
      ::location::nearby::connections::PresenceDevice* presence_device_;
    } Device_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class ConnectionResponseFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.ConnectionResponseFrame) */ {
 public:
  inline ConnectionResponseFrame() : ConnectionResponseFrame(nullptr) {}
  ~ConnectionResponseFrame() override;
  explicit PROTOBUF_CONSTEXPR ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionResponseFrame(const ConnectionResponseFrame& from);
  ConnectionResponseFrame(ConnectionResponseFrame&& from) noexcept
    : ConnectionResponseFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionResponseFrame& operator=(const ConnectionResponseFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionResponseFrame& operator=(ConnectionResponseFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionResponseFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionResponseFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponseFrame*>(
               &_ConnectionResponseFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectionResponseFrame& a, ConnectionResponseFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionResponseFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionResponseFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionResponseFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionResponseFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionResponseFrame& from);
  void MergeFrom(const ConnectionResponseFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionResponseFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.ConnectionResponseFrame";
  }
  protected:
  explicit ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using ResponseStatus = ConnectionResponseFrame_ResponseStatus;
  static constexpr ResponseStatus UNKNOWN_RESPONSE_STATUS = ConnectionResponseFrame_ResponseStatus_UNKNOWN_RESPONSE_STATUS;
  static constexpr ResponseStatus ACCEPT = ConnectionResponseFrame_ResponseStatus_ACCEPT;
  static constexpr ResponseStatus REJECT = ConnectionResponseFrame_ResponseStatus_REJECT;
  static inline bool ResponseStatus_IsValid(int value) {
    return ConnectionResponseFrame_ResponseStatus_IsValid(value);
  }
  static constexpr ResponseStatus ResponseStatus_MIN = ConnectionResponseFrame_ResponseStatus_ResponseStatus_MIN;
  static constexpr ResponseStatus ResponseStatus_MAX = ConnectionResponseFrame_ResponseStatus_ResponseStatus_MAX;
  static constexpr int ResponseStatus_ARRAYSIZE = ConnectionResponseFrame_ResponseStatus_ResponseStatus_ARRAYSIZE;
  template <typename T>
  static inline const std::string& ResponseStatus_Name(T value) {
    return ConnectionResponseFrame_ResponseStatus_Name(value);
  }
  static inline bool ResponseStatus_Parse(absl::string_view name, ResponseStatus* value) {
    return ConnectionResponseFrame_ResponseStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHandshakeDataFieldNumber = 2,
    kOsInfoFieldNumber = 4,
    kStatusFieldNumber = 1,
    kResponseFieldNumber = 3,
    kMultiplexSocketBitmaskFieldNumber = 5,
    kNearbyConnectionsVersionFieldNumber = 6,
    kSafeToDisconnectVersionFieldNumber = 7,
  };
  // optional bytes handshake_data = 2;
  bool has_handshake_data() const;
  void clear_handshake_data() ;
  const std::string& handshake_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_handshake_data(Arg_&& arg, Args_... args);
  std::string* mutable_handshake_data();
  PROTOBUF_NODISCARD std::string* release_handshake_data();
  void set_allocated_handshake_data(std::string* ptr);

  private:
  const std::string& _internal_handshake_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handshake_data(
      const std::string& value);
  std::string* _internal_mutable_handshake_data();

  public:
  // optional .location.nearby.connections.OsInfo os_info = 4;
  bool has_os_info() const;
  void clear_os_info() ;
  const ::location::nearby::connections::OsInfo& os_info() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::OsInfo* release_os_info();
  ::location::nearby::connections::OsInfo* mutable_os_info();
  void set_allocated_os_info(::location::nearby::connections::OsInfo* os_info);
  private:
  const ::location::nearby::connections::OsInfo& _internal_os_info() const;
  ::location::nearby::connections::OsInfo* _internal_mutable_os_info();
  public:
  void unsafe_arena_set_allocated_os_info(
      ::location::nearby::connections::OsInfo* os_info);
  ::location::nearby::connections::OsInfo* unsafe_arena_release_os_info();
  // optional int32 status = 1 [deprecated = true];
  [[deprecated]]  bool has_status() const;
  [[deprecated]]  void clear_status() ;
  [[deprecated]] ::int32_t status() const;
  [[deprecated]] void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
  bool has_response() const;
  void clear_response() ;
  ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus response() const;
  void set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value);

  private:
  ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus _internal_response() const;
  void _internal_set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value);

  public:
  // optional int32 multiplex_socket_bitmask = 5;
  bool has_multiplex_socket_bitmask() const;
  void clear_multiplex_socket_bitmask() ;
  ::int32_t multiplex_socket_bitmask() const;
  void set_multiplex_socket_bitmask(::int32_t value);

  private:
  ::int32_t _internal_multiplex_socket_bitmask() const;
  void _internal_set_multiplex_socket_bitmask(::int32_t value);

  public:
  // optional int32 nearby_connections_version = 6 [deprecated = true];
  [[deprecated]]  bool has_nearby_connections_version() const;
  [[deprecated]]  void clear_nearby_connections_version() ;
  [[deprecated]] ::int32_t nearby_connections_version() const;
  [[deprecated]] void set_nearby_connections_version(::int32_t value);

  private:
  ::int32_t _internal_nearby_connections_version() const;
  void _internal_set_nearby_connections_version(::int32_t value);

  public:
  // optional int32 safe_to_disconnect_version = 7;
  bool has_safe_to_disconnect_version() const;
  void clear_safe_to_disconnect_version() ;
  ::int32_t safe_to_disconnect_version() const;
  void set_safe_to_disconnect_version(::int32_t value);

  private:
  ::int32_t _internal_safe_to_disconnect_version() const;
  void _internal_set_safe_to_disconnect_version(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.ConnectionResponseFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handshake_data_;
    ::location::nearby::connections::OsInfo* os_info_;
    ::int32_t status_;
    int response_;
    ::int32_t multiplex_socket_bitmask_;
    ::int32_t nearby_connections_version_;
    ::int32_t safe_to_disconnect_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class PayloadTransferFrame_PayloadHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame.PayloadHeader) */ {
 public:
  inline PayloadTransferFrame_PayloadHeader() : PayloadTransferFrame_PayloadHeader(nullptr) {}
  ~PayloadTransferFrame_PayloadHeader() override;
  explicit PROTOBUF_CONSTEXPR PayloadTransferFrame_PayloadHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame_PayloadHeader(const PayloadTransferFrame_PayloadHeader& from);
  PayloadTransferFrame_PayloadHeader(PayloadTransferFrame_PayloadHeader&& from) noexcept
    : PayloadTransferFrame_PayloadHeader() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame_PayloadHeader& operator=(const PayloadTransferFrame_PayloadHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame_PayloadHeader& operator=(PayloadTransferFrame_PayloadHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame_PayloadHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame_PayloadHeader* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame_PayloadHeader*>(
               &_PayloadTransferFrame_PayloadHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PayloadTransferFrame_PayloadHeader& a, PayloadTransferFrame_PayloadHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame_PayloadHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame_PayloadHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame_PayloadHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame_PayloadHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame_PayloadHeader& from);
  void MergeFrom(const PayloadTransferFrame_PayloadHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame_PayloadHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame.PayloadHeader";
  }
  protected:
  explicit PayloadTransferFrame_PayloadHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using PayloadType = PayloadTransferFrame_PayloadHeader_PayloadType;
  static constexpr PayloadType UNKNOWN_PAYLOAD_TYPE = PayloadTransferFrame_PayloadHeader_PayloadType_UNKNOWN_PAYLOAD_TYPE;
  static constexpr PayloadType BYTES = PayloadTransferFrame_PayloadHeader_PayloadType_BYTES;
  static constexpr PayloadType FILE = PayloadTransferFrame_PayloadHeader_PayloadType_FILE;
  static constexpr PayloadType STREAM = PayloadTransferFrame_PayloadHeader_PayloadType_STREAM;
  static inline bool PayloadType_IsValid(int value) {
    return PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(value);
  }
  static constexpr PayloadType PayloadType_MIN = PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MIN;
  static constexpr PayloadType PayloadType_MAX = PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_MAX;
  static constexpr int PayloadType_ARRAYSIZE = PayloadTransferFrame_PayloadHeader_PayloadType_PayloadType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& PayloadType_Name(T value) {
    return PayloadTransferFrame_PayloadHeader_PayloadType_Name(value);
  }
  static inline bool PayloadType_Parse(absl::string_view name, PayloadType* value) {
    return PayloadTransferFrame_PayloadHeader_PayloadType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 5,
    kParentFolderFieldNumber = 6,
    kIdFieldNumber = 1,
    kTotalSizeFieldNumber = 3,
    kTypeFieldNumber = 2,
    kIsSensitiveFieldNumber = 4,
  };
  // optional string file_name = 5;
  bool has_file_name() const;
  void clear_file_name() ;
  const std::string& file_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* ptr);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // optional string parent_folder = 6;
  bool has_parent_folder() const;
  void clear_parent_folder() ;
  const std::string& parent_folder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_folder(Arg_&& arg, Args_... args);
  std::string* mutable_parent_folder();
  PROTOBUF_NODISCARD std::string* release_parent_folder();
  void set_allocated_parent_folder(std::string* ptr);

  private:
  const std::string& _internal_parent_folder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_folder(
      const std::string& value);
  std::string* _internal_mutable_parent_folder();

  public:
  // optional int64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional int64 total_size = 3;
  bool has_total_size() const;
  void clear_total_size() ;
  ::int64_t total_size() const;
  void set_total_size(::int64_t value);

  private:
  ::int64_t _internal_total_size() const;
  void _internal_set_total_size(::int64_t value);

  public:
  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType type() const;
  void set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value);

  private:
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType _internal_type() const;
  void _internal_set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value);

  public:
  // optional bool is_sensitive = 4;
  bool has_is_sensitive() const;
  void clear_is_sensitive() ;
  bool is_sensitive() const;
  void set_is_sensitive(bool value);

  private:
  bool _internal_is_sensitive() const;
  void _internal_set_is_sensitive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame.PayloadHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_folder_;
    ::int64_t id_;
    ::int64_t total_size_;
    int type_;
    bool is_sensitive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class PayloadTransferFrame_PayloadChunk final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame.PayloadChunk) */ {
 public:
  inline PayloadTransferFrame_PayloadChunk() : PayloadTransferFrame_PayloadChunk(nullptr) {}
  ~PayloadTransferFrame_PayloadChunk() override;
  explicit PROTOBUF_CONSTEXPR PayloadTransferFrame_PayloadChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame_PayloadChunk(const PayloadTransferFrame_PayloadChunk& from);
  PayloadTransferFrame_PayloadChunk(PayloadTransferFrame_PayloadChunk&& from) noexcept
    : PayloadTransferFrame_PayloadChunk() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame_PayloadChunk& operator=(const PayloadTransferFrame_PayloadChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame_PayloadChunk& operator=(PayloadTransferFrame_PayloadChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame_PayloadChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame_PayloadChunk* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame_PayloadChunk*>(
               &_PayloadTransferFrame_PayloadChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PayloadTransferFrame_PayloadChunk& a, PayloadTransferFrame_PayloadChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame_PayloadChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame_PayloadChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame_PayloadChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame_PayloadChunk>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame_PayloadChunk& from);
  void MergeFrom(const PayloadTransferFrame_PayloadChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame_PayloadChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame.PayloadChunk";
  }
  protected:
  explicit PayloadTransferFrame_PayloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Flags = PayloadTransferFrame_PayloadChunk_Flags;
  static constexpr Flags LAST_CHUNK = PayloadTransferFrame_PayloadChunk_Flags_LAST_CHUNK;
  static inline bool Flags_IsValid(int value) {
    return PayloadTransferFrame_PayloadChunk_Flags_IsValid(value);
  }
  static constexpr Flags Flags_MIN = PayloadTransferFrame_PayloadChunk_Flags_Flags_MIN;
  static constexpr Flags Flags_MAX = PayloadTransferFrame_PayloadChunk_Flags_Flags_MAX;
  static constexpr int Flags_ARRAYSIZE = PayloadTransferFrame_PayloadChunk_Flags_Flags_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Flags_Name(T value) {
    return PayloadTransferFrame_PayloadChunk_Flags_Name(value);
  }
  static inline bool Flags_Parse(absl::string_view name, Flags* value) {
    return PayloadTransferFrame_PayloadChunk_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBodyFieldNumber = 3,
    kOffsetFieldNumber = 2,
    kFlagsFieldNumber = 1,
    kIndexFieldNumber = 4,
  };
  // optional bytes body = 3;
  bool has_body() const;
  void clear_body() ;
  const std::string& body() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* ptr);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // optional int64 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // optional int32 flags = 1;
  bool has_flags() const;
  void clear_flags() ;
  ::int32_t flags() const;
  void set_flags(::int32_t value);

  private:
  ::int32_t _internal_flags() const;
  void _internal_set_flags(::int32_t value);

  public:
  // optional int32 index = 4;
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame.PayloadChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::int64_t offset_;
    ::int32_t flags_;
    ::int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class PayloadTransferFrame_ControlMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame.ControlMessage) */ {
 public:
  inline PayloadTransferFrame_ControlMessage() : PayloadTransferFrame_ControlMessage(nullptr) {}
  ~PayloadTransferFrame_ControlMessage() override;
  explicit PROTOBUF_CONSTEXPR PayloadTransferFrame_ControlMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame_ControlMessage(const PayloadTransferFrame_ControlMessage& from);
  PayloadTransferFrame_ControlMessage(PayloadTransferFrame_ControlMessage&& from) noexcept
    : PayloadTransferFrame_ControlMessage() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame_ControlMessage& operator=(const PayloadTransferFrame_ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame_ControlMessage& operator=(PayloadTransferFrame_ControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame_ControlMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame_ControlMessage* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame_ControlMessage*>(
               &_PayloadTransferFrame_ControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PayloadTransferFrame_ControlMessage& a, PayloadTransferFrame_ControlMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame_ControlMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame_ControlMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame_ControlMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame_ControlMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame_ControlMessage& from);
  void MergeFrom(const PayloadTransferFrame_ControlMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame_ControlMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame.ControlMessage";
  }
  protected:
  explicit PayloadTransferFrame_ControlMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using EventType = PayloadTransferFrame_ControlMessage_EventType;
  static constexpr EventType UNKNOWN_EVENT_TYPE = PayloadTransferFrame_ControlMessage_EventType_UNKNOWN_EVENT_TYPE;
  static constexpr EventType PAYLOAD_ERROR = PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_ERROR;
  static constexpr EventType PAYLOAD_CANCELED = PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_CANCELED;
  static constexpr EventType PAYLOAD_RECEIVED_ACK = PayloadTransferFrame_ControlMessage_EventType_PAYLOAD_RECEIVED_ACK;
  static inline bool EventType_IsValid(int value) {
    return PayloadTransferFrame_ControlMessage_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN = PayloadTransferFrame_ControlMessage_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX = PayloadTransferFrame_ControlMessage_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE = PayloadTransferFrame_ControlMessage_EventType_EventType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& EventType_Name(T value) {
    return PayloadTransferFrame_ControlMessage_EventType_Name(value);
  }
  static inline bool EventType_Parse(absl::string_view name, EventType* value) {
    return PayloadTransferFrame_ControlMessage_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 2,
    kEventFieldNumber = 1,
  };
  // optional int64 offset = 2;
  bool has_offset() const;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
  bool has_event() const;
  void clear_event() ;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType event() const;
  void set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value);

  private:
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType _internal_event() const;
  void _internal_set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame.ControlMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t offset_;
    int event_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class PayloadTransferFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PayloadTransferFrame) */ {
 public:
  inline PayloadTransferFrame() : PayloadTransferFrame(nullptr) {}
  ~PayloadTransferFrame() override;
  explicit PROTOBUF_CONSTEXPR PayloadTransferFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadTransferFrame(const PayloadTransferFrame& from);
  PayloadTransferFrame(PayloadTransferFrame&& from) noexcept
    : PayloadTransferFrame() {
    *this = ::std::move(from);
  }

  inline PayloadTransferFrame& operator=(const PayloadTransferFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadTransferFrame& operator=(PayloadTransferFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadTransferFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadTransferFrame* internal_default_instance() {
    return reinterpret_cast<const PayloadTransferFrame*>(
               &_PayloadTransferFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PayloadTransferFrame& a, PayloadTransferFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadTransferFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadTransferFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadTransferFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadTransferFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadTransferFrame& from);
  void MergeFrom(const PayloadTransferFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadTransferFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.PayloadTransferFrame";
  }
  protected:
  explicit PayloadTransferFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PayloadTransferFrame_PayloadHeader PayloadHeader;
  typedef PayloadTransferFrame_PayloadChunk PayloadChunk;
  typedef PayloadTransferFrame_ControlMessage ControlMessage;

  using PacketType = PayloadTransferFrame_PacketType;
  static constexpr PacketType UNKNOWN_PACKET_TYPE = PayloadTransferFrame_PacketType_UNKNOWN_PACKET_TYPE;
  static constexpr PacketType DATA = PayloadTransferFrame_PacketType_DATA;
  static constexpr PacketType CONTROL = PayloadTransferFrame_PacketType_CONTROL;
  static inline bool PacketType_IsValid(int value) {
    return PayloadTransferFrame_PacketType_IsValid(value);
  }
  static constexpr PacketType PacketType_MIN = PayloadTransferFrame_PacketType_PacketType_MIN;
  static constexpr PacketType PacketType_MAX = PayloadTransferFrame_PacketType_PacketType_MAX;
  static constexpr int PacketType_ARRAYSIZE = PayloadTransferFrame_PacketType_PacketType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& PacketType_Name(T value) {
    return PayloadTransferFrame_PacketType_Name(value);
  }
  static inline bool PacketType_Parse(absl::string_view name, PacketType* value) {
    return PayloadTransferFrame_PacketType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadHeaderFieldNumber = 2,
    kPayloadChunkFieldNumber = 3,
    kControlMessageFieldNumber = 4,
    kPacketTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
  bool has_payload_header() const;
  void clear_payload_header() ;
  const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& payload_header() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* release_payload_header();
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* mutable_payload_header();
  void set_allocated_payload_header(::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header);
  private:
  const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& _internal_payload_header() const;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* _internal_mutable_payload_header();
  public:
  void unsafe_arena_set_allocated_payload_header(
      ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header);
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* unsafe_arena_release_payload_header();
  // optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
  bool has_payload_chunk() const;
  void clear_payload_chunk() ;
  const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& payload_chunk() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* release_payload_chunk();
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* mutable_payload_chunk();
  void set_allocated_payload_chunk(::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk);
  private:
  const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& _internal_payload_chunk() const;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* _internal_mutable_payload_chunk();
  public:
  void unsafe_arena_set_allocated_payload_chunk(
      ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk);
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* unsafe_arena_release_payload_chunk();
  // optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
  bool has_control_message() const;
  void clear_control_message() ;
  const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& control_message() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::PayloadTransferFrame_ControlMessage* release_control_message();
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* mutable_control_message();
  void set_allocated_control_message(::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message);
  private:
  const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& _internal_control_message() const;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* _internal_mutable_control_message();
  public:
  void unsafe_arena_set_allocated_control_message(
      ::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message);
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* unsafe_arena_release_control_message();
  // optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
  bool has_packet_type() const;
  void clear_packet_type() ;
  ::location::nearby::connections::PayloadTransferFrame_PacketType packet_type() const;
  void set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value);

  private:
  ::location::nearby::connections::PayloadTransferFrame_PacketType _internal_packet_type() const;
  void _internal_set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.PayloadTransferFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header_;
    ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk_;
    ::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message_;
    int packet_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kGatewayFieldNumber = 4,
    kPortFieldNumber = 3,
    kFrequencyFieldNumber = 5,
  };
  // optional string ssid = 1;
  bool has_ssid() const;
  void clear_ssid() ;
  const std::string& ssid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ssid(Arg_&& arg, Args_... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ptr);

  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(
      const std::string& value);
  std::string* _internal_mutable_ssid();

  public:
  // optional string password = 2;
  bool has_password() const;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // optional string gateway = 4 [default = "0.0.0.0"];
  bool has_gateway() const;
  void clear_gateway() ;
  const std::string& gateway() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* ptr);

  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(
      const std::string& value);
  std::string* _internal_mutable_gateway();

  public:
  // optional int32 port = 3;
  bool has_port() const;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // optional int32 frequency = 5 [default = -1];
  bool has_frequency() const;
  void clear_frequency() ;
  ::int32_t frequency() const;
  void set_frequency(::int32_t value);

  private:
  ::int32_t _internal_frequency() const;
  void _internal_set_frequency(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    ::int32_t port_;
    ::int32_t frequency_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kWifiPortFieldNumber = 2,
  };
  // optional bytes ip_address = 1;
  bool has_ip_address() const;
  void clear_ip_address() ;
  const std::string& ip_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ptr);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // optional int32 wifi_port = 2;
  bool has_wifi_port() const;
  void clear_wifi_port() ;
  ::int32_t wifi_port() const;
  void set_wifi_port(::int32_t value);

  private:
  ::int32_t _internal_wifi_port() const;
  void _internal_set_wifi_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::int32_t wifi_port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kMacAddressFieldNumber = 2,
  };
  // optional string service_name = 1;
  bool has_service_name() const;
  void clear_service_name() ;
  const std::string& service_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_name(Arg_&& arg, Args_... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* ptr);

  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(
      const std::string& value);
  std::string* _internal_mutable_service_name();

  public:
  // optional string mac_address = 2;
  bool has_mac_address() const;
  void clear_mac_address() ;
  const std::string& mac_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mac_address(Arg_&& arg, Args_... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* ptr);

  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(
      const std::string& value);
  std::string* _internal_mutable_mac_address();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdFieldNumber = 1,
    kServiceInfoFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // optional string service_id = 1;
  bool has_service_id() const;
  void clear_service_id() ;
  const std::string& service_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_id(Arg_&& arg, Args_... args);
  std::string* mutable_service_id();
  PROTOBUF_NODISCARD std::string* release_service_id();
  void set_allocated_service_id(std::string* ptr);

  private:
  const std::string& _internal_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id(
      const std::string& value);
  std::string* _internal_mutable_service_id();

  public:
  // optional bytes service_info = 2;
  bool has_service_info() const;
  void clear_service_info() ;
  const std::string& service_info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_info(Arg_&& arg, Args_... args);
  std::string* mutable_service_info();
  PROTOBUF_NODISCARD std::string* release_service_info();
  void set_allocated_service_info(std::string* ptr);

  private:
  const std::string& _internal_service_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_info(
      const std::string& value);
  std::string* _internal_mutable_service_info();

  public:
  // optional string password = 3;
  bool has_password() const;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kGatewayFieldNumber = 5,
    kIpV6AddressFieldNumber = 6,
    kPortFieldNumber = 3,
    kFrequencyFieldNumber = 4,
  };
  // optional string ssid = 1;
  bool has_ssid() const;
  void clear_ssid() ;
  const std::string& ssid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ssid(Arg_&& arg, Args_... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ptr);

  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(
      const std::string& value);
  std::string* _internal_mutable_ssid();

  public:
  // optional string password = 2;
  bool has_password() const;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // optional string gateway = 5 [default = "0.0.0.0"];
  bool has_gateway() const;
  void clear_gateway() ;
  const std::string& gateway() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* ptr);

  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(
      const std::string& value);
  std::string* _internal_mutable_gateway();

  public:
  // optional bytes ip_v6_address = 6;
  bool has_ip_v6_address() const;
  void clear_ip_v6_address() ;
  const std::string& ip_v6_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_v6_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_v6_address();
  PROTOBUF_NODISCARD std::string* release_ip_v6_address();
  void set_allocated_ip_v6_address(std::string* ptr);

  private:
  const std::string& _internal_ip_v6_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_v6_address(
      const std::string& value);
  std::string* _internal_mutable_ip_v6_address();

  public:
  // optional int32 port = 3;
  bool has_port() const;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // optional int32 frequency = 4;
  bool has_frequency() const;
  void clear_frequency() ;
  ::int32_t frequency() const;
  void set_frequency(::int32_t value);

  private:
  ::int32_t _internal_frequency() const;
  void _internal_set_frequency(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_v6_address_;
    ::int32_t port_;
    ::int32_t frequency_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kLocationHintFieldNumber = 2,
  };
  // optional string peer_id = 1;
  bool has_peer_id() const;
  void clear_peer_id() ;
  const std::string& peer_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_peer_id(Arg_&& arg, Args_... args);
  std::string* mutable_peer_id();
  PROTOBUF_NODISCARD std::string* release_peer_id();
  void set_allocated_peer_id(std::string* ptr);

  private:
  const std::string& _internal_peer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_id(
      const std::string& value);
  std::string* _internal_mutable_peer_id();

  public:
  // optional .location.nearby.connections.LocationHint location_hint = 2;
  bool has_location_hint() const;
  void clear_location_hint() ;
  const ::location::nearby::connections::LocationHint& location_hint() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::LocationHint* release_location_hint();
  ::location::nearby::connections::LocationHint* mutable_location_hint();
  void set_allocated_location_hint(::location::nearby::connections::LocationHint* location_hint);
  private:
  const ::location::nearby::connections::LocationHint& _internal_location_hint() const;
  ::location::nearby::connections::LocationHint* _internal_mutable_location_hint();
  public:
  void unsafe_arena_set_allocated_location_hint(
      ::location::nearby::connections::LocationHint* location_hint);
  ::location::nearby::connections::LocationHint* unsafe_arena_release_location_hint();
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_id_;
    ::location::nearby::connections::LocationHint* location_hint_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_UpgradePathInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo() : BandwidthUpgradeNegotiationFrame_UpgradePathInfo(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_UpgradePathInfo() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from);
  BandwidthUpgradeNegotiationFrame_UpgradePathInfo(BandwidthUpgradeNegotiationFrame_UpgradePathInfo&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_UpgradePathInfo() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo& operator=(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_UpgradePathInfo& operator=(BandwidthUpgradeNegotiationFrame_UpgradePathInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_UpgradePathInfo* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_UpgradePathInfo*>(
               &_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo& a, BandwidthUpgradeNegotiationFrame_UpgradePathInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_UpgradePathInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_UpgradePathInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_UpgradePathInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_UpgradePathInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials WifiHotspotCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket WifiLanSocket;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials BluetoothCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials WifiAwareCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials WifiDirectCredentials;
  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials WebRtcCredentials;

  using Medium = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium;
  static constexpr Medium UNKNOWN_MEDIUM = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_UNKNOWN_MEDIUM;
  [[deprecated]] static constexpr Medium MDNS = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_MDNS;
  static constexpr Medium BLUETOOTH = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLUETOOTH;
  static constexpr Medium WIFI_HOTSPOT = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_HOTSPOT;
  static constexpr Medium BLE = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_BLE;
  static constexpr Medium WIFI_LAN = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_LAN;
  static constexpr Medium WIFI_AWARE = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_AWARE;
  static constexpr Medium NFC = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_NFC;
  static constexpr Medium WIFI_DIRECT = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WIFI_DIRECT;
  static constexpr Medium WEB_RTC = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_WEB_RTC;
  static constexpr Medium USB = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_USB;
  static inline bool Medium_IsValid(int value) {
    return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(value);
  }
  static constexpr Medium Medium_MIN = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MIN;
  static constexpr Medium Medium_MAX = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_MAX;
  static constexpr int Medium_ARRAYSIZE = BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Medium_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Medium_Name(T value) {
    return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Name(value);
  }
  static inline bool Medium_Parse(absl::string_view name, Medium* value) {
    return BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWifiHotspotCredentialsFieldNumber = 2,
    kWifiLanSocketFieldNumber = 3,
    kBluetoothCredentialsFieldNumber = 4,
    kWifiAwareCredentialsFieldNumber = 5,
    kWifiDirectCredentialsFieldNumber = 6,
    kWebRtcCredentialsFieldNumber = 8,
    kMediumFieldNumber = 1,
    kSupportsDisablingEncryptionFieldNumber = 7,
    kSupportsClientIntroductionAckFieldNumber = 9,
  };
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
  bool has_wifi_hotspot_credentials() const;
  void clear_wifi_hotspot_credentials() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& wifi_hotspot_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* release_wifi_hotspot_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* mutable_wifi_hotspot_credentials();
  void set_allocated_wifi_hotspot_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& _internal_wifi_hotspot_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* _internal_mutable_wifi_hotspot_credentials();
  public:
  void unsafe_arena_set_allocated_wifi_hotspot_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* unsafe_arena_release_wifi_hotspot_credentials();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
  bool has_wifi_lan_socket() const;
  void clear_wifi_lan_socket() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& wifi_lan_socket() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* release_wifi_lan_socket();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* mutable_wifi_lan_socket();
  void set_allocated_wifi_lan_socket(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& _internal_wifi_lan_socket() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* _internal_mutable_wifi_lan_socket();
  public:
  void unsafe_arena_set_allocated_wifi_lan_socket(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* unsafe_arena_release_wifi_lan_socket();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
  bool has_bluetooth_credentials() const;
  void clear_bluetooth_credentials() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& bluetooth_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* release_bluetooth_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* mutable_bluetooth_credentials();
  void set_allocated_bluetooth_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& _internal_bluetooth_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* _internal_mutable_bluetooth_credentials();
  public:
  void unsafe_arena_set_allocated_bluetooth_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* unsafe_arena_release_bluetooth_credentials();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
  bool has_wifi_aware_credentials() const;
  void clear_wifi_aware_credentials() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& wifi_aware_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* release_wifi_aware_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* mutable_wifi_aware_credentials();
  void set_allocated_wifi_aware_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& _internal_wifi_aware_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* _internal_mutable_wifi_aware_credentials();
  public:
  void unsafe_arena_set_allocated_wifi_aware_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* unsafe_arena_release_wifi_aware_credentials();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
  bool has_wifi_direct_credentials() const;
  void clear_wifi_direct_credentials() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& wifi_direct_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* release_wifi_direct_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* mutable_wifi_direct_credentials();
  void set_allocated_wifi_direct_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& _internal_wifi_direct_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* _internal_mutable_wifi_direct_credentials();
  public:
  void unsafe_arena_set_allocated_wifi_direct_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* unsafe_arena_release_wifi_direct_credentials();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
  bool has_web_rtc_credentials() const;
  void clear_web_rtc_credentials() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& web_rtc_credentials() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* release_web_rtc_credentials();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* mutable_web_rtc_credentials();
  void set_allocated_web_rtc_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& _internal_web_rtc_credentials() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* _internal_mutable_web_rtc_credentials();
  public:
  void unsafe_arena_set_allocated_web_rtc_credentials(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* unsafe_arena_release_web_rtc_credentials();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
  bool has_medium() const;
  void clear_medium() ;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium medium() const;
  void set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);

  private:
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium _internal_medium() const;
  void _internal_set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value);

  public:
  // optional bool supports_disabling_encryption = 7;
  bool has_supports_disabling_encryption() const;
  void clear_supports_disabling_encryption() ;
  bool supports_disabling_encryption() const;
  void set_supports_disabling_encryption(bool value);

  private:
  bool _internal_supports_disabling_encryption() const;
  void _internal_set_supports_disabling_encryption(bool value);

  public:
  // optional bool supports_client_introduction_ack = 9;
  bool has_supports_client_introduction_ack() const;
  void clear_supports_client_introduction_ack() ;
  bool supports_client_introduction_ack() const;
  void set_supports_client_introduction_ack(bool value);

  private:
  bool _internal_supports_client_introduction_ack() const;
  void _internal_set_supports_client_introduction_ack(bool value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials_;
    int medium_;
    bool supports_disabling_encryption_;
    bool supports_client_introduction_ack_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_ClientIntroduction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_ClientIntroduction() : BandwidthUpgradeNegotiationFrame_ClientIntroduction(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroduction() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_ClientIntroduction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_ClientIntroduction(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from);
  BandwidthUpgradeNegotiationFrame_ClientIntroduction(BandwidthUpgradeNegotiationFrame_ClientIntroduction&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_ClientIntroduction() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_ClientIntroduction& operator=(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_ClientIntroduction& operator=(BandwidthUpgradeNegotiationFrame_ClientIntroduction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_ClientIntroduction& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_ClientIntroduction* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroduction*>(
               &_BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BandwidthUpgradeNegotiationFrame_ClientIntroduction& a, BandwidthUpgradeNegotiationFrame_ClientIntroduction& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_ClientIntroduction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_ClientIntroduction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroduction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroduction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_ClientIntroduction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointIdFieldNumber = 1,
    kSupportsDisablingEncryptionFieldNumber = 2,
  };
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  void clear_endpoint_id() ;
  const std::string& endpoint_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* ptr);

  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(
      const std::string& value);
  std::string* _internal_mutable_endpoint_id();

  public:
  // optional bool supports_disabling_encryption = 2;
  bool has_supports_disabling_encryption() const;
  void clear_supports_disabling_encryption() ;
  bool supports_disabling_encryption() const;
  void set_supports_disabling_encryption(bool value);

  private:
  bool _internal_supports_disabling_encryption() const;
  void _internal_set_supports_disabling_encryption(bool value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
    bool supports_disabling_encryption_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame_ClientIntroductionAck final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() : BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from);
  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&& from) noexcept
    : BandwidthUpgradeNegotiationFrame_ClientIntroductionAck() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& operator=(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& operator=(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck*>(
               &_BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& a, BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame_ClientIntroductionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeNegotiationFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeNegotiationFrame) */ {
 public:
  inline BandwidthUpgradeNegotiationFrame() : BandwidthUpgradeNegotiationFrame(nullptr) {}
  ~BandwidthUpgradeNegotiationFrame() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeNegotiationFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeNegotiationFrame(const BandwidthUpgradeNegotiationFrame& from);
  BandwidthUpgradeNegotiationFrame(BandwidthUpgradeNegotiationFrame&& from) noexcept
    : BandwidthUpgradeNegotiationFrame() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeNegotiationFrame& operator=(const BandwidthUpgradeNegotiationFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeNegotiationFrame& operator=(BandwidthUpgradeNegotiationFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeNegotiationFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeNegotiationFrame* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeNegotiationFrame*>(
               &_BandwidthUpgradeNegotiationFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BandwidthUpgradeNegotiationFrame& a, BandwidthUpgradeNegotiationFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeNegotiationFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeNegotiationFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeNegotiationFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeNegotiationFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeNegotiationFrame& from);
  void MergeFrom(const BandwidthUpgradeNegotiationFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeNegotiationFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeNegotiationFrame";
  }
  protected:
  explicit BandwidthUpgradeNegotiationFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BandwidthUpgradeNegotiationFrame_UpgradePathInfo UpgradePathInfo;
  typedef BandwidthUpgradeNegotiationFrame_ClientIntroduction ClientIntroduction;
  typedef BandwidthUpgradeNegotiationFrame_ClientIntroductionAck ClientIntroductionAck;

  using EventType = BandwidthUpgradeNegotiationFrame_EventType;
  static constexpr EventType UNKNOWN_EVENT_TYPE = BandwidthUpgradeNegotiationFrame_EventType_UNKNOWN_EVENT_TYPE;
  static constexpr EventType UPGRADE_PATH_AVAILABLE = BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_PATH_AVAILABLE;
  static constexpr EventType LAST_WRITE_TO_PRIOR_CHANNEL = BandwidthUpgradeNegotiationFrame_EventType_LAST_WRITE_TO_PRIOR_CHANNEL;
  static constexpr EventType SAFE_TO_CLOSE_PRIOR_CHANNEL = BandwidthUpgradeNegotiationFrame_EventType_SAFE_TO_CLOSE_PRIOR_CHANNEL;
  static constexpr EventType CLIENT_INTRODUCTION = BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION;
  static constexpr EventType UPGRADE_FAILURE = BandwidthUpgradeNegotiationFrame_EventType_UPGRADE_FAILURE;
  static constexpr EventType CLIENT_INTRODUCTION_ACK = BandwidthUpgradeNegotiationFrame_EventType_CLIENT_INTRODUCTION_ACK;
  static inline bool EventType_IsValid(int value) {
    return BandwidthUpgradeNegotiationFrame_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN = BandwidthUpgradeNegotiationFrame_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX = BandwidthUpgradeNegotiationFrame_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE = BandwidthUpgradeNegotiationFrame_EventType_EventType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& EventType_Name(T value) {
    return BandwidthUpgradeNegotiationFrame_EventType_Name(value);
  }
  static inline bool EventType_Parse(absl::string_view name, EventType* value) {
    return BandwidthUpgradeNegotiationFrame_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUpgradePathInfoFieldNumber = 2,
    kClientIntroductionFieldNumber = 3,
    kClientIntroductionAckFieldNumber = 4,
    kEventTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
  bool has_upgrade_path_info() const;
  void clear_upgrade_path_info() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& upgrade_path_info() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* release_upgrade_path_info();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* mutable_upgrade_path_info();
  void set_allocated_upgrade_path_info(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& _internal_upgrade_path_info() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* _internal_mutable_upgrade_path_info();
  public:
  void unsafe_arena_set_allocated_upgrade_path_info(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* unsafe_arena_release_upgrade_path_info();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
  bool has_client_introduction() const;
  void clear_client_introduction() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& client_introduction() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* release_client_introduction();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* mutable_client_introduction();
  void set_allocated_client_introduction(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& _internal_client_introduction() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* _internal_mutable_client_introduction();
  public:
  void unsafe_arena_set_allocated_client_introduction(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* unsafe_arena_release_client_introduction();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
  bool has_client_introduction_ack() const;
  void clear_client_introduction_ack() ;
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& client_introduction_ack() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* release_client_introduction_ack();
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* mutable_client_introduction_ack();
  void set_allocated_client_introduction_ack(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack);
  private:
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& _internal_client_introduction_ack() const;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* _internal_mutable_client_introduction_ack();
  public:
  void unsafe_arena_set_allocated_client_introduction_ack(
      ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack);
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* unsafe_arena_release_client_introduction_ack();
  // optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
  bool has_event_type() const;
  void clear_event_type() ;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType event_type() const;
  void set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value);

  private:
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType _internal_event_type() const;
  void _internal_set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeNegotiationFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction_;
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack_;
    int event_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class BandwidthUpgradeRetryFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.BandwidthUpgradeRetryFrame) */ {
 public:
  inline BandwidthUpgradeRetryFrame() : BandwidthUpgradeRetryFrame(nullptr) {}
  ~BandwidthUpgradeRetryFrame() override;
  explicit PROTOBUF_CONSTEXPR BandwidthUpgradeRetryFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BandwidthUpgradeRetryFrame(const BandwidthUpgradeRetryFrame& from);
  BandwidthUpgradeRetryFrame(BandwidthUpgradeRetryFrame&& from) noexcept
    : BandwidthUpgradeRetryFrame() {
    *this = ::std::move(from);
  }

  inline BandwidthUpgradeRetryFrame& operator=(const BandwidthUpgradeRetryFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline BandwidthUpgradeRetryFrame& operator=(BandwidthUpgradeRetryFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BandwidthUpgradeRetryFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const BandwidthUpgradeRetryFrame* internal_default_instance() {
    return reinterpret_cast<const BandwidthUpgradeRetryFrame*>(
               &_BandwidthUpgradeRetryFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BandwidthUpgradeRetryFrame& a, BandwidthUpgradeRetryFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(BandwidthUpgradeRetryFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BandwidthUpgradeRetryFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BandwidthUpgradeRetryFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BandwidthUpgradeRetryFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BandwidthUpgradeRetryFrame& from);
  void MergeFrom(const BandwidthUpgradeRetryFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BandwidthUpgradeRetryFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.BandwidthUpgradeRetryFrame";
  }
  protected:
  explicit BandwidthUpgradeRetryFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Medium = BandwidthUpgradeRetryFrame_Medium;
  static constexpr Medium UNKNOWN_MEDIUM = BandwidthUpgradeRetryFrame_Medium_UNKNOWN_MEDIUM;
  static constexpr Medium BLUETOOTH = BandwidthUpgradeRetryFrame_Medium_BLUETOOTH;
  static constexpr Medium WIFI_HOTSPOT = BandwidthUpgradeRetryFrame_Medium_WIFI_HOTSPOT;
  static constexpr Medium BLE = BandwidthUpgradeRetryFrame_Medium_BLE;
  static constexpr Medium WIFI_LAN = BandwidthUpgradeRetryFrame_Medium_WIFI_LAN;
  static constexpr Medium WIFI_AWARE = BandwidthUpgradeRetryFrame_Medium_WIFI_AWARE;
  static constexpr Medium NFC = BandwidthUpgradeRetryFrame_Medium_NFC;
  static constexpr Medium WIFI_DIRECT = BandwidthUpgradeRetryFrame_Medium_WIFI_DIRECT;
  static constexpr Medium WEB_RTC = BandwidthUpgradeRetryFrame_Medium_WEB_RTC;
  static constexpr Medium BLE_L2CAP = BandwidthUpgradeRetryFrame_Medium_BLE_L2CAP;
  static constexpr Medium USB = BandwidthUpgradeRetryFrame_Medium_USB;
  static inline bool Medium_IsValid(int value) {
    return BandwidthUpgradeRetryFrame_Medium_IsValid(value);
  }
  static constexpr Medium Medium_MIN = BandwidthUpgradeRetryFrame_Medium_Medium_MIN;
  static constexpr Medium Medium_MAX = BandwidthUpgradeRetryFrame_Medium_Medium_MAX;
  static constexpr int Medium_ARRAYSIZE = BandwidthUpgradeRetryFrame_Medium_Medium_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Medium_Name(T value) {
    return BandwidthUpgradeRetryFrame_Medium_Name(value);
  }
  static inline bool Medium_Parse(absl::string_view name, Medium* value) {
    return BandwidthUpgradeRetryFrame_Medium_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedMediumFieldNumber = 1,
    kIsRequestFieldNumber = 2,
  };
  // repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
  int supported_medium_size() const;
  private:
  int _internal_supported_medium_size() const;

  public:
  void clear_supported_medium() ;
  public:
  ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium supported_medium(int index) const;
  void set_supported_medium(int index, ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium value);
  void add_supported_medium(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_medium() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_medium();

  private:
  ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium _internal_supported_medium(int index) const;
  void _internal_add_supported_medium(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_supported_medium() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_medium();

  public:
  // optional bool is_request = 2;
  bool has_is_request() const;
  void clear_is_request() ;
  bool is_request() const;
  void set_is_request(bool value);

  private:
  bool _internal_is_request() const;
  void _internal_set_is_request(bool value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.BandwidthUpgradeRetryFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_medium_;
    bool is_request_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class KeepAliveFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.KeepAliveFrame) */ {
 public:
  inline KeepAliveFrame() : KeepAliveFrame(nullptr) {}
  ~KeepAliveFrame() override;
  explicit PROTOBUF_CONSTEXPR KeepAliveFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeepAliveFrame(const KeepAliveFrame& from);
  KeepAliveFrame(KeepAliveFrame&& from) noexcept
    : KeepAliveFrame() {
    *this = ::std::move(from);
  }

  inline KeepAliveFrame& operator=(const KeepAliveFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAliveFrame& operator=(KeepAliveFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeepAliveFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeepAliveFrame* internal_default_instance() {
    return reinterpret_cast<const KeepAliveFrame*>(
               &_KeepAliveFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(KeepAliveFrame& a, KeepAliveFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepAliveFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepAliveFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeepAliveFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeepAliveFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeepAliveFrame& from);
  void MergeFrom(const KeepAliveFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeepAliveFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.KeepAliveFrame";
  }
  protected:
  explicit KeepAliveFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
    kSeqNumFieldNumber = 2,
  };
  // optional bool ack = 1;
  bool has_ack() const;
  void clear_ack() ;
  bool ack() const;
  void set_ack(bool value);

  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);

  public:
  // optional uint32 seq_num = 2;
  bool has_seq_num() const;
  void clear_seq_num() ;
  ::uint32_t seq_num() const;
  void set_seq_num(::uint32_t value);

  private:
  ::uint32_t _internal_seq_num() const;
  void _internal_set_seq_num(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.KeepAliveFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ack_;
    ::uint32_t seq_num_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class DisconnectionFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.DisconnectionFrame) */ {
 public:
  inline DisconnectionFrame() : DisconnectionFrame(nullptr) {}
  ~DisconnectionFrame() override;
  explicit PROTOBUF_CONSTEXPR DisconnectionFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectionFrame(const DisconnectionFrame& from);
  DisconnectionFrame(DisconnectionFrame&& from) noexcept
    : DisconnectionFrame() {
    *this = ::std::move(from);
  }

  inline DisconnectionFrame& operator=(const DisconnectionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectionFrame& operator=(DisconnectionFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisconnectionFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectionFrame* internal_default_instance() {
    return reinterpret_cast<const DisconnectionFrame*>(
               &_DisconnectionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DisconnectionFrame& a, DisconnectionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectionFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectionFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DisconnectionFrame& from);
  void MergeFrom(const DisconnectionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisconnectionFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.DisconnectionFrame";
  }
  protected:
  explicit DisconnectionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestSafeToDisconnectFieldNumber = 1,
    kAckSafeToDisconnectFieldNumber = 2,
  };
  // optional bool request_safe_to_disconnect = 1;
  bool has_request_safe_to_disconnect() const;
  void clear_request_safe_to_disconnect() ;
  bool request_safe_to_disconnect() const;
  void set_request_safe_to_disconnect(bool value);

  private:
  bool _internal_request_safe_to_disconnect() const;
  void _internal_set_request_safe_to_disconnect(bool value);

  public:
  // optional bool ack_safe_to_disconnect = 2;
  bool has_ack_safe_to_disconnect() const;
  void clear_ack_safe_to_disconnect() ;
  bool ack_safe_to_disconnect() const;
  void set_ack_safe_to_disconnect(bool value);

  private:
  bool _internal_ack_safe_to_disconnect() const;
  void _internal_set_ack_safe_to_disconnect(bool value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.DisconnectionFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool request_safe_to_disconnect_;
    bool ack_safe_to_disconnect_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class PairedKeyEncryptionFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PairedKeyEncryptionFrame) */ {
 public:
  inline PairedKeyEncryptionFrame() : PairedKeyEncryptionFrame(nullptr) {}
  ~PairedKeyEncryptionFrame() override;
  explicit PROTOBUF_CONSTEXPR PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from);
  PairedKeyEncryptionFrame(PairedKeyEncryptionFrame&& from) noexcept
    : PairedKeyEncryptionFrame() {
    *this = ::std::move(from);
  }

  inline PairedKeyEncryptionFrame& operator=(const PairedKeyEncryptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairedKeyEncryptionFrame& operator=(PairedKeyEncryptionFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PairedKeyEncryptionFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairedKeyEncryptionFrame* internal_default_instance() {
    return reinterpret_cast<const PairedKeyEncryptionFrame*>(
               &_PairedKeyEncryptionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PairedKeyEncryptionFrame& a, PairedKeyEncryptionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairedKeyEncryptionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PairedKeyEncryptionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PairedKeyEncryptionFrame& from);
  void MergeFrom(const PairedKeyEncryptionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairedKeyEncryptionFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.PairedKeyEncryptionFrame";
  }
  protected:
  explicit PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedDataFieldNumber = 1,
  };
  // optional bytes signed_data = 1;
  bool has_signed_data() const;
  void clear_signed_data() ;
  const std::string& signed_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signed_data(Arg_&& arg, Args_... args);
  std::string* mutable_signed_data();
  PROTOBUF_NODISCARD std::string* release_signed_data();
  void set_allocated_signed_data(std::string* ptr);

  private:
  const std::string& _internal_signed_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_data(
      const std::string& value);
  std::string* _internal_mutable_signed_data();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.PairedKeyEncryptionFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class AuthenticationMessageFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AuthenticationMessageFrame) */ {
 public:
  inline AuthenticationMessageFrame() : AuthenticationMessageFrame(nullptr) {}
  ~AuthenticationMessageFrame() override;
  explicit PROTOBUF_CONSTEXPR AuthenticationMessageFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationMessageFrame(const AuthenticationMessageFrame& from);
  AuthenticationMessageFrame(AuthenticationMessageFrame&& from) noexcept
    : AuthenticationMessageFrame() {
    *this = ::std::move(from);
  }

  inline AuthenticationMessageFrame& operator=(const AuthenticationMessageFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationMessageFrame& operator=(AuthenticationMessageFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthenticationMessageFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationMessageFrame* internal_default_instance() {
    return reinterpret_cast<const AuthenticationMessageFrame*>(
               &_AuthenticationMessageFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AuthenticationMessageFrame& a, AuthenticationMessageFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationMessageFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationMessageFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticationMessageFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticationMessageFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthenticationMessageFrame& from);
  void MergeFrom(const AuthenticationMessageFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticationMessageFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.AuthenticationMessageFrame";
  }
  protected:
  explicit AuthenticationMessageFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthMessageFieldNumber = 1,
  };
  // optional bytes auth_message = 1;
  bool has_auth_message() const;
  void clear_auth_message() ;
  const std::string& auth_message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auth_message(Arg_&& arg, Args_... args);
  std::string* mutable_auth_message();
  PROTOBUF_NODISCARD std::string* release_auth_message();
  void set_allocated_auth_message(std::string* ptr);

  private:
  const std::string& _internal_auth_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_message(
      const std::string& value);
  std::string* _internal_mutable_auth_message();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.AuthenticationMessageFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class AuthenticationResultFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AuthenticationResultFrame) */ {
 public:
  inline AuthenticationResultFrame() : AuthenticationResultFrame(nullptr) {}
  ~AuthenticationResultFrame() override;
  explicit PROTOBUF_CONSTEXPR AuthenticationResultFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationResultFrame(const AuthenticationResultFrame& from);
  AuthenticationResultFrame(AuthenticationResultFrame&& from) noexcept
    : AuthenticationResultFrame() {
    *this = ::std::move(from);
  }

  inline AuthenticationResultFrame& operator=(const AuthenticationResultFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationResultFrame& operator=(AuthenticationResultFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthenticationResultFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationResultFrame* internal_default_instance() {
    return reinterpret_cast<const AuthenticationResultFrame*>(
               &_AuthenticationResultFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AuthenticationResultFrame& a, AuthenticationResultFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationResultFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationResultFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticationResultFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticationResultFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AuthenticationResultFrame& from);
  void MergeFrom(const AuthenticationResultFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticationResultFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.AuthenticationResultFrame";
  }
  protected:
  explicit AuthenticationResultFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional int32 result = 1;
  bool has_result() const;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.AuthenticationResultFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class AutoResumeFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AutoResumeFrame) */ {
 public:
  inline AutoResumeFrame() : AutoResumeFrame(nullptr) {}
  ~AutoResumeFrame() override;
  explicit PROTOBUF_CONSTEXPR AutoResumeFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoResumeFrame(const AutoResumeFrame& from);
  AutoResumeFrame(AutoResumeFrame&& from) noexcept
    : AutoResumeFrame() {
    *this = ::std::move(from);
  }

  inline AutoResumeFrame& operator=(const AutoResumeFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoResumeFrame& operator=(AutoResumeFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutoResumeFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoResumeFrame* internal_default_instance() {
    return reinterpret_cast<const AutoResumeFrame*>(
               &_AutoResumeFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AutoResumeFrame& a, AutoResumeFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoResumeFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoResumeFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoResumeFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoResumeFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutoResumeFrame& from);
  void MergeFrom(const AutoResumeFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoResumeFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.AutoResumeFrame";
  }
  protected:
  explicit AutoResumeFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using EventType = AutoResumeFrame_EventType;
  static constexpr EventType UNKNOWN_AUTO_RESUME_EVENT_TYPE = AutoResumeFrame_EventType_UNKNOWN_AUTO_RESUME_EVENT_TYPE;
  static constexpr EventType PAYLOAD_RESUME_TRANSFER_START = AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_START;
  static constexpr EventType PAYLOAD_RESUME_TRANSFER_ACK = AutoResumeFrame_EventType_PAYLOAD_RESUME_TRANSFER_ACK;
  static inline bool EventType_IsValid(int value) {
    return AutoResumeFrame_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN = AutoResumeFrame_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX = AutoResumeFrame_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE = AutoResumeFrame_EventType_EventType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& EventType_Name(T value) {
    return AutoResumeFrame_EventType_Name(value);
  }
  static inline bool EventType_Parse(absl::string_view name, EventType* value) {
    return AutoResumeFrame_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPendingPayloadIdFieldNumber = 2,
    kEventTypeFieldNumber = 1,
    kNextPayloadChunkIndexFieldNumber = 3,
  };
  // optional int64 pending_payload_id = 2;
  bool has_pending_payload_id() const;
  void clear_pending_payload_id() ;
  ::int64_t pending_payload_id() const;
  void set_pending_payload_id(::int64_t value);

  private:
  ::int64_t _internal_pending_payload_id() const;
  void _internal_set_pending_payload_id(::int64_t value);

  public:
  // optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
  bool has_event_type() const;
  void clear_event_type() ;
  ::location::nearby::connections::AutoResumeFrame_EventType event_type() const;
  void set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value);

  private:
  ::location::nearby::connections::AutoResumeFrame_EventType _internal_event_type() const;
  void _internal_set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value);

  public:
  // optional int32 next_payload_chunk_index = 3;
  bool has_next_payload_chunk_index() const;
  void clear_next_payload_chunk_index() ;
  ::int32_t next_payload_chunk_index() const;
  void set_next_payload_chunk_index(::int32_t value);

  private:
  ::int32_t _internal_next_payload_chunk_index() const;
  void _internal_set_next_payload_chunk_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.AutoResumeFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t pending_payload_id_;
    int event_type_;
    ::int32_t next_payload_chunk_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class AutoReconnectFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AutoReconnectFrame) */ {
 public:
  inline AutoReconnectFrame() : AutoReconnectFrame(nullptr) {}
  ~AutoReconnectFrame() override;
  explicit PROTOBUF_CONSTEXPR AutoReconnectFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoReconnectFrame(const AutoReconnectFrame& from);
  AutoReconnectFrame(AutoReconnectFrame&& from) noexcept
    : AutoReconnectFrame() {
    *this = ::std::move(from);
  }

  inline AutoReconnectFrame& operator=(const AutoReconnectFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoReconnectFrame& operator=(AutoReconnectFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutoReconnectFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoReconnectFrame* internal_default_instance() {
    return reinterpret_cast<const AutoReconnectFrame*>(
               &_AutoReconnectFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AutoReconnectFrame& a, AutoReconnectFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoReconnectFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoReconnectFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoReconnectFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoReconnectFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutoReconnectFrame& from);
  void MergeFrom(const AutoReconnectFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoReconnectFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.AutoReconnectFrame";
  }
  protected:
  explicit AutoReconnectFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using EventType = AutoReconnectFrame_EventType;
  static constexpr EventType UNKNOWN_EVENT_TYPE = AutoReconnectFrame_EventType_UNKNOWN_EVENT_TYPE;
  static constexpr EventType CLIENT_INTRODUCTION = AutoReconnectFrame_EventType_CLIENT_INTRODUCTION;
  static constexpr EventType CLIENT_INTRODUCTION_ACK = AutoReconnectFrame_EventType_CLIENT_INTRODUCTION_ACK;
  static inline bool EventType_IsValid(int value) {
    return AutoReconnectFrame_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN = AutoReconnectFrame_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX = AutoReconnectFrame_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE = AutoReconnectFrame_EventType_EventType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& EventType_Name(T value) {
    return AutoReconnectFrame_EventType_Name(value);
  }
  static inline bool EventType_Parse(absl::string_view name, EventType* value) {
    return AutoReconnectFrame_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
  };
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  void clear_endpoint_id() ;
  const std::string& endpoint_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* ptr);

  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(
      const std::string& value);
  std::string* _internal_mutable_endpoint_id();

  public:
  // optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
  bool has_event_type() const;
  void clear_event_type() ;
  ::location::nearby::connections::AutoReconnectFrame_EventType event_type() const;
  void set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value);

  private:
  ::location::nearby::connections::AutoReconnectFrame_EventType _internal_event_type() const;
  void _internal_set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.AutoReconnectFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
    int event_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class MediumMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.MediumMetadata) */ {
 public:
  inline MediumMetadata() : MediumMetadata(nullptr) {}
  ~MediumMetadata() override;
  explicit PROTOBUF_CONSTEXPR MediumMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediumMetadata(const MediumMetadata& from);
  MediumMetadata(MediumMetadata&& from) noexcept
    : MediumMetadata() {
    *this = ::std::move(from);
  }

  inline MediumMetadata& operator=(const MediumMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediumMetadata& operator=(MediumMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MediumMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediumMetadata* internal_default_instance() {
    return reinterpret_cast<const MediumMetadata*>(
               &_MediumMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MediumMetadata& a, MediumMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MediumMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediumMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediumMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediumMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MediumMetadata& from);
  void MergeFrom(const MediumMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MediumMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.MediumMetadata";
  }
  protected:
  explicit MediumMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBssidFieldNumber = 2,
    kIpAddressFieldNumber = 3,
    kAvailableChannelsFieldNumber = 7,
    kWifiDirectCliUsableChannelsFieldNumber = 8,
    kWifiLanUsableChannelsFieldNumber = 9,
    kWifiAwareUsableChannelsFieldNumber = 10,
    kWifiHotspotStaUsableChannelsFieldNumber = 11,
    kSupports5GhzFieldNumber = 1,
    kSupports6GhzFieldNumber = 4,
    kMobileRadioFieldNumber = 5,
    kApFrequencyFieldNumber = 6,
  };
  // optional string bssid = 2;
  bool has_bssid() const;
  void clear_bssid() ;
  const std::string& bssid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bssid(Arg_&& arg, Args_... args);
  std::string* mutable_bssid();
  PROTOBUF_NODISCARD std::string* release_bssid();
  void set_allocated_bssid(std::string* ptr);

  private:
  const std::string& _internal_bssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bssid(
      const std::string& value);
  std::string* _internal_mutable_bssid();

  public:
  // optional bytes ip_address = 3;
  bool has_ip_address() const;
  void clear_ip_address() ;
  const std::string& ip_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ptr);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // optional .location.nearby.connections.AvailableChannels available_channels = 7;
  bool has_available_channels() const;
  void clear_available_channels() ;
  const ::location::nearby::connections::AvailableChannels& available_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::AvailableChannels* release_available_channels();
  ::location::nearby::connections::AvailableChannels* mutable_available_channels();
  void set_allocated_available_channels(::location::nearby::connections::AvailableChannels* available_channels);
  private:
  const ::location::nearby::connections::AvailableChannels& _internal_available_channels() const;
  ::location::nearby::connections::AvailableChannels* _internal_mutable_available_channels();
  public:
  void unsafe_arena_set_allocated_available_channels(
      ::location::nearby::connections::AvailableChannels* available_channels);
  ::location::nearby::connections::AvailableChannels* unsafe_arena_release_available_channels();
  // optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
  bool has_wifi_direct_cli_usable_channels() const;
  void clear_wifi_direct_cli_usable_channels() ;
  const ::location::nearby::connections::WifiDirectCliUsableChannels& wifi_direct_cli_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiDirectCliUsableChannels* release_wifi_direct_cli_usable_channels();
  ::location::nearby::connections::WifiDirectCliUsableChannels* mutable_wifi_direct_cli_usable_channels();
  void set_allocated_wifi_direct_cli_usable_channels(::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels);
  private:
  const ::location::nearby::connections::WifiDirectCliUsableChannels& _internal_wifi_direct_cli_usable_channels() const;
  ::location::nearby::connections::WifiDirectCliUsableChannels* _internal_mutable_wifi_direct_cli_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_direct_cli_usable_channels(
      ::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels);
  ::location::nearby::connections::WifiDirectCliUsableChannels* unsafe_arena_release_wifi_direct_cli_usable_channels();
  // optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
  bool has_wifi_lan_usable_channels() const;
  void clear_wifi_lan_usable_channels() ;
  const ::location::nearby::connections::WifiLanUsableChannels& wifi_lan_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiLanUsableChannels* release_wifi_lan_usable_channels();
  ::location::nearby::connections::WifiLanUsableChannels* mutable_wifi_lan_usable_channels();
  void set_allocated_wifi_lan_usable_channels(::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels);
  private:
  const ::location::nearby::connections::WifiLanUsableChannels& _internal_wifi_lan_usable_channels() const;
  ::location::nearby::connections::WifiLanUsableChannels* _internal_mutable_wifi_lan_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_lan_usable_channels(
      ::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels);
  ::location::nearby::connections::WifiLanUsableChannels* unsafe_arena_release_wifi_lan_usable_channels();
  // optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
  bool has_wifi_aware_usable_channels() const;
  void clear_wifi_aware_usable_channels() ;
  const ::location::nearby::connections::WifiAwareUsableChannels& wifi_aware_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiAwareUsableChannels* release_wifi_aware_usable_channels();
  ::location::nearby::connections::WifiAwareUsableChannels* mutable_wifi_aware_usable_channels();
  void set_allocated_wifi_aware_usable_channels(::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels);
  private:
  const ::location::nearby::connections::WifiAwareUsableChannels& _internal_wifi_aware_usable_channels() const;
  ::location::nearby::connections::WifiAwareUsableChannels* _internal_mutable_wifi_aware_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_aware_usable_channels(
      ::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels);
  ::location::nearby::connections::WifiAwareUsableChannels* unsafe_arena_release_wifi_aware_usable_channels();
  // optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
  bool has_wifi_hotspot_sta_usable_channels() const;
  void clear_wifi_hotspot_sta_usable_channels() ;
  const ::location::nearby::connections::WifiHotspotStaUsableChannels& wifi_hotspot_sta_usable_channels() const;
  PROTOBUF_NODISCARD ::location::nearby::connections::WifiHotspotStaUsableChannels* release_wifi_hotspot_sta_usable_channels();
  ::location::nearby::connections::WifiHotspotStaUsableChannels* mutable_wifi_hotspot_sta_usable_channels();
  void set_allocated_wifi_hotspot_sta_usable_channels(::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels);
  private:
  const ::location::nearby::connections::WifiHotspotStaUsableChannels& _internal_wifi_hotspot_sta_usable_channels() const;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* _internal_mutable_wifi_hotspot_sta_usable_channels();
  public:
  void unsafe_arena_set_allocated_wifi_hotspot_sta_usable_channels(
      ::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels);
  ::location::nearby::connections::WifiHotspotStaUsableChannels* unsafe_arena_release_wifi_hotspot_sta_usable_channels();
  // optional bool supports_5_ghz = 1;
  bool has_supports_5_ghz() const;
  void clear_supports_5_ghz() ;
  bool supports_5_ghz() const;
  void set_supports_5_ghz(bool value);

  private:
  bool _internal_supports_5_ghz() const;
  void _internal_set_supports_5_ghz(bool value);

  public:
  // optional bool supports_6_ghz = 4;
  bool has_supports_6_ghz() const;
  void clear_supports_6_ghz() ;
  bool supports_6_ghz() const;
  void set_supports_6_ghz(bool value);

  private:
  bool _internal_supports_6_ghz() const;
  void _internal_set_supports_6_ghz(bool value);

  public:
  // optional bool mobile_radio = 5;
  bool has_mobile_radio() const;
  void clear_mobile_radio() ;
  bool mobile_radio() const;
  void set_mobile_radio(bool value);

  private:
  bool _internal_mobile_radio() const;
  void _internal_set_mobile_radio(bool value);

  public:
  // optional int32 ap_frequency = 6 [default = -1];
  bool has_ap_frequency() const;
  void clear_ap_frequency() ;
  ::int32_t ap_frequency() const;
  void set_ap_frequency(::int32_t value);

  private:
  ::int32_t _internal_ap_frequency() const;
  void _internal_set_ap_frequency(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.MediumMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bssid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::location::nearby::connections::AvailableChannels* available_channels_;
    ::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels_;
    ::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels_;
    ::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels_;
    ::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels_;
    bool supports_5_ghz_;
    bool supports_6_ghz_;
    bool mobile_radio_;
    ::int32_t ap_frequency_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class AvailableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.AvailableChannels) */ {
 public:
  inline AvailableChannels() : AvailableChannels(nullptr) {}
  ~AvailableChannels() override;
  explicit PROTOBUF_CONSTEXPR AvailableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailableChannels(const AvailableChannels& from);
  AvailableChannels(AvailableChannels&& from) noexcept
    : AvailableChannels() {
    *this = ::std::move(from);
  }

  inline AvailableChannels& operator=(const AvailableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableChannels& operator=(AvailableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvailableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailableChannels* internal_default_instance() {
    return reinterpret_cast<const AvailableChannels*>(
               &_AvailableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AvailableChannels& a, AvailableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvailableChannels& from);
  void MergeFrom(const AvailableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvailableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.AvailableChannels";
  }
  protected:
  explicit AvailableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_channels();

  private:
  ::int32_t _internal_channels(int index) const;
  void _internal_add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.AvailableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _channels_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class WifiDirectCliUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiDirectCliUsableChannels) */ {
 public:
  inline WifiDirectCliUsableChannels() : WifiDirectCliUsableChannels(nullptr) {}
  ~WifiDirectCliUsableChannels() override;
  explicit PROTOBUF_CONSTEXPR WifiDirectCliUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiDirectCliUsableChannels(const WifiDirectCliUsableChannels& from);
  WifiDirectCliUsableChannels(WifiDirectCliUsableChannels&& from) noexcept
    : WifiDirectCliUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiDirectCliUsableChannels& operator=(const WifiDirectCliUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiDirectCliUsableChannels& operator=(WifiDirectCliUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiDirectCliUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiDirectCliUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiDirectCliUsableChannels*>(
               &_WifiDirectCliUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(WifiDirectCliUsableChannels& a, WifiDirectCliUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiDirectCliUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiDirectCliUsableChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiDirectCliUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiDirectCliUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiDirectCliUsableChannels& from);
  void MergeFrom(const WifiDirectCliUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiDirectCliUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.WifiDirectCliUsableChannels";
  }
  protected:
  explicit WifiDirectCliUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_channels();

  private:
  ::int32_t _internal_channels(int index) const;
  void _internal_add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiDirectCliUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _channels_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class WifiLanUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiLanUsableChannels) */ {
 public:
  inline WifiLanUsableChannels() : WifiLanUsableChannels(nullptr) {}
  ~WifiLanUsableChannels() override;
  explicit PROTOBUF_CONSTEXPR WifiLanUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiLanUsableChannels(const WifiLanUsableChannels& from);
  WifiLanUsableChannels(WifiLanUsableChannels&& from) noexcept
    : WifiLanUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiLanUsableChannels& operator=(const WifiLanUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiLanUsableChannels& operator=(WifiLanUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiLanUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiLanUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiLanUsableChannels*>(
               &_WifiLanUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(WifiLanUsableChannels& a, WifiLanUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiLanUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiLanUsableChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiLanUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiLanUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiLanUsableChannels& from);
  void MergeFrom(const WifiLanUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiLanUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.WifiLanUsableChannels";
  }
  protected:
  explicit WifiLanUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_channels();

  private:
  ::int32_t _internal_channels(int index) const;
  void _internal_add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiLanUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _channels_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class WifiAwareUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiAwareUsableChannels) */ {
 public:
  inline WifiAwareUsableChannels() : WifiAwareUsableChannels(nullptr) {}
  ~WifiAwareUsableChannels() override;
  explicit PROTOBUF_CONSTEXPR WifiAwareUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiAwareUsableChannels(const WifiAwareUsableChannels& from);
  WifiAwareUsableChannels(WifiAwareUsableChannels&& from) noexcept
    : WifiAwareUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiAwareUsableChannels& operator=(const WifiAwareUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiAwareUsableChannels& operator=(WifiAwareUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiAwareUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiAwareUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiAwareUsableChannels*>(
               &_WifiAwareUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(WifiAwareUsableChannels& a, WifiAwareUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiAwareUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiAwareUsableChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiAwareUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiAwareUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiAwareUsableChannels& from);
  void MergeFrom(const WifiAwareUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiAwareUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.WifiAwareUsableChannels";
  }
  protected:
  explicit WifiAwareUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_channels();

  private:
  ::int32_t _internal_channels(int index) const;
  void _internal_add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiAwareUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _channels_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class WifiHotspotStaUsableChannels final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.WifiHotspotStaUsableChannels) */ {
 public:
  inline WifiHotspotStaUsableChannels() : WifiHotspotStaUsableChannels(nullptr) {}
  ~WifiHotspotStaUsableChannels() override;
  explicit PROTOBUF_CONSTEXPR WifiHotspotStaUsableChannels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiHotspotStaUsableChannels(const WifiHotspotStaUsableChannels& from);
  WifiHotspotStaUsableChannels(WifiHotspotStaUsableChannels&& from) noexcept
    : WifiHotspotStaUsableChannels() {
    *this = ::std::move(from);
  }

  inline WifiHotspotStaUsableChannels& operator=(const WifiHotspotStaUsableChannels& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiHotspotStaUsableChannels& operator=(WifiHotspotStaUsableChannels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiHotspotStaUsableChannels& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiHotspotStaUsableChannels* internal_default_instance() {
    return reinterpret_cast<const WifiHotspotStaUsableChannels*>(
               &_WifiHotspotStaUsableChannels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(WifiHotspotStaUsableChannels& a, WifiHotspotStaUsableChannels& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiHotspotStaUsableChannels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiHotspotStaUsableChannels* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiHotspotStaUsableChannels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiHotspotStaUsableChannels>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiHotspotStaUsableChannels& from);
  void MergeFrom(const WifiHotspotStaUsableChannels& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiHotspotStaUsableChannels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.WifiHotspotStaUsableChannels";
  }
  protected:
  explicit WifiHotspotStaUsableChannels(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated int32 channels = 1 [packed = true];
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_channels();

  private:
  ::int32_t _internal_channels(int index) const;
  void _internal_add_channels(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.WifiHotspotStaUsableChannels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _channels_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class LocationHint final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.LocationHint) */ {
 public:
  inline LocationHint() : LocationHint(nullptr) {}
  ~LocationHint() override;
  explicit PROTOBUF_CONSTEXPR LocationHint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationHint(const LocationHint& from);
  LocationHint(LocationHint&& from) noexcept
    : LocationHint() {
    *this = ::std::move(from);
  }

  inline LocationHint& operator=(const LocationHint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationHint& operator=(LocationHint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LocationHint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationHint* internal_default_instance() {
    return reinterpret_cast<const LocationHint*>(
               &_LocationHint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(LocationHint& a, LocationHint& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationHint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationHint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationHint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationHint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocationHint& from);
  void MergeFrom(const LocationHint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocationHint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.LocationHint";
  }
  protected:
  explicit LocationHint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // optional string location = 1;
  bool has_location() const;
  void clear_location() ;
  const std::string& location() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_location(Arg_&& arg, Args_... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* ptr);

  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(
      const std::string& value);
  std::string* _internal_mutable_location();

  public:
  // optional .location.nearby.connections.LocationStandard.Format format = 2;
  bool has_format() const;
  void clear_format() ;
  ::location::nearby::connections::LocationStandard_Format format() const;
  void set_format(::location::nearby::connections::LocationStandard_Format value);

  private:
  ::location::nearby::connections::LocationStandard_Format _internal_format() const;
  void _internal_set_format(::location::nearby::connections::LocationStandard_Format value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.LocationHint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    int format_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class LocationStandard final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.LocationStandard) */ {
 public:
  inline LocationStandard() : LocationStandard(nullptr) {}
  ~LocationStandard() override;
  explicit PROTOBUF_CONSTEXPR LocationStandard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationStandard(const LocationStandard& from);
  LocationStandard(LocationStandard&& from) noexcept
    : LocationStandard() {
    *this = ::std::move(from);
  }

  inline LocationStandard& operator=(const LocationStandard& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationStandard& operator=(LocationStandard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LocationStandard& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationStandard* internal_default_instance() {
    return reinterpret_cast<const LocationStandard*>(
               &_LocationStandard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(LocationStandard& a, LocationStandard& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationStandard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationStandard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationStandard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationStandard>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LocationStandard& from);
  void MergeFrom(const LocationStandard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocationStandard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.LocationStandard";
  }
  protected:
  explicit LocationStandard(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Format = LocationStandard_Format;
  static constexpr Format UNKNOWN = LocationStandard_Format_UNKNOWN;
  static constexpr Format E164_CALLING = LocationStandard_Format_E164_CALLING;
  static constexpr Format ISO_3166_1_ALPHA_2 = LocationStandard_Format_ISO_3166_1_ALPHA_2;
  static inline bool Format_IsValid(int value) {
    return LocationStandard_Format_IsValid(value);
  }
  static constexpr Format Format_MIN = LocationStandard_Format_Format_MIN;
  static constexpr Format Format_MAX = LocationStandard_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE = LocationStandard_Format_Format_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Format_Name(T value) {
    return LocationStandard_Format_Name(value);
  }
  static inline bool Format_Parse(absl::string_view name, Format* value) {
    return LocationStandard_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:location.nearby.connections.LocationStandard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class OsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.OsInfo) */ {
 public:
  inline OsInfo() : OsInfo(nullptr) {}
  ~OsInfo() override;
  explicit PROTOBUF_CONSTEXPR OsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OsInfo(const OsInfo& from);
  OsInfo(OsInfo&& from) noexcept
    : OsInfo() {
    *this = ::std::move(from);
  }

  inline OsInfo& operator=(const OsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OsInfo& operator=(OsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OsInfo* internal_default_instance() {
    return reinterpret_cast<const OsInfo*>(
               &_OsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(OsInfo& a, OsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OsInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OsInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OsInfo& from);
  void MergeFrom(const OsInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.OsInfo";
  }
  protected:
  explicit OsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using OsType = OsInfo_OsType;
  static constexpr OsType UNKNOWN_OS_TYPE = OsInfo_OsType_UNKNOWN_OS_TYPE;
  static constexpr OsType ANDROID = OsInfo_OsType_ANDROID;
  static constexpr OsType CHROME_OS = OsInfo_OsType_CHROME_OS;
  static constexpr OsType WINDOWS = OsInfo_OsType_WINDOWS;
  static constexpr OsType APPLE = OsInfo_OsType_APPLE;
  static constexpr OsType LINUX = OsInfo_OsType_LINUX;
  static inline bool OsType_IsValid(int value) {
    return OsInfo_OsType_IsValid(value);
  }
  static constexpr OsType OsType_MIN = OsInfo_OsType_OsType_MIN;
  static constexpr OsType OsType_MAX = OsInfo_OsType_OsType_MAX;
  static constexpr int OsType_ARRAYSIZE = OsInfo_OsType_OsType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& OsType_Name(T value) {
    return OsInfo_OsType_Name(value);
  }
  static inline bool OsType_Parse(absl::string_view name, OsType* value) {
    return OsInfo_OsType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .location.nearby.connections.OsInfo.OsType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::location::nearby::connections::OsInfo_OsType type() const;
  void set_type(::location::nearby::connections::OsInfo_OsType value);

  private:
  ::location::nearby::connections::OsInfo_OsType _internal_type() const;
  void _internal_set_type(::location::nearby::connections::OsInfo_OsType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.OsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class ConnectionsDevice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.ConnectionsDevice) */ {
 public:
  inline ConnectionsDevice() : ConnectionsDevice(nullptr) {}
  ~ConnectionsDevice() override;
  explicit PROTOBUF_CONSTEXPR ConnectionsDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionsDevice(const ConnectionsDevice& from);
  ConnectionsDevice(ConnectionsDevice&& from) noexcept
    : ConnectionsDevice() {
    *this = ::std::move(from);
  }

  inline ConnectionsDevice& operator=(const ConnectionsDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionsDevice& operator=(ConnectionsDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionsDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionsDevice* internal_default_instance() {
    return reinterpret_cast<const ConnectionsDevice*>(
               &_ConnectionsDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ConnectionsDevice& a, ConnectionsDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionsDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionsDevice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionsDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionsDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionsDevice& from);
  void MergeFrom(const ConnectionsDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionsDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.ConnectionsDevice";
  }
  protected:
  explicit ConnectionsDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointIdFieldNumber = 1,
    kConnectivityInfoListFieldNumber = 3,
    kEndpointInfoFieldNumber = 4,
    kEndpointTypeFieldNumber = 2,
  };
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  void clear_endpoint_id() ;
  const std::string& endpoint_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* ptr);

  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(
      const std::string& value);
  std::string* _internal_mutable_endpoint_id();

  public:
  // optional bytes connectivity_info_list = 3;
  bool has_connectivity_info_list() const;
  void clear_connectivity_info_list() ;
  const std::string& connectivity_info_list() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectivity_info_list(Arg_&& arg, Args_... args);
  std::string* mutable_connectivity_info_list();
  PROTOBUF_NODISCARD std::string* release_connectivity_info_list();
  void set_allocated_connectivity_info_list(std::string* ptr);

  private:
  const std::string& _internal_connectivity_info_list() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectivity_info_list(
      const std::string& value);
  std::string* _internal_mutable_connectivity_info_list();

  public:
  // optional bytes endpoint_info = 4;
  bool has_endpoint_info() const;
  void clear_endpoint_info() ;
  const std::string& endpoint_info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_info(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_info();
  PROTOBUF_NODISCARD std::string* release_endpoint_info();
  void set_allocated_endpoint_info(std::string* ptr);

  private:
  const std::string& _internal_endpoint_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_info(
      const std::string& value);
  std::string* _internal_mutable_endpoint_info();

  public:
  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  bool has_endpoint_type() const;
  void clear_endpoint_type() ;
  ::location::nearby::connections::EndpointType endpoint_type() const;
  void set_endpoint_type(::location::nearby::connections::EndpointType value);

  private:
  ::location::nearby::connections::EndpointType _internal_endpoint_type() const;
  void _internal_set_endpoint_type(::location::nearby::connections::EndpointType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.ConnectionsDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectivity_info_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_info_;
    int endpoint_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};// -------------------------------------------------------------------

class PresenceDevice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:location.nearby.connections.PresenceDevice) */ {
 public:
  inline PresenceDevice() : PresenceDevice(nullptr) {}
  ~PresenceDevice() override;
  explicit PROTOBUF_CONSTEXPR PresenceDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PresenceDevice(const PresenceDevice& from);
  PresenceDevice(PresenceDevice&& from) noexcept
    : PresenceDevice() {
    *this = ::std::move(from);
  }

  inline PresenceDevice& operator=(const PresenceDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresenceDevice& operator=(PresenceDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PresenceDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresenceDevice* internal_default_instance() {
    return reinterpret_cast<const PresenceDevice*>(
               &_PresenceDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(PresenceDevice& a, PresenceDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(PresenceDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresenceDevice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresenceDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PresenceDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PresenceDevice& from);
  void MergeFrom(const PresenceDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PresenceDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "location.nearby.connections.PresenceDevice";
  }
  protected:
  explicit PresenceDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using DeviceType = PresenceDevice_DeviceType;
  static constexpr DeviceType UNKNOWN = PresenceDevice_DeviceType_UNKNOWN;
  static constexpr DeviceType PHONE = PresenceDevice_DeviceType_PHONE;
  static constexpr DeviceType TABLET = PresenceDevice_DeviceType_TABLET;
  static constexpr DeviceType DISPLAY = PresenceDevice_DeviceType_DISPLAY;
  static constexpr DeviceType LAPTOP = PresenceDevice_DeviceType_LAPTOP;
  static constexpr DeviceType TV = PresenceDevice_DeviceType_TV;
  static constexpr DeviceType WATCH = PresenceDevice_DeviceType_WATCH;
  static inline bool DeviceType_IsValid(int value) {
    return PresenceDevice_DeviceType_IsValid(value);
  }
  static constexpr DeviceType DeviceType_MIN = PresenceDevice_DeviceType_DeviceType_MIN;
  static constexpr DeviceType DeviceType_MAX = PresenceDevice_DeviceType_DeviceType_MAX;
  static constexpr int DeviceType_ARRAYSIZE = PresenceDevice_DeviceType_DeviceType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& DeviceType_Name(T value) {
    return PresenceDevice_DeviceType_Name(value);
  }
  static inline bool DeviceType_Parse(absl::string_view name, DeviceType* value) {
    return PresenceDevice_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDiscoveryMediumFieldNumber = 8,
    kActionsFieldNumber = 9,
    kIdentityTypeFieldNumber = 10,
    kEndpointIdFieldNumber = 1,
    kConnectivityInfoListFieldNumber = 3,
    kDeviceNameFieldNumber = 5,
    kDeviceImageUrlFieldNumber = 7,
    kDeviceIdFieldNumber = 4,
    kEndpointTypeFieldNumber = 2,
    kDeviceTypeFieldNumber = 6,
  };
  // repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
  int discovery_medium_size() const;
  private:
  int _internal_discovery_medium_size() const;

  public:
  void clear_discovery_medium() ;
  public:
  ::location::nearby::connections::ConnectionRequestFrame_Medium discovery_medium(int index) const;
  void set_discovery_medium(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value);
  void add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& discovery_medium() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_discovery_medium();

  private:
  ::location::nearby::connections::ConnectionRequestFrame_Medium _internal_discovery_medium(int index) const;
  void _internal_add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_discovery_medium() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_discovery_medium();

  public:
  // repeated int32 actions = 9 [packed = true];
  int actions_size() const;
  private:
  int _internal_actions_size() const;

  public:
  void clear_actions() ;
  ::int32_t actions(int index) const;
  void set_actions(int index, ::int32_t value);
  void add_actions(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_actions();

  private:
  ::int32_t _internal_actions(int index) const;
  void _internal_add_actions(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_actions();

  public:
  // repeated int64 identity_type = 10 [packed = true];
  int identity_type_size() const;
  private:
  int _internal_identity_type_size() const;

  public:
  void clear_identity_type() ;
  ::int64_t identity_type(int index) const;
  void set_identity_type(int index, ::int64_t value);
  void add_identity_type(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& identity_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* mutable_identity_type();

  private:
  ::int64_t _internal_identity_type(int index) const;
  void _internal_add_identity_type(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& _internal_identity_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* _internal_mutable_identity_type();

  public:
  // optional string endpoint_id = 1;
  bool has_endpoint_id() const;
  void clear_endpoint_id() ;
  const std::string& endpoint_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* ptr);

  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(
      const std::string& value);
  std::string* _internal_mutable_endpoint_id();

  public:
  // optional bytes connectivity_info_list = 3;
  bool has_connectivity_info_list() const;
  void clear_connectivity_info_list() ;
  const std::string& connectivity_info_list() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectivity_info_list(Arg_&& arg, Args_... args);
  std::string* mutable_connectivity_info_list();
  PROTOBUF_NODISCARD std::string* release_connectivity_info_list();
  void set_allocated_connectivity_info_list(std::string* ptr);

  private:
  const std::string& _internal_connectivity_info_list() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectivity_info_list(
      const std::string& value);
  std::string* _internal_mutable_connectivity_info_list();

  public:
  // optional string device_name = 5;
  bool has_device_name() const;
  void clear_device_name() ;
  const std::string& device_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_name(Arg_&& arg, Args_... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* ptr);

  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(
      const std::string& value);
  std::string* _internal_mutable_device_name();

  public:
  // optional string device_image_url = 7;
  bool has_device_image_url() const;
  void clear_device_image_url() ;
  const std::string& device_image_url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_image_url(Arg_&& arg, Args_... args);
  std::string* mutable_device_image_url();
  PROTOBUF_NODISCARD std::string* release_device_image_url();
  void set_allocated_device_image_url(std::string* ptr);

  private:
  const std::string& _internal_device_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_image_url(
      const std::string& value);
  std::string* _internal_mutable_device_image_url();

  public:
  // optional int64 device_id = 4;
  bool has_device_id() const;
  void clear_device_id() ;
  ::int64_t device_id() const;
  void set_device_id(::int64_t value);

  private:
  ::int64_t _internal_device_id() const;
  void _internal_set_device_id(::int64_t value);

  public:
  // optional .location.nearby.connections.EndpointType endpoint_type = 2;
  bool has_endpoint_type() const;
  void clear_endpoint_type() ;
  ::location::nearby::connections::EndpointType endpoint_type() const;
  void set_endpoint_type(::location::nearby::connections::EndpointType value);

  private:
  ::location::nearby::connections::EndpointType _internal_endpoint_type() const;
  void _internal_set_endpoint_type(::location::nearby::connections::EndpointType value);

  public:
  // optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
  bool has_device_type() const;
  void clear_device_type() ;
  ::location::nearby::connections::PresenceDevice_DeviceType device_type() const;
  void set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value);

  private:
  ::location::nearby::connections::PresenceDevice_DeviceType _internal_device_type() const;
  void _internal_set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value);

  public:
  // @@protoc_insertion_point(class_scope:location.nearby.connections.PresenceDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> discovery_medium_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _discovery_medium_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> actions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _actions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t> identity_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _identity_type_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectivity_info_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_image_url_;
    ::int64_t device_id_;
    int endpoint_type_;
    int device_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// OfflineFrame

// optional .location.nearby.connections.OfflineFrame.Version version = 1;
inline bool OfflineFrame::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void OfflineFrame::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::OfflineFrame_Version OfflineFrame::version() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.OfflineFrame.version)
  return _internal_version();
}
inline void OfflineFrame::set_version(::location::nearby::connections::OfflineFrame_Version value) {
   _internal_set_version(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.OfflineFrame.version)
}
inline ::location::nearby::connections::OfflineFrame_Version OfflineFrame::_internal_version() const {
  return static_cast<::location::nearby::connections::OfflineFrame_Version>(_impl_.version_);
}
inline void OfflineFrame::_internal_set_version(::location::nearby::connections::OfflineFrame_Version value) {
  assert(::location::nearby::connections::OfflineFrame_Version_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}

// optional .location.nearby.connections.V1Frame v1 = 2;
inline bool OfflineFrame::has_v1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v1_ != nullptr);
  return value;
}
inline void OfflineFrame::clear_v1() {
  if (_impl_.v1_ != nullptr) _impl_.v1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::V1Frame& OfflineFrame::_internal_v1() const {
  const ::location::nearby::connections::V1Frame* p = _impl_.v1_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::V1Frame&>(
      ::location::nearby::connections::_V1Frame_default_instance_);
}
inline const ::location::nearby::connections::V1Frame& OfflineFrame::v1() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.OfflineFrame.v1)
  return _internal_v1();
}
inline void OfflineFrame::unsafe_arena_set_allocated_v1(
    ::location::nearby::connections::V1Frame* v1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.v1_);
  }
  _impl_.v1_ = v1;
  if (v1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.OfflineFrame.v1)
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::release_v1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::V1Frame* temp = _impl_.v1_;
  _impl_.v1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.OfflineFrame.v1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::V1Frame* temp = _impl_.v1_;
  _impl_.v1_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::_internal_mutable_v1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.v1_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::V1Frame>(GetArenaForAllocation());
    _impl_.v1_ = p;
  }
  return _impl_.v1_;
}
inline ::location::nearby::connections::V1Frame* OfflineFrame::mutable_v1() {
  ::location::nearby::connections::V1Frame* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.OfflineFrame.v1)
  return _msg;
}
inline void OfflineFrame::set_allocated_v1(::location::nearby::connections::V1Frame* v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.v1_;
  }
  if (v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(v1);
    if (message_arena != submessage_arena) {
      v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.v1_ = v1;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.OfflineFrame.v1)
}

// -------------------------------------------------------------------

// V1Frame

// optional .location.nearby.connections.V1Frame.FrameType type = 1;
inline bool V1Frame::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void V1Frame::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::location::nearby::connections::V1Frame_FrameType V1Frame::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.type)
  return _internal_type();
}
inline void V1Frame::set_type(::location::nearby::connections::V1Frame_FrameType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.V1Frame.type)
}
inline ::location::nearby::connections::V1Frame_FrameType V1Frame::_internal_type() const {
  return static_cast<::location::nearby::connections::V1Frame_FrameType>(_impl_.type_);
}
inline void V1Frame::_internal_set_type(::location::nearby::connections::V1Frame_FrameType value) {
  assert(::location::nearby::connections::V1Frame_FrameType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.type_ = value;
}

// optional .location.nearby.connections.ConnectionRequestFrame connection_request = 2;
inline bool V1Frame::has_connection_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connection_request_ != nullptr);
  return value;
}
inline void V1Frame::clear_connection_request() {
  if (_impl_.connection_request_ != nullptr) _impl_.connection_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::ConnectionRequestFrame& V1Frame::_internal_connection_request() const {
  const ::location::nearby::connections::ConnectionRequestFrame* p = _impl_.connection_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::ConnectionRequestFrame&>(
      ::location::nearby::connections::_ConnectionRequestFrame_default_instance_);
}
inline const ::location::nearby::connections::ConnectionRequestFrame& V1Frame::connection_request() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.connection_request)
  return _internal_connection_request();
}
inline void V1Frame::unsafe_arena_set_allocated_connection_request(
    ::location::nearby::connections::ConnectionRequestFrame* connection_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_request_);
  }
  _impl_.connection_request_ = connection_request;
  if (connection_request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.connection_request)
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::release_connection_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::ConnectionRequestFrame* temp = _impl_.connection_request_;
  _impl_.connection_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::unsafe_arena_release_connection_request() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.connection_request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::ConnectionRequestFrame* temp = _impl_.connection_request_;
  _impl_.connection_request_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::_internal_mutable_connection_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.connection_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::ConnectionRequestFrame>(GetArenaForAllocation());
    _impl_.connection_request_ = p;
  }
  return _impl_.connection_request_;
}
inline ::location::nearby::connections::ConnectionRequestFrame* V1Frame::mutable_connection_request() {
  ::location::nearby::connections::ConnectionRequestFrame* _msg = _internal_mutable_connection_request();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.connection_request)
  return _msg;
}
inline void V1Frame::set_allocated_connection_request(::location::nearby::connections::ConnectionRequestFrame* connection_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_request_;
  }
  if (connection_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_request);
    if (message_arena != submessage_arena) {
      connection_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.connection_request_ = connection_request;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.connection_request)
}

// optional .location.nearby.connections.ConnectionResponseFrame connection_response = 3;
inline bool V1Frame::has_connection_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connection_response_ != nullptr);
  return value;
}
inline void V1Frame::clear_connection_response() {
  if (_impl_.connection_response_ != nullptr) _impl_.connection_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::ConnectionResponseFrame& V1Frame::_internal_connection_response() const {
  const ::location::nearby::connections::ConnectionResponseFrame* p = _impl_.connection_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::ConnectionResponseFrame&>(
      ::location::nearby::connections::_ConnectionResponseFrame_default_instance_);
}
inline const ::location::nearby::connections::ConnectionResponseFrame& V1Frame::connection_response() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.connection_response)
  return _internal_connection_response();
}
inline void V1Frame::unsafe_arena_set_allocated_connection_response(
    ::location::nearby::connections::ConnectionResponseFrame* connection_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_response_);
  }
  _impl_.connection_response_ = connection_response;
  if (connection_response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.connection_response)
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::release_connection_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::ConnectionResponseFrame* temp = _impl_.connection_response_;
  _impl_.connection_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::unsafe_arena_release_connection_response() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.connection_response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::ConnectionResponseFrame* temp = _impl_.connection_response_;
  _impl_.connection_response_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::_internal_mutable_connection_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.connection_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::ConnectionResponseFrame>(GetArenaForAllocation());
    _impl_.connection_response_ = p;
  }
  return _impl_.connection_response_;
}
inline ::location::nearby::connections::ConnectionResponseFrame* V1Frame::mutable_connection_response() {
  ::location::nearby::connections::ConnectionResponseFrame* _msg = _internal_mutable_connection_response();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.connection_response)
  return _msg;
}
inline void V1Frame::set_allocated_connection_response(::location::nearby::connections::ConnectionResponseFrame* connection_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_response_;
  }
  if (connection_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_response);
    if (message_arena != submessage_arena) {
      connection_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.connection_response_ = connection_response;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.connection_response)
}

// optional .location.nearby.connections.PayloadTransferFrame payload_transfer = 4;
inline bool V1Frame::has_payload_transfer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_transfer_ != nullptr);
  return value;
}
inline void V1Frame::clear_payload_transfer() {
  if (_impl_.payload_transfer_ != nullptr) _impl_.payload_transfer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::PayloadTransferFrame& V1Frame::_internal_payload_transfer() const {
  const ::location::nearby::connections::PayloadTransferFrame* p = _impl_.payload_transfer_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame&>(
      ::location::nearby::connections::_PayloadTransferFrame_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame& V1Frame::payload_transfer() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.payload_transfer)
  return _internal_payload_transfer();
}
inline void V1Frame::unsafe_arena_set_allocated_payload_transfer(
    ::location::nearby::connections::PayloadTransferFrame* payload_transfer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_transfer_);
  }
  _impl_.payload_transfer_ = payload_transfer;
  if (payload_transfer) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.payload_transfer)
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::release_payload_transfer() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame* temp = _impl_.payload_transfer_;
  _impl_.payload_transfer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::unsafe_arena_release_payload_transfer() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.payload_transfer)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame* temp = _impl_.payload_transfer_;
  _impl_.payload_transfer_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::_internal_mutable_payload_transfer() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.payload_transfer_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame>(GetArenaForAllocation());
    _impl_.payload_transfer_ = p;
  }
  return _impl_.payload_transfer_;
}
inline ::location::nearby::connections::PayloadTransferFrame* V1Frame::mutable_payload_transfer() {
  ::location::nearby::connections::PayloadTransferFrame* _msg = _internal_mutable_payload_transfer();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.payload_transfer)
  return _msg;
}
inline void V1Frame::set_allocated_payload_transfer(::location::nearby::connections::PayloadTransferFrame* payload_transfer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_transfer_;
  }
  if (payload_transfer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_transfer);
    if (message_arena != submessage_arena) {
      payload_transfer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_transfer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.payload_transfer_ = payload_transfer;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.payload_transfer)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame bandwidth_upgrade_negotiation = 5;
inline bool V1Frame::has_bandwidth_upgrade_negotiation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bandwidth_upgrade_negotiation_ != nullptr);
  return value;
}
inline void V1Frame::clear_bandwidth_upgrade_negotiation() {
  if (_impl_.bandwidth_upgrade_negotiation_ != nullptr) _impl_.bandwidth_upgrade_negotiation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& V1Frame::_internal_bandwidth_upgrade_negotiation() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* p = _impl_.bandwidth_upgrade_negotiation_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame& V1Frame::bandwidth_upgrade_negotiation() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
  return _internal_bandwidth_upgrade_negotiation();
}
inline void V1Frame::unsafe_arena_set_allocated_bandwidth_upgrade_negotiation(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bandwidth_upgrade_negotiation_);
  }
  _impl_.bandwidth_upgrade_negotiation_ = bandwidth_upgrade_negotiation;
  if (bandwidth_upgrade_negotiation) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::release_bandwidth_upgrade_negotiation() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* temp = _impl_.bandwidth_upgrade_negotiation_;
  _impl_.bandwidth_upgrade_negotiation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::unsafe_arena_release_bandwidth_upgrade_negotiation() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* temp = _impl_.bandwidth_upgrade_negotiation_;
  _impl_.bandwidth_upgrade_negotiation_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::_internal_mutable_bandwidth_upgrade_negotiation() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.bandwidth_upgrade_negotiation_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame>(GetArenaForAllocation());
    _impl_.bandwidth_upgrade_negotiation_ = p;
  }
  return _impl_.bandwidth_upgrade_negotiation_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* V1Frame::mutable_bandwidth_upgrade_negotiation() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame* _msg = _internal_mutable_bandwidth_upgrade_negotiation();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
  return _msg;
}
inline void V1Frame::set_allocated_bandwidth_upgrade_negotiation(::location::nearby::connections::BandwidthUpgradeNegotiationFrame* bandwidth_upgrade_negotiation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bandwidth_upgrade_negotiation_;
  }
  if (bandwidth_upgrade_negotiation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bandwidth_upgrade_negotiation);
    if (message_arena != submessage_arena) {
      bandwidth_upgrade_negotiation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bandwidth_upgrade_negotiation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.bandwidth_upgrade_negotiation_ = bandwidth_upgrade_negotiation;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.bandwidth_upgrade_negotiation)
}

// optional .location.nearby.connections.KeepAliveFrame keep_alive = 6;
inline bool V1Frame::has_keep_alive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keep_alive_ != nullptr);
  return value;
}
inline void V1Frame::clear_keep_alive() {
  if (_impl_.keep_alive_ != nullptr) _impl_.keep_alive_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::location::nearby::connections::KeepAliveFrame& V1Frame::_internal_keep_alive() const {
  const ::location::nearby::connections::KeepAliveFrame* p = _impl_.keep_alive_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::KeepAliveFrame&>(
      ::location::nearby::connections::_KeepAliveFrame_default_instance_);
}
inline const ::location::nearby::connections::KeepAliveFrame& V1Frame::keep_alive() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.keep_alive)
  return _internal_keep_alive();
}
inline void V1Frame::unsafe_arena_set_allocated_keep_alive(
    ::location::nearby::connections::KeepAliveFrame* keep_alive) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keep_alive_);
  }
  _impl_.keep_alive_ = keep_alive;
  if (keep_alive) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.keep_alive)
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::release_keep_alive() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::KeepAliveFrame* temp = _impl_.keep_alive_;
  _impl_.keep_alive_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::unsafe_arena_release_keep_alive() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.keep_alive)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::KeepAliveFrame* temp = _impl_.keep_alive_;
  _impl_.keep_alive_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::_internal_mutable_keep_alive() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.keep_alive_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::KeepAliveFrame>(GetArenaForAllocation());
    _impl_.keep_alive_ = p;
  }
  return _impl_.keep_alive_;
}
inline ::location::nearby::connections::KeepAliveFrame* V1Frame::mutable_keep_alive() {
  ::location::nearby::connections::KeepAliveFrame* _msg = _internal_mutable_keep_alive();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.keep_alive)
  return _msg;
}
inline void V1Frame::set_allocated_keep_alive(::location::nearby::connections::KeepAliveFrame* keep_alive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.keep_alive_;
  }
  if (keep_alive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keep_alive);
    if (message_arena != submessage_arena) {
      keep_alive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keep_alive, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.keep_alive_ = keep_alive;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.keep_alive)
}

// optional .location.nearby.connections.DisconnectionFrame disconnection = 7;
inline bool V1Frame::has_disconnection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.disconnection_ != nullptr);
  return value;
}
inline void V1Frame::clear_disconnection() {
  if (_impl_.disconnection_ != nullptr) _impl_.disconnection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::DisconnectionFrame& V1Frame::_internal_disconnection() const {
  const ::location::nearby::connections::DisconnectionFrame* p = _impl_.disconnection_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::DisconnectionFrame&>(
      ::location::nearby::connections::_DisconnectionFrame_default_instance_);
}
inline const ::location::nearby::connections::DisconnectionFrame& V1Frame::disconnection() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.disconnection)
  return _internal_disconnection();
}
inline void V1Frame::unsafe_arena_set_allocated_disconnection(
    ::location::nearby::connections::DisconnectionFrame* disconnection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disconnection_);
  }
  _impl_.disconnection_ = disconnection;
  if (disconnection) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.disconnection)
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::release_disconnection() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::DisconnectionFrame* temp = _impl_.disconnection_;
  _impl_.disconnection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::unsafe_arena_release_disconnection() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.disconnection)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::DisconnectionFrame* temp = _impl_.disconnection_;
  _impl_.disconnection_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::_internal_mutable_disconnection() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.disconnection_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::DisconnectionFrame>(GetArenaForAllocation());
    _impl_.disconnection_ = p;
  }
  return _impl_.disconnection_;
}
inline ::location::nearby::connections::DisconnectionFrame* V1Frame::mutable_disconnection() {
  ::location::nearby::connections::DisconnectionFrame* _msg = _internal_mutable_disconnection();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.disconnection)
  return _msg;
}
inline void V1Frame::set_allocated_disconnection(::location::nearby::connections::DisconnectionFrame* disconnection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disconnection_;
  }
  if (disconnection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disconnection);
    if (message_arena != submessage_arena) {
      disconnection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disconnection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.disconnection_ = disconnection;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.disconnection)
}

// optional .location.nearby.connections.PairedKeyEncryptionFrame paired_key_encryption = 8;
inline bool V1Frame::has_paired_key_encryption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paired_key_encryption_ != nullptr);
  return value;
}
inline void V1Frame::clear_paired_key_encryption() {
  if (_impl_.paired_key_encryption_ != nullptr) _impl_.paired_key_encryption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::location::nearby::connections::PairedKeyEncryptionFrame& V1Frame::_internal_paired_key_encryption() const {
  const ::location::nearby::connections::PairedKeyEncryptionFrame* p = _impl_.paired_key_encryption_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PairedKeyEncryptionFrame&>(
      ::location::nearby::connections::_PairedKeyEncryptionFrame_default_instance_);
}
inline const ::location::nearby::connections::PairedKeyEncryptionFrame& V1Frame::paired_key_encryption() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.paired_key_encryption)
  return _internal_paired_key_encryption();
}
inline void V1Frame::unsafe_arena_set_allocated_paired_key_encryption(
    ::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paired_key_encryption_);
  }
  _impl_.paired_key_encryption_ = paired_key_encryption;
  if (paired_key_encryption) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.paired_key_encryption)
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::release_paired_key_encryption() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::PairedKeyEncryptionFrame* temp = _impl_.paired_key_encryption_;
  _impl_.paired_key_encryption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::unsafe_arena_release_paired_key_encryption() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.paired_key_encryption)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::PairedKeyEncryptionFrame* temp = _impl_.paired_key_encryption_;
  _impl_.paired_key_encryption_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::_internal_mutable_paired_key_encryption() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.paired_key_encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PairedKeyEncryptionFrame>(GetArenaForAllocation());
    _impl_.paired_key_encryption_ = p;
  }
  return _impl_.paired_key_encryption_;
}
inline ::location::nearby::connections::PairedKeyEncryptionFrame* V1Frame::mutable_paired_key_encryption() {
  ::location::nearby::connections::PairedKeyEncryptionFrame* _msg = _internal_mutable_paired_key_encryption();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.paired_key_encryption)
  return _msg;
}
inline void V1Frame::set_allocated_paired_key_encryption(::location::nearby::connections::PairedKeyEncryptionFrame* paired_key_encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paired_key_encryption_;
  }
  if (paired_key_encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paired_key_encryption);
    if (message_arena != submessage_arena) {
      paired_key_encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paired_key_encryption, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.paired_key_encryption_ = paired_key_encryption;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.paired_key_encryption)
}

// optional .location.nearby.connections.AuthenticationMessageFrame authentication_message = 9;
inline bool V1Frame::has_authentication_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.authentication_message_ != nullptr);
  return value;
}
inline void V1Frame::clear_authentication_message() {
  if (_impl_.authentication_message_ != nullptr) _impl_.authentication_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::location::nearby::connections::AuthenticationMessageFrame& V1Frame::_internal_authentication_message() const {
  const ::location::nearby::connections::AuthenticationMessageFrame* p = _impl_.authentication_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AuthenticationMessageFrame&>(
      ::location::nearby::connections::_AuthenticationMessageFrame_default_instance_);
}
inline const ::location::nearby::connections::AuthenticationMessageFrame& V1Frame::authentication_message() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.authentication_message)
  return _internal_authentication_message();
}
inline void V1Frame::unsafe_arena_set_allocated_authentication_message(
    ::location::nearby::connections::AuthenticationMessageFrame* authentication_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authentication_message_);
  }
  _impl_.authentication_message_ = authentication_message;
  if (authentication_message) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.authentication_message)
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::release_authentication_message() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::location::nearby::connections::AuthenticationMessageFrame* temp = _impl_.authentication_message_;
  _impl_.authentication_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::unsafe_arena_release_authentication_message() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.authentication_message)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::location::nearby::connections::AuthenticationMessageFrame* temp = _impl_.authentication_message_;
  _impl_.authentication_message_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::_internal_mutable_authentication_message() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.authentication_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AuthenticationMessageFrame>(GetArenaForAllocation());
    _impl_.authentication_message_ = p;
  }
  return _impl_.authentication_message_;
}
inline ::location::nearby::connections::AuthenticationMessageFrame* V1Frame::mutable_authentication_message() {
  ::location::nearby::connections::AuthenticationMessageFrame* _msg = _internal_mutable_authentication_message();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.authentication_message)
  return _msg;
}
inline void V1Frame::set_allocated_authentication_message(::location::nearby::connections::AuthenticationMessageFrame* authentication_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authentication_message_;
  }
  if (authentication_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authentication_message);
    if (message_arena != submessage_arena) {
      authentication_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authentication_message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.authentication_message_ = authentication_message;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.authentication_message)
}

// optional .location.nearby.connections.AuthenticationResultFrame authentication_result = 10;
inline bool V1Frame::has_authentication_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.authentication_result_ != nullptr);
  return value;
}
inline void V1Frame::clear_authentication_result() {
  if (_impl_.authentication_result_ != nullptr) _impl_.authentication_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::location::nearby::connections::AuthenticationResultFrame& V1Frame::_internal_authentication_result() const {
  const ::location::nearby::connections::AuthenticationResultFrame* p = _impl_.authentication_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AuthenticationResultFrame&>(
      ::location::nearby::connections::_AuthenticationResultFrame_default_instance_);
}
inline const ::location::nearby::connections::AuthenticationResultFrame& V1Frame::authentication_result() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.authentication_result)
  return _internal_authentication_result();
}
inline void V1Frame::unsafe_arena_set_allocated_authentication_result(
    ::location::nearby::connections::AuthenticationResultFrame* authentication_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authentication_result_);
  }
  _impl_.authentication_result_ = authentication_result;
  if (authentication_result) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.authentication_result)
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::release_authentication_result() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::location::nearby::connections::AuthenticationResultFrame* temp = _impl_.authentication_result_;
  _impl_.authentication_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::unsafe_arena_release_authentication_result() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.authentication_result)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::location::nearby::connections::AuthenticationResultFrame* temp = _impl_.authentication_result_;
  _impl_.authentication_result_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::_internal_mutable_authentication_result() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.authentication_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AuthenticationResultFrame>(GetArenaForAllocation());
    _impl_.authentication_result_ = p;
  }
  return _impl_.authentication_result_;
}
inline ::location::nearby::connections::AuthenticationResultFrame* V1Frame::mutable_authentication_result() {
  ::location::nearby::connections::AuthenticationResultFrame* _msg = _internal_mutable_authentication_result();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.authentication_result)
  return _msg;
}
inline void V1Frame::set_allocated_authentication_result(::location::nearby::connections::AuthenticationResultFrame* authentication_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authentication_result_;
  }
  if (authentication_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authentication_result);
    if (message_arena != submessage_arena) {
      authentication_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authentication_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.authentication_result_ = authentication_result;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.authentication_result)
}

// optional .location.nearby.connections.AutoResumeFrame auto_resume = 11;
inline bool V1Frame::has_auto_resume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_resume_ != nullptr);
  return value;
}
inline void V1Frame::clear_auto_resume() {
  if (_impl_.auto_resume_ != nullptr) _impl_.auto_resume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::location::nearby::connections::AutoResumeFrame& V1Frame::_internal_auto_resume() const {
  const ::location::nearby::connections::AutoResumeFrame* p = _impl_.auto_resume_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AutoResumeFrame&>(
      ::location::nearby::connections::_AutoResumeFrame_default_instance_);
}
inline const ::location::nearby::connections::AutoResumeFrame& V1Frame::auto_resume() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.auto_resume)
  return _internal_auto_resume();
}
inline void V1Frame::unsafe_arena_set_allocated_auto_resume(
    ::location::nearby::connections::AutoResumeFrame* auto_resume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_resume_);
  }
  _impl_.auto_resume_ = auto_resume;
  if (auto_resume) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.auto_resume)
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::release_auto_resume() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::location::nearby::connections::AutoResumeFrame* temp = _impl_.auto_resume_;
  _impl_.auto_resume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::unsafe_arena_release_auto_resume() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.auto_resume)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::location::nearby::connections::AutoResumeFrame* temp = _impl_.auto_resume_;
  _impl_.auto_resume_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::_internal_mutable_auto_resume() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.auto_resume_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AutoResumeFrame>(GetArenaForAllocation());
    _impl_.auto_resume_ = p;
  }
  return _impl_.auto_resume_;
}
inline ::location::nearby::connections::AutoResumeFrame* V1Frame::mutable_auto_resume() {
  ::location::nearby::connections::AutoResumeFrame* _msg = _internal_mutable_auto_resume();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.auto_resume)
  return _msg;
}
inline void V1Frame::set_allocated_auto_resume(::location::nearby::connections::AutoResumeFrame* auto_resume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_resume_;
  }
  if (auto_resume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_resume);
    if (message_arena != submessage_arena) {
      auto_resume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_resume, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.auto_resume_ = auto_resume;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.auto_resume)
}

// optional .location.nearby.connections.AutoReconnectFrame auto_reconnect = 12;
inline bool V1Frame::has_auto_reconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auto_reconnect_ != nullptr);
  return value;
}
inline void V1Frame::clear_auto_reconnect() {
  if (_impl_.auto_reconnect_ != nullptr) _impl_.auto_reconnect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::location::nearby::connections::AutoReconnectFrame& V1Frame::_internal_auto_reconnect() const {
  const ::location::nearby::connections::AutoReconnectFrame* p = _impl_.auto_reconnect_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AutoReconnectFrame&>(
      ::location::nearby::connections::_AutoReconnectFrame_default_instance_);
}
inline const ::location::nearby::connections::AutoReconnectFrame& V1Frame::auto_reconnect() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.auto_reconnect)
  return _internal_auto_reconnect();
}
inline void V1Frame::unsafe_arena_set_allocated_auto_reconnect(
    ::location::nearby::connections::AutoReconnectFrame* auto_reconnect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_reconnect_);
  }
  _impl_.auto_reconnect_ = auto_reconnect;
  if (auto_reconnect) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.auto_reconnect)
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::release_auto_reconnect() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::location::nearby::connections::AutoReconnectFrame* temp = _impl_.auto_reconnect_;
  _impl_.auto_reconnect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::unsafe_arena_release_auto_reconnect() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.auto_reconnect)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::location::nearby::connections::AutoReconnectFrame* temp = _impl_.auto_reconnect_;
  _impl_.auto_reconnect_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::_internal_mutable_auto_reconnect() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.auto_reconnect_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AutoReconnectFrame>(GetArenaForAllocation());
    _impl_.auto_reconnect_ = p;
  }
  return _impl_.auto_reconnect_;
}
inline ::location::nearby::connections::AutoReconnectFrame* V1Frame::mutable_auto_reconnect() {
  ::location::nearby::connections::AutoReconnectFrame* _msg = _internal_mutable_auto_reconnect();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.auto_reconnect)
  return _msg;
}
inline void V1Frame::set_allocated_auto_reconnect(::location::nearby::connections::AutoReconnectFrame* auto_reconnect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auto_reconnect_;
  }
  if (auto_reconnect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_reconnect);
    if (message_arena != submessage_arena) {
      auto_reconnect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_reconnect, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.auto_reconnect_ = auto_reconnect;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.auto_reconnect)
}

// optional .location.nearby.connections.BandwidthUpgradeRetryFrame bandwidth_upgrade_retry = 13;
inline bool V1Frame::has_bandwidth_upgrade_retry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bandwidth_upgrade_retry_ != nullptr);
  return value;
}
inline void V1Frame::clear_bandwidth_upgrade_retry() {
  if (_impl_.bandwidth_upgrade_retry_ != nullptr) _impl_.bandwidth_upgrade_retry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::location::nearby::connections::BandwidthUpgradeRetryFrame& V1Frame::_internal_bandwidth_upgrade_retry() const {
  const ::location::nearby::connections::BandwidthUpgradeRetryFrame* p = _impl_.bandwidth_upgrade_retry_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeRetryFrame&>(
      ::location::nearby::connections::_BandwidthUpgradeRetryFrame_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeRetryFrame& V1Frame::bandwidth_upgrade_retry() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.V1Frame.bandwidth_upgrade_retry)
  return _internal_bandwidth_upgrade_retry();
}
inline void V1Frame::unsafe_arena_set_allocated_bandwidth_upgrade_retry(
    ::location::nearby::connections::BandwidthUpgradeRetryFrame* bandwidth_upgrade_retry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bandwidth_upgrade_retry_);
  }
  _impl_.bandwidth_upgrade_retry_ = bandwidth_upgrade_retry;
  if (bandwidth_upgrade_retry) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.V1Frame.bandwidth_upgrade_retry)
}
inline ::location::nearby::connections::BandwidthUpgradeRetryFrame* V1Frame::release_bandwidth_upgrade_retry() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::location::nearby::connections::BandwidthUpgradeRetryFrame* temp = _impl_.bandwidth_upgrade_retry_;
  _impl_.bandwidth_upgrade_retry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeRetryFrame* V1Frame::unsafe_arena_release_bandwidth_upgrade_retry() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.V1Frame.bandwidth_upgrade_retry)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::location::nearby::connections::BandwidthUpgradeRetryFrame* temp = _impl_.bandwidth_upgrade_retry_;
  _impl_.bandwidth_upgrade_retry_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeRetryFrame* V1Frame::_internal_mutable_bandwidth_upgrade_retry() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.bandwidth_upgrade_retry_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeRetryFrame>(GetArenaForAllocation());
    _impl_.bandwidth_upgrade_retry_ = p;
  }
  return _impl_.bandwidth_upgrade_retry_;
}
inline ::location::nearby::connections::BandwidthUpgradeRetryFrame* V1Frame::mutable_bandwidth_upgrade_retry() {
  ::location::nearby::connections::BandwidthUpgradeRetryFrame* _msg = _internal_mutable_bandwidth_upgrade_retry();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.V1Frame.bandwidth_upgrade_retry)
  return _msg;
}
inline void V1Frame::set_allocated_bandwidth_upgrade_retry(::location::nearby::connections::BandwidthUpgradeRetryFrame* bandwidth_upgrade_retry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bandwidth_upgrade_retry_;
  }
  if (bandwidth_upgrade_retry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bandwidth_upgrade_retry);
    if (message_arena != submessage_arena) {
      bandwidth_upgrade_retry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bandwidth_upgrade_retry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.bandwidth_upgrade_retry_ = bandwidth_upgrade_retry;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.V1Frame.bandwidth_upgrade_retry)
}

// -------------------------------------------------------------------

// ConnectionRequestFrame

// optional string endpoint_id = 1;
inline bool ConnectionRequestFrame::has_endpoint_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_endpoint_id() {
  _impl_.endpoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionRequestFrame::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
  return _internal_endpoint_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionRequestFrame::set_endpoint_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.endpoint_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
}
inline std::string* ConnectionRequestFrame::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_endpoint_id() const {
  return _impl_.endpoint_id_.Get();
}
inline void ConnectionRequestFrame::_internal_set_endpoint_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.endpoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_endpoint_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.endpoint_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.endpoint_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionRequestFrame::set_allocated_endpoint_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_id_.IsDefault()) {
          _impl_.endpoint_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.endpoint_id)
}

// optional string endpoint_name = 2;
inline bool ConnectionRequestFrame::has_endpoint_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_endpoint_name() {
  _impl_.endpoint_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectionRequestFrame::endpoint_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
  return _internal_endpoint_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionRequestFrame::set_endpoint_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.endpoint_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
}
inline std::string* ConnectionRequestFrame::mutable_endpoint_name() {
  std::string* _s = _internal_mutable_endpoint_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_endpoint_name() const {
  return _impl_.endpoint_name_.Get();
}
inline void ConnectionRequestFrame::_internal_set_endpoint_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.endpoint_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_endpoint_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.endpoint_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_endpoint_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.endpoint_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionRequestFrame::set_allocated_endpoint_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.endpoint_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_name_.IsDefault()) {
          _impl_.endpoint_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.endpoint_name)
}

// optional bytes handshake_data = 3;
inline bool ConnectionRequestFrame::has_handshake_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_handshake_data() {
  _impl_.handshake_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConnectionRequestFrame::handshake_data() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.handshake_data)
  return _internal_handshake_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionRequestFrame::set_handshake_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.handshake_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.handshake_data)
}
inline std::string* ConnectionRequestFrame::mutable_handshake_data() {
  std::string* _s = _internal_mutable_handshake_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.handshake_data)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_handshake_data() const {
  return _impl_.handshake_data_.Get();
}
inline void ConnectionRequestFrame::_internal_set_handshake_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.handshake_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_handshake_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.handshake_data_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_handshake_data() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.handshake_data)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.handshake_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.handshake_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionRequestFrame::set_allocated_handshake_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.handshake_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.handshake_data_.IsDefault()) {
          _impl_.handshake_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.handshake_data)
}

// optional int32 nonce = 4;
inline bool ConnectionRequestFrame::has_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_nonce() {
  _impl_.nonce_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t ConnectionRequestFrame::nonce() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.nonce)
  return _internal_nonce();
}
inline void ConnectionRequestFrame::set_nonce(::int32_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.nonce)
}
inline ::int32_t ConnectionRequestFrame::_internal_nonce() const {
  return _impl_.nonce_;
}
inline void ConnectionRequestFrame::_internal_set_nonce(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.nonce_ = value;
}

// repeated .location.nearby.connections.ConnectionRequestFrame.Medium mediums = 5;
inline int ConnectionRequestFrame::_internal_mediums_size() const {
  return _impl_.mediums_.size();
}
inline int ConnectionRequestFrame::mediums_size() const {
  return _internal_mediums_size();
}
inline void ConnectionRequestFrame::clear_mediums() {
  _internal_mutable_mediums()->Clear();
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium ConnectionRequestFrame::mediums(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.mediums)
  return _internal_mediums(index);
}
inline void ConnectionRequestFrame::set_mediums(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  _internal_mutable_mediums()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.mediums)
}
inline void ConnectionRequestFrame::add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  _internal_add_mediums(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.ConnectionRequestFrame.mediums)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ConnectionRequestFrame::mediums() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.ConnectionRequestFrame.mediums)
  return _internal_mediums();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ConnectionRequestFrame::mutable_mediums() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.ConnectionRequestFrame.mediums)
  return _internal_mutable_mediums();
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium ConnectionRequestFrame::_internal_mediums(int index) const {
  return static_cast<::location::nearby::connections::ConnectionRequestFrame_Medium>(_internal_mediums().Get(index));
}
inline void ConnectionRequestFrame::_internal_add_mediums(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  _internal_mutable_mediums()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ConnectionRequestFrame::_internal_mediums() const {
  return _impl_.mediums_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ConnectionRequestFrame::_internal_mutable_mediums() {
  return &_impl_.mediums_;
}

// optional bytes endpoint_info = 6;
inline bool ConnectionRequestFrame::has_endpoint_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_endpoint_info() {
  _impl_.endpoint_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConnectionRequestFrame::endpoint_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
  return _internal_endpoint_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionRequestFrame::set_endpoint_info(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endpoint_info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
}
inline std::string* ConnectionRequestFrame::mutable_endpoint_info() {
  std::string* _s = _internal_mutable_endpoint_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_endpoint_info() const {
  return _impl_.endpoint_info_.Get();
}
inline void ConnectionRequestFrame::_internal_set_endpoint_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.endpoint_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_endpoint_info() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.endpoint_info_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_endpoint_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.endpoint_info_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_info_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionRequestFrame::set_allocated_endpoint_info(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.endpoint_info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_info_.IsDefault()) {
          _impl_.endpoint_info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.endpoint_info)
}

// optional .location.nearby.connections.MediumMetadata medium_metadata = 7;
inline bool ConnectionRequestFrame::has_medium_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.medium_metadata_ != nullptr);
  return value;
}
inline void ConnectionRequestFrame::clear_medium_metadata() {
  if (_impl_.medium_metadata_ != nullptr) _impl_.medium_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::MediumMetadata& ConnectionRequestFrame::_internal_medium_metadata() const {
  const ::location::nearby::connections::MediumMetadata* p = _impl_.medium_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::MediumMetadata&>(
      ::location::nearby::connections::_MediumMetadata_default_instance_);
}
inline const ::location::nearby::connections::MediumMetadata& ConnectionRequestFrame::medium_metadata() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
  return _internal_medium_metadata();
}
inline void ConnectionRequestFrame::unsafe_arena_set_allocated_medium_metadata(
    ::location::nearby::connections::MediumMetadata* medium_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.medium_metadata_);
  }
  _impl_.medium_metadata_ = medium_metadata;
  if (medium_metadata) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::release_medium_metadata() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::MediumMetadata* temp = _impl_.medium_metadata_;
  _impl_.medium_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::unsafe_arena_release_medium_metadata() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::MediumMetadata* temp = _impl_.medium_metadata_;
  _impl_.medium_metadata_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::_internal_mutable_medium_metadata() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.medium_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::MediumMetadata>(GetArenaForAllocation());
    _impl_.medium_metadata_ = p;
  }
  return _impl_.medium_metadata_;
}
inline ::location::nearby::connections::MediumMetadata* ConnectionRequestFrame::mutable_medium_metadata() {
  ::location::nearby::connections::MediumMetadata* _msg = _internal_mutable_medium_metadata();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
  return _msg;
}
inline void ConnectionRequestFrame::set_allocated_medium_metadata(::location::nearby::connections::MediumMetadata* medium_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.medium_metadata_;
  }
  if (medium_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(medium_metadata);
    if (message_arena != submessage_arena) {
      medium_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, medium_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.medium_metadata_ = medium_metadata;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.medium_metadata)
}

// optional int32 keep_alive_interval_millis = 8;
inline bool ConnectionRequestFrame::has_keep_alive_interval_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_keep_alive_interval_millis() {
  _impl_.keep_alive_interval_millis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t ConnectionRequestFrame::keep_alive_interval_millis() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.keep_alive_interval_millis)
  return _internal_keep_alive_interval_millis();
}
inline void ConnectionRequestFrame::set_keep_alive_interval_millis(::int32_t value) {
  _internal_set_keep_alive_interval_millis(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.keep_alive_interval_millis)
}
inline ::int32_t ConnectionRequestFrame::_internal_keep_alive_interval_millis() const {
  return _impl_.keep_alive_interval_millis_;
}
inline void ConnectionRequestFrame::_internal_set_keep_alive_interval_millis(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.keep_alive_interval_millis_ = value;
}

// optional int32 keep_alive_timeout_millis = 9;
inline bool ConnectionRequestFrame::has_keep_alive_timeout_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_keep_alive_timeout_millis() {
  _impl_.keep_alive_timeout_millis_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t ConnectionRequestFrame::keep_alive_timeout_millis() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.keep_alive_timeout_millis)
  return _internal_keep_alive_timeout_millis();
}
inline void ConnectionRequestFrame::set_keep_alive_timeout_millis(::int32_t value) {
  _internal_set_keep_alive_timeout_millis(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.keep_alive_timeout_millis)
}
inline ::int32_t ConnectionRequestFrame::_internal_keep_alive_timeout_millis() const {
  return _impl_.keep_alive_timeout_millis_;
}
inline void ConnectionRequestFrame::_internal_set_keep_alive_timeout_millis(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.keep_alive_timeout_millis_ = value;
}

// optional int32 device_type = 10 [default = 0, deprecated = true];
inline bool ConnectionRequestFrame::has_device_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_device_type() {
  _impl_.device_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t ConnectionRequestFrame::device_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.device_type)
  return _internal_device_type();
}
inline void ConnectionRequestFrame::set_device_type(::int32_t value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.device_type)
}
inline ::int32_t ConnectionRequestFrame::_internal_device_type() const {
  return _impl_.device_type_;
}
inline void ConnectionRequestFrame::_internal_set_device_type(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.device_type_ = value;
}

// optional bytes device_info = 11 [deprecated = true];
inline bool ConnectionRequestFrame::has_device_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ConnectionRequestFrame::clear_device_info() {
  _impl_.device_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConnectionRequestFrame::device_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.device_info)
  return _internal_device_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionRequestFrame::set_device_info(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.device_info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionRequestFrame.device_info)
}
inline std::string* ConnectionRequestFrame::mutable_device_info() {
  std::string* _s = _internal_mutable_device_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.device_info)
  return _s;
}
inline const std::string& ConnectionRequestFrame::_internal_device_info() const {
  return _impl_.device_info_.Get();
}
inline void ConnectionRequestFrame::_internal_set_device_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.device_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::_internal_mutable_device_info() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.device_info_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionRequestFrame::release_device_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.device_info)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.device_info_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_info_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionRequestFrame::set_allocated_device_info(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.device_info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_info_.IsDefault()) {
          _impl_.device_info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionRequestFrame.device_info)
}

// .location.nearby.connections.ConnectionsDevice connections_device = 12;
inline bool ConnectionRequestFrame::has_connections_device() const {
  return Device_case() == kConnectionsDevice;
}
inline bool ConnectionRequestFrame::_internal_has_connections_device() const {
  return Device_case() == kConnectionsDevice;
}
inline void ConnectionRequestFrame::set_has_connections_device() {
  _impl_._oneof_case_[0] = kConnectionsDevice;
}
inline void ConnectionRequestFrame::clear_connections_device() {
  if (Device_case() == kConnectionsDevice) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Device_.connections_device_;
    }
    clear_has_Device();
  }
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::release_connections_device() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.connections_device)
  if (Device_case() == kConnectionsDevice) {
    clear_has_Device();
    ::location::nearby::connections::ConnectionsDevice* temp = _impl_.Device_.connections_device_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Device_.connections_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::connections::ConnectionsDevice& ConnectionRequestFrame::_internal_connections_device() const {
  return Device_case() == kConnectionsDevice
      ? *_impl_.Device_.connections_device_
      : reinterpret_cast<::location::nearby::connections::ConnectionsDevice&>(::location::nearby::connections::_ConnectionsDevice_default_instance_);
}
inline const ::location::nearby::connections::ConnectionsDevice& ConnectionRequestFrame::connections_device() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.connections_device)
  return _internal_connections_device();
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::unsafe_arena_release_connections_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.connections.ConnectionRequestFrame.connections_device)
  if (Device_case() == kConnectionsDevice) {
    clear_has_Device();
    ::location::nearby::connections::ConnectionsDevice* temp = _impl_.Device_.connections_device_;
    _impl_.Device_.connections_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionRequestFrame::unsafe_arena_set_allocated_connections_device(::location::nearby::connections::ConnectionsDevice* connections_device) {
  clear_Device();
  if (connections_device) {
    set_has_connections_device();
    _impl_.Device_.connections_device_ = connections_device;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionRequestFrame.connections_device)
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::_internal_mutable_connections_device() {
  if (Device_case() != kConnectionsDevice) {
    clear_Device();
    set_has_connections_device();
    _impl_.Device_.connections_device_ = CreateMaybeMessage< ::location::nearby::connections::ConnectionsDevice >(GetArenaForAllocation());
  }
  return _impl_.Device_.connections_device_;
}
inline ::location::nearby::connections::ConnectionsDevice* ConnectionRequestFrame::mutable_connections_device() {
  ::location::nearby::connections::ConnectionsDevice* _msg = _internal_mutable_connections_device();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.connections_device)
  return _msg;
}

// .location.nearby.connections.PresenceDevice presence_device = 13;
inline bool ConnectionRequestFrame::has_presence_device() const {
  return Device_case() == kPresenceDevice;
}
inline bool ConnectionRequestFrame::_internal_has_presence_device() const {
  return Device_case() == kPresenceDevice;
}
inline void ConnectionRequestFrame::set_has_presence_device() {
  _impl_._oneof_case_[0] = kPresenceDevice;
}
inline void ConnectionRequestFrame::clear_presence_device() {
  if (Device_case() == kPresenceDevice) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Device_.presence_device_;
    }
    clear_has_Device();
  }
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::release_presence_device() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionRequestFrame.presence_device)
  if (Device_case() == kPresenceDevice) {
    clear_has_Device();
    ::location::nearby::connections::PresenceDevice* temp = _impl_.Device_.presence_device_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Device_.presence_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::location::nearby::connections::PresenceDevice& ConnectionRequestFrame::_internal_presence_device() const {
  return Device_case() == kPresenceDevice
      ? *_impl_.Device_.presence_device_
      : reinterpret_cast<::location::nearby::connections::PresenceDevice&>(::location::nearby::connections::_PresenceDevice_default_instance_);
}
inline const ::location::nearby::connections::PresenceDevice& ConnectionRequestFrame::presence_device() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionRequestFrame.presence_device)
  return _internal_presence_device();
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::unsafe_arena_release_presence_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:location.nearby.connections.ConnectionRequestFrame.presence_device)
  if (Device_case() == kPresenceDevice) {
    clear_has_Device();
    ::location::nearby::connections::PresenceDevice* temp = _impl_.Device_.presence_device_;
    _impl_.Device_.presence_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectionRequestFrame::unsafe_arena_set_allocated_presence_device(::location::nearby::connections::PresenceDevice* presence_device) {
  clear_Device();
  if (presence_device) {
    set_has_presence_device();
    _impl_.Device_.presence_device_ = presence_device;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionRequestFrame.presence_device)
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::_internal_mutable_presence_device() {
  if (Device_case() != kPresenceDevice) {
    clear_Device();
    set_has_presence_device();
    _impl_.Device_.presence_device_ = CreateMaybeMessage< ::location::nearby::connections::PresenceDevice >(GetArenaForAllocation());
  }
  return _impl_.Device_.presence_device_;
}
inline ::location::nearby::connections::PresenceDevice* ConnectionRequestFrame::mutable_presence_device() {
  ::location::nearby::connections::PresenceDevice* _msg = _internal_mutable_presence_device();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionRequestFrame.presence_device)
  return _msg;
}

inline bool ConnectionRequestFrame::has_Device() const {
  return Device_case() != DEVICE_NOT_SET;
}
inline void ConnectionRequestFrame::clear_has_Device() {
  _impl_._oneof_case_[0] = DEVICE_NOT_SET;
}
inline ConnectionRequestFrame::DeviceCase ConnectionRequestFrame::Device_case() const {
  return ConnectionRequestFrame::DeviceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConnectionResponseFrame

// optional int32 status = 1 [deprecated = true];
inline bool ConnectionResponseFrame::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ConnectionResponseFrame::status() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.status)
  return _internal_status();
}
inline void ConnectionResponseFrame::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.status)
}
inline ::int32_t ConnectionResponseFrame::_internal_status() const {
  return _impl_.status_;
}
inline void ConnectionResponseFrame::_internal_set_status(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}

// optional bytes handshake_data = 2;
inline bool ConnectionResponseFrame::has_handshake_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_handshake_data() {
  _impl_.handshake_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionResponseFrame::handshake_data() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.handshake_data)
  return _internal_handshake_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionResponseFrame::set_handshake_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handshake_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.handshake_data)
}
inline std::string* ConnectionResponseFrame::mutable_handshake_data() {
  std::string* _s = _internal_mutable_handshake_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionResponseFrame.handshake_data)
  return _s;
}
inline const std::string& ConnectionResponseFrame::_internal_handshake_data() const {
  return _impl_.handshake_data_.Get();
}
inline void ConnectionResponseFrame::_internal_set_handshake_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.handshake_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionResponseFrame::_internal_mutable_handshake_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handshake_data_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionResponseFrame::release_handshake_data() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionResponseFrame.handshake_data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.handshake_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.handshake_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionResponseFrame::set_allocated_handshake_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handshake_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.handshake_data_.IsDefault()) {
          _impl_.handshake_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionResponseFrame.handshake_data)
}

// optional .location.nearby.connections.ConnectionResponseFrame.ResponseStatus response = 3;
inline bool ConnectionResponseFrame::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::response() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.response)
  return _internal_response();
}
inline void ConnectionResponseFrame::set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value) {
   _internal_set_response(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.response)
}
inline ::location::nearby::connections::ConnectionResponseFrame_ResponseStatus ConnectionResponseFrame::_internal_response() const {
  return static_cast<::location::nearby::connections::ConnectionResponseFrame_ResponseStatus>(_impl_.response_);
}
inline void ConnectionResponseFrame::_internal_set_response(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus value) {
  assert(::location::nearby::connections::ConnectionResponseFrame_ResponseStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.response_ = value;
}

// optional .location.nearby.connections.OsInfo os_info = 4;
inline bool ConnectionResponseFrame::has_os_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.os_info_ != nullptr);
  return value;
}
inline void ConnectionResponseFrame::clear_os_info() {
  if (_impl_.os_info_ != nullptr) _impl_.os_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::OsInfo& ConnectionResponseFrame::_internal_os_info() const {
  const ::location::nearby::connections::OsInfo* p = _impl_.os_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::OsInfo&>(
      ::location::nearby::connections::_OsInfo_default_instance_);
}
inline const ::location::nearby::connections::OsInfo& ConnectionResponseFrame::os_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.os_info)
  return _internal_os_info();
}
inline void ConnectionResponseFrame::unsafe_arena_set_allocated_os_info(
    ::location::nearby::connections::OsInfo* os_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.os_info_);
  }
  _impl_.os_info_ = os_info;
  if (os_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.ConnectionResponseFrame.os_info)
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::release_os_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::OsInfo* temp = _impl_.os_info_;
  _impl_.os_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::unsafe_arena_release_os_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionResponseFrame.os_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::OsInfo* temp = _impl_.os_info_;
  _impl_.os_info_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::_internal_mutable_os_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.os_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::OsInfo>(GetArenaForAllocation());
    _impl_.os_info_ = p;
  }
  return _impl_.os_info_;
}
inline ::location::nearby::connections::OsInfo* ConnectionResponseFrame::mutable_os_info() {
  ::location::nearby::connections::OsInfo* _msg = _internal_mutable_os_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionResponseFrame.os_info)
  return _msg;
}
inline void ConnectionResponseFrame::set_allocated_os_info(::location::nearby::connections::OsInfo* os_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.os_info_;
  }
  if (os_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(os_info);
    if (message_arena != submessage_arena) {
      os_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, os_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.os_info_ = os_info;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionResponseFrame.os_info)
}

// optional int32 multiplex_socket_bitmask = 5;
inline bool ConnectionResponseFrame::has_multiplex_socket_bitmask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_multiplex_socket_bitmask() {
  _impl_.multiplex_socket_bitmask_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t ConnectionResponseFrame::multiplex_socket_bitmask() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.multiplex_socket_bitmask)
  return _internal_multiplex_socket_bitmask();
}
inline void ConnectionResponseFrame::set_multiplex_socket_bitmask(::int32_t value) {
  _internal_set_multiplex_socket_bitmask(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.multiplex_socket_bitmask)
}
inline ::int32_t ConnectionResponseFrame::_internal_multiplex_socket_bitmask() const {
  return _impl_.multiplex_socket_bitmask_;
}
inline void ConnectionResponseFrame::_internal_set_multiplex_socket_bitmask(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.multiplex_socket_bitmask_ = value;
}

// optional int32 nearby_connections_version = 6 [deprecated = true];
inline bool ConnectionResponseFrame::has_nearby_connections_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_nearby_connections_version() {
  _impl_.nearby_connections_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t ConnectionResponseFrame::nearby_connections_version() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.nearby_connections_version)
  return _internal_nearby_connections_version();
}
inline void ConnectionResponseFrame::set_nearby_connections_version(::int32_t value) {
  _internal_set_nearby_connections_version(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.nearby_connections_version)
}
inline ::int32_t ConnectionResponseFrame::_internal_nearby_connections_version() const {
  return _impl_.nearby_connections_version_;
}
inline void ConnectionResponseFrame::_internal_set_nearby_connections_version(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.nearby_connections_version_ = value;
}

// optional int32 safe_to_disconnect_version = 7;
inline bool ConnectionResponseFrame::has_safe_to_disconnect_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_safe_to_disconnect_version() {
  _impl_.safe_to_disconnect_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t ConnectionResponseFrame::safe_to_disconnect_version() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionResponseFrame.safe_to_disconnect_version)
  return _internal_safe_to_disconnect_version();
}
inline void ConnectionResponseFrame::set_safe_to_disconnect_version(::int32_t value) {
  _internal_set_safe_to_disconnect_version(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionResponseFrame.safe_to_disconnect_version)
}
inline ::int32_t ConnectionResponseFrame::_internal_safe_to_disconnect_version() const {
  return _impl_.safe_to_disconnect_version_;
}
inline void ConnectionResponseFrame::_internal_set_safe_to_disconnect_version(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.safe_to_disconnect_version_ = value;
}

// -------------------------------------------------------------------

// PayloadTransferFrame_PayloadHeader

// optional int64 id = 1;
inline bool PayloadTransferFrame_PayloadHeader::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadHeader::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t PayloadTransferFrame_PayloadHeader::id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.id)
  return _internal_id();
}
inline void PayloadTransferFrame_PayloadHeader::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.id)
}
inline ::int64_t PayloadTransferFrame_PayloadHeader::_internal_id() const {
  return _impl_.id_;
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}

// optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader.PayloadType type = 2;
inline bool PayloadTransferFrame_PayloadHeader::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadHeader::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.type)
  return _internal_type();
}
inline void PayloadTransferFrame_PayloadHeader::set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.type)
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType PayloadTransferFrame_PayloadHeader::_internal_type() const {
  return static_cast<::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType>(_impl_.type_);
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_type(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType value) {
  assert(::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}

// optional int64 total_size = 3;
inline bool PayloadTransferFrame_PayloadHeader::has_total_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadHeader::clear_total_size() {
  _impl_.total_size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t PayloadTransferFrame_PayloadHeader::total_size() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.total_size)
  return _internal_total_size();
}
inline void PayloadTransferFrame_PayloadHeader::set_total_size(::int64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.total_size)
}
inline ::int64_t PayloadTransferFrame_PayloadHeader::_internal_total_size() const {
  return _impl_.total_size_;
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_total_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.total_size_ = value;
}

// optional bool is_sensitive = 4;
inline bool PayloadTransferFrame_PayloadHeader::has_is_sensitive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadHeader::clear_is_sensitive() {
  _impl_.is_sensitive_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool PayloadTransferFrame_PayloadHeader::is_sensitive() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.is_sensitive)
  return _internal_is_sensitive();
}
inline void PayloadTransferFrame_PayloadHeader::set_is_sensitive(bool value) {
  _internal_set_is_sensitive(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.is_sensitive)
}
inline bool PayloadTransferFrame_PayloadHeader::_internal_is_sensitive() const {
  return _impl_.is_sensitive_;
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_is_sensitive(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_sensitive_ = value;
}

// optional string file_name = 5;
inline bool PayloadTransferFrame_PayloadHeader::has_file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadHeader::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::file_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PayloadTransferFrame_PayloadHeader::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
}
inline std::string* PayloadTransferFrame_PayloadHeader::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
  return _s;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::_internal_mutable_file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.file_name_.Mutable( GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::release_file_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.file_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PayloadTransferFrame_PayloadHeader::set_allocated_file_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.file_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_name_.IsDefault()) {
          _impl_.file_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.PayloadHeader.file_name)
}

// optional string parent_folder = 6;
inline bool PayloadTransferFrame_PayloadHeader::has_parent_folder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadHeader::clear_parent_folder() {
  _impl_.parent_folder_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::parent_folder() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
  return _internal_parent_folder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PayloadTransferFrame_PayloadHeader::set_parent_folder(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_folder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
}
inline std::string* PayloadTransferFrame_PayloadHeader::mutable_parent_folder() {
  std::string* _s = _internal_mutable_parent_folder();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
  return _s;
}
inline const std::string& PayloadTransferFrame_PayloadHeader::_internal_parent_folder() const {
  return _impl_.parent_folder_.Get();
}
inline void PayloadTransferFrame_PayloadHeader::_internal_set_parent_folder(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.parent_folder_.Set(value, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::_internal_mutable_parent_folder() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.parent_folder_.Mutable( GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadHeader::release_parent_folder() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.parent_folder_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_folder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PayloadTransferFrame_PayloadHeader::set_allocated_parent_folder(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parent_folder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_folder_.IsDefault()) {
          _impl_.parent_folder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.PayloadHeader.parent_folder)
}

// -------------------------------------------------------------------

// PayloadTransferFrame_PayloadChunk

// optional int32 flags = 1;
inline bool PayloadTransferFrame_PayloadChunk::has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadChunk::clear_flags() {
  _impl_.flags_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t PayloadTransferFrame_PayloadChunk::flags() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.flags)
  return _internal_flags();
}
inline void PayloadTransferFrame_PayloadChunk::set_flags(::int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.flags)
}
inline ::int32_t PayloadTransferFrame_PayloadChunk::_internal_flags() const {
  return _impl_.flags_;
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_flags(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}

// optional int64 offset = 2;
inline bool PayloadTransferFrame_PayloadChunk::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadChunk::clear_offset() {
  _impl_.offset_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t PayloadTransferFrame_PayloadChunk::offset() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.offset)
  return _internal_offset();
}
inline void PayloadTransferFrame_PayloadChunk::set_offset(::int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.offset)
}
inline ::int64_t PayloadTransferFrame_PayloadChunk::_internal_offset() const {
  return _impl_.offset_;
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_offset(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}

// optional bytes body = 3;
inline bool PayloadTransferFrame_PayloadChunk::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadChunk::clear_body() {
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PayloadTransferFrame_PayloadChunk::body() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PayloadTransferFrame_PayloadChunk::set_body(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
}
inline std::string* PayloadTransferFrame_PayloadChunk::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
  return _s;
}
inline const std::string& PayloadTransferFrame_PayloadChunk::_internal_body() const {
  return _impl_.body_.Get();
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_body(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadChunk::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.body_.Mutable( GetArenaForAllocation());
}
inline std::string* PayloadTransferFrame_PayloadChunk::release_body() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.body_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PayloadTransferFrame_PayloadChunk::set_allocated_body(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.body_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_.IsDefault()) {
          _impl_.body_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.PayloadChunk.body)
}

// optional int32 index = 4;
inline bool PayloadTransferFrame_PayloadChunk::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PayloadTransferFrame_PayloadChunk::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t PayloadTransferFrame_PayloadChunk::index() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.PayloadChunk.index)
  return _internal_index();
}
inline void PayloadTransferFrame_PayloadChunk::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.PayloadChunk.index)
}
inline ::int32_t PayloadTransferFrame_PayloadChunk::_internal_index() const {
  return _impl_.index_;
}
inline void PayloadTransferFrame_PayloadChunk::_internal_set_index(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// PayloadTransferFrame_ControlMessage

// optional .location.nearby.connections.PayloadTransferFrame.ControlMessage.EventType event = 1;
inline bool PayloadTransferFrame_ControlMessage::has_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PayloadTransferFrame_ControlMessage::clear_event() {
  _impl_.event_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::event() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.ControlMessage.event)
  return _internal_event();
}
inline void PayloadTransferFrame_ControlMessage::set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value) {
   _internal_set_event(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.ControlMessage.event)
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType PayloadTransferFrame_ControlMessage::_internal_event() const {
  return static_cast<::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType>(_impl_.event_);
}
inline void PayloadTransferFrame_ControlMessage::_internal_set_event(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType value) {
  assert(::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_ = value;
}

// optional int64 offset = 2;
inline bool PayloadTransferFrame_ControlMessage::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PayloadTransferFrame_ControlMessage::clear_offset() {
  _impl_.offset_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t PayloadTransferFrame_ControlMessage::offset() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.ControlMessage.offset)
  return _internal_offset();
}
inline void PayloadTransferFrame_ControlMessage::set_offset(::int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.ControlMessage.offset)
}
inline ::int64_t PayloadTransferFrame_ControlMessage::_internal_offset() const {
  return _impl_.offset_;
}
inline void PayloadTransferFrame_ControlMessage::_internal_set_offset(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// PayloadTransferFrame

// optional .location.nearby.connections.PayloadTransferFrame.PacketType packet_type = 1;
inline bool PayloadTransferFrame::has_packet_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PayloadTransferFrame::clear_packet_type() {
  _impl_.packet_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::PayloadTransferFrame_PacketType PayloadTransferFrame::packet_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.packet_type)
  return _internal_packet_type();
}
inline void PayloadTransferFrame::set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value) {
   _internal_set_packet_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PayloadTransferFrame.packet_type)
}
inline ::location::nearby::connections::PayloadTransferFrame_PacketType PayloadTransferFrame::_internal_packet_type() const {
  return static_cast<::location::nearby::connections::PayloadTransferFrame_PacketType>(_impl_.packet_type_);
}
inline void PayloadTransferFrame::_internal_set_packet_type(::location::nearby::connections::PayloadTransferFrame_PacketType value) {
  assert(::location::nearby::connections::PayloadTransferFrame_PacketType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.packet_type_ = value;
}

// optional .location.nearby.connections.PayloadTransferFrame.PayloadHeader payload_header = 2;
inline bool PayloadTransferFrame::has_payload_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_header_ != nullptr);
  return value;
}
inline void PayloadTransferFrame::clear_payload_header() {
  if (_impl_.payload_header_ != nullptr) _impl_.payload_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& PayloadTransferFrame::_internal_payload_header() const {
  const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* p = _impl_.payload_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader&>(
      ::location::nearby::connections::_PayloadTransferFrame_PayloadHeader_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadHeader& PayloadTransferFrame::payload_header() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.payload_header)
  return _internal_payload_header();
}
inline void PayloadTransferFrame::unsafe_arena_set_allocated_payload_header(
    ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_header_);
  }
  _impl_.payload_header_ = payload_header;
  if (payload_header) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_header)
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::release_payload_header() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* temp = _impl_.payload_header_;
  _impl_.payload_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::unsafe_arena_release_payload_header() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.payload_header)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* temp = _impl_.payload_header_;
  _impl_.payload_header_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::_internal_mutable_payload_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.payload_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadHeader>(GetArenaForAllocation());
    _impl_.payload_header_ = p;
  }
  return _impl_.payload_header_;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* PayloadTransferFrame::mutable_payload_header() {
  ::location::nearby::connections::PayloadTransferFrame_PayloadHeader* _msg = _internal_mutable_payload_header();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.payload_header)
  return _msg;
}
inline void PayloadTransferFrame::set_allocated_payload_header(::location::nearby::connections::PayloadTransferFrame_PayloadHeader* payload_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_header_;
  }
  if (payload_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_header);
    if (message_arena != submessage_arena) {
      payload_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_header_ = payload_header;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_header)
}

// optional .location.nearby.connections.PayloadTransferFrame.PayloadChunk payload_chunk = 3;
inline bool PayloadTransferFrame::has_payload_chunk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_chunk_ != nullptr);
  return value;
}
inline void PayloadTransferFrame::clear_payload_chunk() {
  if (_impl_.payload_chunk_ != nullptr) _impl_.payload_chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& PayloadTransferFrame::_internal_payload_chunk() const {
  const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* p = _impl_.payload_chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk&>(
      ::location::nearby::connections::_PayloadTransferFrame_PayloadChunk_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame_PayloadChunk& PayloadTransferFrame::payload_chunk() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.payload_chunk)
  return _internal_payload_chunk();
}
inline void PayloadTransferFrame::unsafe_arena_set_allocated_payload_chunk(
    ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_chunk_);
  }
  _impl_.payload_chunk_ = payload_chunk;
  if (payload_chunk) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_chunk)
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::release_payload_chunk() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* temp = _impl_.payload_chunk_;
  _impl_.payload_chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::unsafe_arena_release_payload_chunk() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.payload_chunk)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* temp = _impl_.payload_chunk_;
  _impl_.payload_chunk_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::_internal_mutable_payload_chunk() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.payload_chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_PayloadChunk>(GetArenaForAllocation());
    _impl_.payload_chunk_ = p;
  }
  return _impl_.payload_chunk_;
}
inline ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* PayloadTransferFrame::mutable_payload_chunk() {
  ::location::nearby::connections::PayloadTransferFrame_PayloadChunk* _msg = _internal_mutable_payload_chunk();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.payload_chunk)
  return _msg;
}
inline void PayloadTransferFrame::set_allocated_payload_chunk(::location::nearby::connections::PayloadTransferFrame_PayloadChunk* payload_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_chunk_;
  }
  if (payload_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_chunk);
    if (message_arena != submessage_arena) {
      payload_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_chunk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.payload_chunk_ = payload_chunk;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.payload_chunk)
}

// optional .location.nearby.connections.PayloadTransferFrame.ControlMessage control_message = 4;
inline bool PayloadTransferFrame::has_control_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_message_ != nullptr);
  return value;
}
inline void PayloadTransferFrame::clear_control_message() {
  if (_impl_.control_message_ != nullptr) _impl_.control_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& PayloadTransferFrame::_internal_control_message() const {
  const ::location::nearby::connections::PayloadTransferFrame_ControlMessage* p = _impl_.control_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::PayloadTransferFrame_ControlMessage&>(
      ::location::nearby::connections::_PayloadTransferFrame_ControlMessage_default_instance_);
}
inline const ::location::nearby::connections::PayloadTransferFrame_ControlMessage& PayloadTransferFrame::control_message() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PayloadTransferFrame.control_message)
  return _internal_control_message();
}
inline void PayloadTransferFrame::unsafe_arena_set_allocated_control_message(
    ::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_message_);
  }
  _impl_.control_message_ = control_message;
  if (control_message) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.PayloadTransferFrame.control_message)
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::release_control_message() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* temp = _impl_.control_message_;
  _impl_.control_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::unsafe_arena_release_control_message() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PayloadTransferFrame.control_message)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* temp = _impl_.control_message_;
  _impl_.control_message_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::_internal_mutable_control_message() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.control_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::PayloadTransferFrame_ControlMessage>(GetArenaForAllocation());
    _impl_.control_message_ = p;
  }
  return _impl_.control_message_;
}
inline ::location::nearby::connections::PayloadTransferFrame_ControlMessage* PayloadTransferFrame::mutable_control_message() {
  ::location::nearby::connections::PayloadTransferFrame_ControlMessage* _msg = _internal_mutable_control_message();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PayloadTransferFrame.control_message)
  return _msg;
}
inline void PayloadTransferFrame::set_allocated_control_message(::location::nearby::connections::PayloadTransferFrame_ControlMessage* control_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_message_;
  }
  if (control_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control_message);
    if (message_arena != submessage_arena) {
      control_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.control_message_ = control_message;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PayloadTransferFrame.control_message)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials

// optional string ssid = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_ssid() {
  _impl_.ssid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::ssid() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
  return _internal_ssid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_ssid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ssid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_ssid() const {
  return _impl_.ssid_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_ssid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.ssid_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_mutable_ssid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ssid_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::release_ssid() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ssid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_allocated_ssid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ssid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ssid_.IsDefault()) {
          _impl_.ssid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.ssid)
}

// optional string password = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::password() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_password(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_password() const {
  return _impl_.password_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::release_password() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_allocated_password(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.password)
}

// optional int32 port = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_port() {
  _impl_.port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::port() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.port)
  return _internal_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.port)
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_port() const {
  return _impl_.port_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_port(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.port_ = value;
}

// optional string gateway = 4 [default = "0.0.0.0"];
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_gateway() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_gateway() {
  _impl_.gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::gateway() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
  if (_impl_.gateway_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_gateway_.get();
  }
  return _internal_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_gateway(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_gateway(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_mutable_gateway() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.gateway_.Mutable(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::release_gateway() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  return _impl_.gateway_.Release();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_allocated_gateway(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gateway_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.gateway)
}

// optional int32 frequency = 5 [default = -1];
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::has_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::clear_frequency() {
  _impl_.frequency_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::frequency() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.frequency)
  return _internal_frequency();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::set_frequency(::int32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials.frequency)
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_frequency() const {
  return _impl_.frequency_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials::_internal_set_frequency(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.frequency_ = value;
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket

// optional bytes ip_address = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::ip_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_set_ip_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_mutable_ip_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_address_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::release_ip_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ip_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::set_allocated_ip_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.ip_address)
}

// optional int32 wifi_port = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::has_wifi_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::clear_wifi_port() {
  _impl_.wifi_port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::wifi_port() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.wifi_port)
  return _internal_wifi_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::set_wifi_port(::int32_t value) {
  _internal_set_wifi_port(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket.wifi_port)
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_wifi_port() const {
  return _impl_.wifi_port_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket::_internal_set_wifi_port(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wifi_port_ = value;
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials

// optional string service_name = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::has_service_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::service_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
  return _internal_service_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_service_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.service_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_set_service_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_mutable_service_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.service_name_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::release_service_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.service_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_allocated_service_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.service_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_name_.IsDefault()) {
          _impl_.service_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.service_name)
}

// optional string mac_address = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::has_mac_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::clear_mac_address() {
  _impl_.mac_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::mac_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
  return _internal_mac_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_mac_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mac_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_mac_address() const {
  return _impl_.mac_address_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_set_mac_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::_internal_mutable_mac_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mac_address_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::release_mac_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.mac_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials::set_allocated_mac_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mac_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mac_address_.IsDefault()) {
          _impl_.mac_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials.mac_address)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials

// optional string service_id = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::has_service_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::clear_service_id() {
  _impl_.service_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::service_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
  return _internal_service_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_service_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.service_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::mutable_service_id() {
  std::string* _s = _internal_mutable_service_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_service_id() const {
  return _impl_.service_id_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_set_service_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.service_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_mutable_service_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.service_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::release_service_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.service_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_allocated_service_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.service_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_id_.IsDefault()) {
          _impl_.service_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_id)
}

// optional bytes service_info = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::has_service_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::clear_service_info() {
  _impl_.service_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::service_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
  return _internal_service_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_service_info(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.service_info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::mutable_service_info() {
  std::string* _s = _internal_mutable_service_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_service_info() const {
  return _impl_.service_info_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_set_service_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.service_info_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_mutable_service_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.service_info_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::release_service_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.service_info_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.service_info_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_allocated_service_info(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.service_info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_info_.IsDefault()) {
          _impl_.service_info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.service_info)
}

// optional string password = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::password() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_password(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_password() const {
  return _impl_.password_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::release_password() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.password_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials::set_allocated_password(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials.password)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials

// optional string ssid = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_ssid() {
  _impl_.ssid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ssid() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
  return _internal_ssid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_ssid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ssid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_ssid() const {
  return _impl_.ssid_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_ssid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.ssid_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_ssid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ssid_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_ssid() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ssid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_ssid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ssid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ssid_.IsDefault()) {
          _impl_.ssid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ssid)
}

// optional string password = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::password() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_password(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_password() const {
  return _impl_.password_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_password() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_password(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.password)
}

// optional int32 port = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_port() {
  _impl_.port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::port() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.port)
  return _internal_port();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.port)
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_port() const {
  return _impl_.port_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_port(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.port_ = value;
}

// optional int32 frequency = 4;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_frequency() {
  _impl_.frequency_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::frequency() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.frequency)
  return _internal_frequency();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_frequency(::int32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.frequency)
}
inline ::int32_t BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_frequency() const {
  return _impl_.frequency_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_frequency(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.frequency_ = value;
}

// optional string gateway = 5 [default = "0.0.0.0"];
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_gateway() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_gateway() {
  _impl_.gateway_.ClearToDefault(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::gateway() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
  if (_impl_.gateway_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_gateway_.get();
  }
  return _internal_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_gateway(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_gateway(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_gateway() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.gateway_.Mutable(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::Impl_::_i_give_permission_to_break_this_code_default_gateway_, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_gateway() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  return _impl_.gateway_.Release();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_gateway(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gateway_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.gateway)
}

// optional bytes ip_v6_address = 6;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::has_ip_v6_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::clear_ip_v6_address() {
  _impl_.ip_v6_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::ip_v6_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
  return _internal_ip_v6_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_ip_v6_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ip_v6_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::mutable_ip_v6_address() {
  std::string* _s = _internal_mutable_ip_v6_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_ip_v6_address() const {
  return _impl_.ip_v6_address_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_set_ip_v6_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.ip_v6_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::_internal_mutable_ip_v6_address() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.ip_v6_address_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::release_ip_v6_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.ip_v6_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_v6_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials::set_allocated_ip_v6_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ip_v6_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_v6_address_.IsDefault()) {
          _impl_.ip_v6_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials.ip_v6_address)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials

// optional string peer_id = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::has_peer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::clear_peer_id() {
  _impl_.peer_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::peer_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
  return _internal_peer_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::set_peer_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.peer_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::mutable_peer_id() {
  std::string* _s = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_peer_id() const {
  return _impl_.peer_id_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_set_peer_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.peer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_mutable_peer_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.peer_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::release_peer_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.peer_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.peer_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::set_allocated_peer_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.peer_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.peer_id_.IsDefault()) {
          _impl_.peer_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.peer_id)
}

// optional .location.nearby.connections.LocationHint location_hint = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::has_location_hint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_hint_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::clear_location_hint() {
  if (_impl_.location_hint_ != nullptr) _impl_.location_hint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::LocationHint& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_location_hint() const {
  const ::location::nearby::connections::LocationHint* p = _impl_.location_hint_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::LocationHint&>(
      ::location::nearby::connections::_LocationHint_default_instance_);
}
inline const ::location::nearby::connections::LocationHint& BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::location_hint() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
  return _internal_location_hint();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::unsafe_arena_set_allocated_location_hint(
    ::location::nearby::connections::LocationHint* location_hint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_hint_);
  }
  _impl_.location_hint_ = location_hint;
  if (location_hint) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::release_location_hint() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::LocationHint* temp = _impl_.location_hint_;
  _impl_.location_hint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::unsafe_arena_release_location_hint() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::LocationHint* temp = _impl_.location_hint_;
  _impl_.location_hint_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::_internal_mutable_location_hint() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.location_hint_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::LocationHint>(GetArenaForAllocation());
    _impl_.location_hint_ = p;
  }
  return _impl_.location_hint_;
}
inline ::location::nearby::connections::LocationHint* BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::mutable_location_hint() {
  ::location::nearby::connections::LocationHint* _msg = _internal_mutable_location_hint();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials::set_allocated_location_hint(::location::nearby::connections::LocationHint* location_hint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_hint_;
  }
  if (location_hint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location_hint);
    if (message_arena != submessage_arena) {
      location_hint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location_hint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.location_hint_ = location_hint;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials.location_hint)
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_UpgradePathInfo

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.Medium medium = 1;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_medium() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_medium() {
  _impl_.medium_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::medium() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.medium)
  return _internal_medium();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
   _internal_set_medium(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.medium)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_medium() const {
  return static_cast<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium>(_impl_.medium_);
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_set_medium(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium value) {
  assert(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.medium_ = value;
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiHotspotCredentials wifi_hotspot_credentials = 2;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_hotspot_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_hotspot_credentials_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_hotspot_credentials() {
  if (_impl_.wifi_hotspot_credentials_ != nullptr) _impl_.wifi_hotspot_credentials_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_hotspot_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* p = _impl_.wifi_hotspot_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_hotspot_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
  return _internal_wifi_hotspot_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_hotspot_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_hotspot_credentials_);
  }
  _impl_.wifi_hotspot_credentials_ = wifi_hotspot_credentials;
  if (wifi_hotspot_credentials) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_hotspot_credentials() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* temp = _impl_.wifi_hotspot_credentials_;
  _impl_.wifi_hotspot_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_hotspot_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* temp = _impl_.wifi_hotspot_credentials_;
  _impl_.wifi_hotspot_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_hotspot_credentials() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.wifi_hotspot_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials>(GetArenaForAllocation());
    _impl_.wifi_hotspot_credentials_ = p;
  }
  return _impl_.wifi_hotspot_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_hotspot_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* _msg = _internal_mutable_wifi_hotspot_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_hotspot_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiHotspotCredentials* wifi_hotspot_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_hotspot_credentials_;
  }
  if (wifi_hotspot_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_hotspot_credentials);
    if (message_arena != submessage_arena) {
      wifi_hotspot_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_hotspot_credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.wifi_hotspot_credentials_ = wifi_hotspot_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_hotspot_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiLanSocket wifi_lan_socket = 3;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_lan_socket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_lan_socket_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_lan_socket() {
  if (_impl_.wifi_lan_socket_ != nullptr) _impl_.wifi_lan_socket_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_lan_socket() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* p = _impl_.wifi_lan_socket_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_lan_socket() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
  return _internal_wifi_lan_socket();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_lan_socket(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_lan_socket_);
  }
  _impl_.wifi_lan_socket_ = wifi_lan_socket;
  if (wifi_lan_socket) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_lan_socket() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* temp = _impl_.wifi_lan_socket_;
  _impl_.wifi_lan_socket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_lan_socket() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* temp = _impl_.wifi_lan_socket_;
  _impl_.wifi_lan_socket_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_lan_socket() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.wifi_lan_socket_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket>(GetArenaForAllocation());
    _impl_.wifi_lan_socket_ = p;
  }
  return _impl_.wifi_lan_socket_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_lan_socket() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* _msg = _internal_mutable_wifi_lan_socket();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_lan_socket(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiLanSocket* wifi_lan_socket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_lan_socket_;
  }
  if (wifi_lan_socket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_lan_socket);
    if (message_arena != submessage_arena) {
      wifi_lan_socket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_lan_socket, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wifi_lan_socket_ = wifi_lan_socket;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_lan_socket)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.BluetoothCredentials bluetooth_credentials = 4;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_bluetooth_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bluetooth_credentials_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_bluetooth_credentials() {
  if (_impl_.bluetooth_credentials_ != nullptr) _impl_.bluetooth_credentials_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_bluetooth_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* p = _impl_.bluetooth_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::bluetooth_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
  return _internal_bluetooth_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_bluetooth_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bluetooth_credentials_);
  }
  _impl_.bluetooth_credentials_ = bluetooth_credentials;
  if (bluetooth_credentials) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_bluetooth_credentials() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* temp = _impl_.bluetooth_credentials_;
  _impl_.bluetooth_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_bluetooth_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* temp = _impl_.bluetooth_credentials_;
  _impl_.bluetooth_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_bluetooth_credentials() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.bluetooth_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials>(GetArenaForAllocation());
    _impl_.bluetooth_credentials_ = p;
  }
  return _impl_.bluetooth_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_bluetooth_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* _msg = _internal_mutable_bluetooth_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_bluetooth_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_BluetoothCredentials* bluetooth_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bluetooth_credentials_;
  }
  if (bluetooth_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bluetooth_credentials);
    if (message_arena != submessage_arena) {
      bluetooth_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bluetooth_credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.bluetooth_credentials_ = bluetooth_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.bluetooth_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiAwareCredentials wifi_aware_credentials = 5;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_aware_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_aware_credentials_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_aware_credentials() {
  if (_impl_.wifi_aware_credentials_ != nullptr) _impl_.wifi_aware_credentials_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_aware_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* p = _impl_.wifi_aware_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_aware_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
  return _internal_wifi_aware_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_aware_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_aware_credentials_);
  }
  _impl_.wifi_aware_credentials_ = wifi_aware_credentials;
  if (wifi_aware_credentials) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_aware_credentials() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* temp = _impl_.wifi_aware_credentials_;
  _impl_.wifi_aware_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_aware_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* temp = _impl_.wifi_aware_credentials_;
  _impl_.wifi_aware_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_aware_credentials() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.wifi_aware_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials>(GetArenaForAllocation());
    _impl_.wifi_aware_credentials_ = p;
  }
  return _impl_.wifi_aware_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_aware_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* _msg = _internal_mutable_wifi_aware_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_aware_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiAwareCredentials* wifi_aware_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_aware_credentials_;
  }
  if (wifi_aware_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_aware_credentials);
    if (message_arena != submessage_arena) {
      wifi_aware_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_aware_credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.wifi_aware_credentials_ = wifi_aware_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_aware_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WifiDirectCredentials wifi_direct_credentials = 6;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_wifi_direct_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_direct_credentials_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_wifi_direct_credentials() {
  if (_impl_.wifi_direct_credentials_ != nullptr) _impl_.wifi_direct_credentials_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_wifi_direct_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* p = _impl_.wifi_direct_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::wifi_direct_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
  return _internal_wifi_direct_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_wifi_direct_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_direct_credentials_);
  }
  _impl_.wifi_direct_credentials_ = wifi_direct_credentials;
  if (wifi_direct_credentials) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_wifi_direct_credentials() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* temp = _impl_.wifi_direct_credentials_;
  _impl_.wifi_direct_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_wifi_direct_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* temp = _impl_.wifi_direct_credentials_;
  _impl_.wifi_direct_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_wifi_direct_credentials() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.wifi_direct_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials>(GetArenaForAllocation());
    _impl_.wifi_direct_credentials_ = p;
  }
  return _impl_.wifi_direct_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_wifi_direct_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* _msg = _internal_mutable_wifi_direct_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_wifi_direct_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WifiDirectCredentials* wifi_direct_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_direct_credentials_;
  }
  if (wifi_direct_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_direct_credentials);
    if (message_arena != submessage_arena) {
      wifi_direct_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_direct_credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.wifi_direct_credentials_ = wifi_direct_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.wifi_direct_credentials)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.WebRtcCredentials web_rtc_credentials = 8;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_web_rtc_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.web_rtc_credentials_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_web_rtc_credentials() {
  if (_impl_.web_rtc_credentials_ != nullptr) _impl_.web_rtc_credentials_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_web_rtc_credentials() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* p = _impl_.web_rtc_credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials& BandwidthUpgradeNegotiationFrame_UpgradePathInfo::web_rtc_credentials() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
  return _internal_web_rtc_credentials();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_set_allocated_web_rtc_credentials(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_rtc_credentials_);
  }
  _impl_.web_rtc_credentials_ = web_rtc_credentials;
  if (web_rtc_credentials) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::release_web_rtc_credentials() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* temp = _impl_.web_rtc_credentials_;
  _impl_.web_rtc_credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::unsafe_arena_release_web_rtc_credentials() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* temp = _impl_.web_rtc_credentials_;
  _impl_.web_rtc_credentials_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_mutable_web_rtc_credentials() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.web_rtc_credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials>(GetArenaForAllocation());
    _impl_.web_rtc_credentials_ = p;
  }
  return _impl_.web_rtc_credentials_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* BandwidthUpgradeNegotiationFrame_UpgradePathInfo::mutable_web_rtc_credentials() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* _msg = _internal_mutable_web_rtc_credentials();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_allocated_web_rtc_credentials(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_WebRtcCredentials* web_rtc_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.web_rtc_credentials_;
  }
  if (web_rtc_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(web_rtc_credentials);
    if (message_arena != submessage_arena) {
      web_rtc_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_rtc_credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.web_rtc_credentials_ = web_rtc_credentials;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.web_rtc_credentials)
}

// optional bool supports_disabling_encryption = 7;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_supports_disabling_encryption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_supports_disabling_encryption() {
  _impl_.supports_disabling_encryption_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::supports_disabling_encryption() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_disabling_encryption)
  return _internal_supports_disabling_encryption();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_supports_disabling_encryption(bool value) {
  _internal_set_supports_disabling_encryption(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_disabling_encryption)
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_supports_disabling_encryption() const {
  return _impl_.supports_disabling_encryption_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_set_supports_disabling_encryption(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.supports_disabling_encryption_ = value;
}

// optional bool supports_client_introduction_ack = 9;
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::has_supports_client_introduction_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::clear_supports_client_introduction_ack() {
  _impl_.supports_client_introduction_ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::supports_client_introduction_ack() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_client_introduction_ack)
  return _internal_supports_client_introduction_ack();
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::set_supports_client_introduction_ack(bool value) {
  _internal_set_supports_client_introduction_ack(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo.supports_client_introduction_ack)
}
inline bool BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_supports_client_introduction_ack() const {
  return _impl_.supports_client_introduction_ack_;
}
inline void BandwidthUpgradeNegotiationFrame_UpgradePathInfo::_internal_set_supports_client_introduction_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.supports_client_introduction_ack_ = value;
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_ClientIntroduction

// optional string endpoint_id = 1;
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::has_endpoint_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::clear_endpoint_id() {
  _impl_.endpoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_ClientIntroduction::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
  return _internal_endpoint_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BandwidthUpgradeNegotiationFrame_ClientIntroduction::set_endpoint_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.endpoint_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
}
inline std::string* BandwidthUpgradeNegotiationFrame_ClientIntroduction::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
  return _s;
}
inline const std::string& BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_endpoint_id() const {
  return _impl_.endpoint_id_.Get();
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_set_endpoint_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.endpoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_mutable_endpoint_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.endpoint_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BandwidthUpgradeNegotiationFrame_ClientIntroduction::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.endpoint_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::set_allocated_endpoint_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_id_.IsDefault()) {
          _impl_.endpoint_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.endpoint_id)
}

// optional bool supports_disabling_encryption = 2;
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::has_supports_disabling_encryption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::clear_supports_disabling_encryption() {
  _impl_.supports_disabling_encryption_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::supports_disabling_encryption() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.supports_disabling_encryption)
  return _internal_supports_disabling_encryption();
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::set_supports_disabling_encryption(bool value) {
  _internal_set_supports_disabling_encryption(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction.supports_disabling_encryption)
}
inline bool BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_supports_disabling_encryption() const {
  return _impl_.supports_disabling_encryption_;
}
inline void BandwidthUpgradeNegotiationFrame_ClientIntroduction::_internal_set_supports_disabling_encryption(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.supports_disabling_encryption_ = value;
}

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame_ClientIntroductionAck

// -------------------------------------------------------------------

// BandwidthUpgradeNegotiationFrame

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.EventType event_type = 1;
inline bool BandwidthUpgradeNegotiationFrame::has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BandwidthUpgradeNegotiationFrame::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::event_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.event_type)
  return _internal_event_type();
}
inline void BandwidthUpgradeNegotiationFrame::set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value) {
   _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeNegotiationFrame.event_type)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType BandwidthUpgradeNegotiationFrame::_internal_event_type() const {
  return static_cast<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType>(_impl_.event_type_);
}
inline void BandwidthUpgradeNegotiationFrame::_internal_set_event_type(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType value) {
  assert(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_type_ = value;
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.UpgradePathInfo upgrade_path_info = 2;
inline bool BandwidthUpgradeNegotiationFrame::has_upgrade_path_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upgrade_path_info_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame::clear_upgrade_path_info() {
  if (_impl_.upgrade_path_info_ != nullptr) _impl_.upgrade_path_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& BandwidthUpgradeNegotiationFrame::_internal_upgrade_path_info() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* p = _impl_.upgrade_path_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_UpgradePathInfo_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo& BandwidthUpgradeNegotiationFrame::upgrade_path_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
  return _internal_upgrade_path_info();
}
inline void BandwidthUpgradeNegotiationFrame::unsafe_arena_set_allocated_upgrade_path_info(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upgrade_path_info_);
  }
  _impl_.upgrade_path_info_ = upgrade_path_info;
  if (upgrade_path_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::release_upgrade_path_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* temp = _impl_.upgrade_path_info_;
  _impl_.upgrade_path_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::unsafe_arena_release_upgrade_path_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* temp = _impl_.upgrade_path_info_;
  _impl_.upgrade_path_info_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::_internal_mutable_upgrade_path_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.upgrade_path_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo>(GetArenaForAllocation());
    _impl_.upgrade_path_info_ = p;
  }
  return _impl_.upgrade_path_info_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* BandwidthUpgradeNegotiationFrame::mutable_upgrade_path_info() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* _msg = _internal_mutable_upgrade_path_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame::set_allocated_upgrade_path_info(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo* upgrade_path_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upgrade_path_info_;
  }
  if (upgrade_path_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upgrade_path_info);
    if (message_arena != submessage_arena) {
      upgrade_path_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upgrade_path_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.upgrade_path_info_ = upgrade_path_info;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.upgrade_path_info)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroduction client_introduction = 3;
inline bool BandwidthUpgradeNegotiationFrame::has_client_introduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_introduction_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame::clear_client_introduction() {
  if (_impl_.client_introduction_ != nullptr) _impl_.client_introduction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& BandwidthUpgradeNegotiationFrame::_internal_client_introduction() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* p = _impl_.client_introduction_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_ClientIntroduction_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction& BandwidthUpgradeNegotiationFrame::client_introduction() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
  return _internal_client_introduction();
}
inline void BandwidthUpgradeNegotiationFrame::unsafe_arena_set_allocated_client_introduction(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_introduction_);
  }
  _impl_.client_introduction_ = client_introduction;
  if (client_introduction) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::release_client_introduction() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* temp = _impl_.client_introduction_;
  _impl_.client_introduction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::unsafe_arena_release_client_introduction() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* temp = _impl_.client_introduction_;
  _impl_.client_introduction_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::_internal_mutable_client_introduction() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.client_introduction_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction>(GetArenaForAllocation());
    _impl_.client_introduction_ = p;
  }
  return _impl_.client_introduction_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* BandwidthUpgradeNegotiationFrame::mutable_client_introduction() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* _msg = _internal_mutable_client_introduction();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame::set_allocated_client_introduction(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroduction* client_introduction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_introduction_;
  }
  if (client_introduction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_introduction);
    if (message_arena != submessage_arena) {
      client_introduction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_introduction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.client_introduction_ = client_introduction;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction)
}

// optional .location.nearby.connections.BandwidthUpgradeNegotiationFrame.ClientIntroductionAck client_introduction_ack = 4;
inline bool BandwidthUpgradeNegotiationFrame::has_client_introduction_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_introduction_ack_ != nullptr);
  return value;
}
inline void BandwidthUpgradeNegotiationFrame::clear_client_introduction_ack() {
  if (_impl_.client_introduction_ack_ != nullptr) _impl_.client_introduction_ack_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& BandwidthUpgradeNegotiationFrame::_internal_client_introduction_ack() const {
  const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* p = _impl_.client_introduction_ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck&>(
      ::location::nearby::connections::_BandwidthUpgradeNegotiationFrame_ClientIntroductionAck_default_instance_);
}
inline const ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck& BandwidthUpgradeNegotiationFrame::client_introduction_ack() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
  return _internal_client_introduction_ack();
}
inline void BandwidthUpgradeNegotiationFrame::unsafe_arena_set_allocated_client_introduction_ack(
    ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_introduction_ack_);
  }
  _impl_.client_introduction_ack_ = client_introduction_ack;
  if (client_introduction_ack) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::release_client_introduction_ack() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* temp = _impl_.client_introduction_ack_;
  _impl_.client_introduction_ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::unsafe_arena_release_client_introduction_ack() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* temp = _impl_.client_introduction_ack_;
  _impl_.client_introduction_ack_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::_internal_mutable_client_introduction_ack() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.client_introduction_ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck>(GetArenaForAllocation());
    _impl_.client_introduction_ack_ = p;
  }
  return _impl_.client_introduction_ack_;
}
inline ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* BandwidthUpgradeNegotiationFrame::mutable_client_introduction_ack() {
  ::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* _msg = _internal_mutable_client_introduction_ack();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
  return _msg;
}
inline void BandwidthUpgradeNegotiationFrame::set_allocated_client_introduction_ack(::location::nearby::connections::BandwidthUpgradeNegotiationFrame_ClientIntroductionAck* client_introduction_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_introduction_ack_;
  }
  if (client_introduction_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_introduction_ack);
    if (message_arena != submessage_arena) {
      client_introduction_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_introduction_ack, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.client_introduction_ack_ = client_introduction_ack;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.BandwidthUpgradeNegotiationFrame.client_introduction_ack)
}

// -------------------------------------------------------------------

// BandwidthUpgradeRetryFrame

// repeated .location.nearby.connections.BandwidthUpgradeRetryFrame.Medium supported_medium = 1;
inline int BandwidthUpgradeRetryFrame::_internal_supported_medium_size() const {
  return _impl_.supported_medium_.size();
}
inline int BandwidthUpgradeRetryFrame::supported_medium_size() const {
  return _internal_supported_medium_size();
}
inline void BandwidthUpgradeRetryFrame::clear_supported_medium() {
  _internal_mutable_supported_medium()->Clear();
}
inline ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::supported_medium(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeRetryFrame.supported_medium)
  return _internal_supported_medium(index);
}
inline void BandwidthUpgradeRetryFrame::set_supported_medium(int index, ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium value) {
  assert(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium_IsValid(value));
  _internal_mutable_supported_medium()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeRetryFrame.supported_medium)
}
inline void BandwidthUpgradeRetryFrame::add_supported_medium(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium value) {
  _internal_add_supported_medium(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.BandwidthUpgradeRetryFrame.supported_medium)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& BandwidthUpgradeRetryFrame::supported_medium() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.BandwidthUpgradeRetryFrame.supported_medium)
  return _internal_supported_medium();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* BandwidthUpgradeRetryFrame::mutable_supported_medium() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.BandwidthUpgradeRetryFrame.supported_medium)
  return _internal_mutable_supported_medium();
}
inline ::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium BandwidthUpgradeRetryFrame::_internal_supported_medium(int index) const {
  return static_cast<::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium>(_internal_supported_medium().Get(index));
}
inline void BandwidthUpgradeRetryFrame::_internal_add_supported_medium(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium value) {
  assert(::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium_IsValid(value));
  _internal_mutable_supported_medium()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& BandwidthUpgradeRetryFrame::_internal_supported_medium() const {
  return _impl_.supported_medium_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* BandwidthUpgradeRetryFrame::_internal_mutable_supported_medium() {
  return &_impl_.supported_medium_;
}

// optional bool is_request = 2;
inline bool BandwidthUpgradeRetryFrame::has_is_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BandwidthUpgradeRetryFrame::clear_is_request() {
  _impl_.is_request_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BandwidthUpgradeRetryFrame::is_request() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.BandwidthUpgradeRetryFrame.is_request)
  return _internal_is_request();
}
inline void BandwidthUpgradeRetryFrame::set_is_request(bool value) {
  _internal_set_is_request(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.BandwidthUpgradeRetryFrame.is_request)
}
inline bool BandwidthUpgradeRetryFrame::_internal_is_request() const {
  return _impl_.is_request_;
}
inline void BandwidthUpgradeRetryFrame::_internal_set_is_request(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.is_request_ = value;
}

// -------------------------------------------------------------------

// KeepAliveFrame

// optional bool ack = 1;
inline bool KeepAliveFrame::has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KeepAliveFrame::clear_ack() {
  _impl_.ack_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool KeepAliveFrame::ack() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.KeepAliveFrame.ack)
  return _internal_ack();
}
inline void KeepAliveFrame::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.KeepAliveFrame.ack)
}
inline bool KeepAliveFrame::_internal_ack() const {
  return _impl_.ack_;
}
inline void KeepAliveFrame::_internal_set_ack(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ack_ = value;
}

// optional uint32 seq_num = 2;
inline bool KeepAliveFrame::has_seq_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KeepAliveFrame::clear_seq_num() {
  _impl_.seq_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t KeepAliveFrame::seq_num() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.KeepAliveFrame.seq_num)
  return _internal_seq_num();
}
inline void KeepAliveFrame::set_seq_num(::uint32_t value) {
  _internal_set_seq_num(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.KeepAliveFrame.seq_num)
}
inline ::uint32_t KeepAliveFrame::_internal_seq_num() const {
  return _impl_.seq_num_;
}
inline void KeepAliveFrame::_internal_set_seq_num(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seq_num_ = value;
}

// -------------------------------------------------------------------

// DisconnectionFrame

// optional bool request_safe_to_disconnect = 1;
inline bool DisconnectionFrame::has_request_safe_to_disconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DisconnectionFrame::clear_request_safe_to_disconnect() {
  _impl_.request_safe_to_disconnect_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool DisconnectionFrame::request_safe_to_disconnect() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.DisconnectionFrame.request_safe_to_disconnect)
  return _internal_request_safe_to_disconnect();
}
inline void DisconnectionFrame::set_request_safe_to_disconnect(bool value) {
  _internal_set_request_safe_to_disconnect(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.DisconnectionFrame.request_safe_to_disconnect)
}
inline bool DisconnectionFrame::_internal_request_safe_to_disconnect() const {
  return _impl_.request_safe_to_disconnect_;
}
inline void DisconnectionFrame::_internal_set_request_safe_to_disconnect(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_safe_to_disconnect_ = value;
}

// optional bool ack_safe_to_disconnect = 2;
inline bool DisconnectionFrame::has_ack_safe_to_disconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DisconnectionFrame::clear_ack_safe_to_disconnect() {
  _impl_.ack_safe_to_disconnect_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DisconnectionFrame::ack_safe_to_disconnect() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.DisconnectionFrame.ack_safe_to_disconnect)
  return _internal_ack_safe_to_disconnect();
}
inline void DisconnectionFrame::set_ack_safe_to_disconnect(bool value) {
  _internal_set_ack_safe_to_disconnect(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.DisconnectionFrame.ack_safe_to_disconnect)
}
inline bool DisconnectionFrame::_internal_ack_safe_to_disconnect() const {
  return _impl_.ack_safe_to_disconnect_;
}
inline void DisconnectionFrame::_internal_set_ack_safe_to_disconnect(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ack_safe_to_disconnect_ = value;
}

// -------------------------------------------------------------------

// PairedKeyEncryptionFrame

// optional bytes signed_data = 1;
inline bool PairedKeyEncryptionFrame::has_signed_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PairedKeyEncryptionFrame::clear_signed_data() {
  _impl_.signed_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PairedKeyEncryptionFrame::signed_data() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
  return _internal_signed_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PairedKeyEncryptionFrame::set_signed_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signed_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
}
inline std::string* PairedKeyEncryptionFrame::mutable_signed_data() {
  std::string* _s = _internal_mutable_signed_data();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
  return _s;
}
inline const std::string& PairedKeyEncryptionFrame::_internal_signed_data() const {
  return _impl_.signed_data_.Get();
}
inline void PairedKeyEncryptionFrame::_internal_set_signed_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.signed_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::_internal_mutable_signed_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signed_data_.Mutable( GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::release_signed_data() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.signed_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PairedKeyEncryptionFrame::set_allocated_signed_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signed_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signed_data_.IsDefault()) {
          _impl_.signed_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PairedKeyEncryptionFrame.signed_data)
}

// -------------------------------------------------------------------

// AuthenticationMessageFrame

// optional bytes auth_message = 1;
inline bool AuthenticationMessageFrame::has_auth_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AuthenticationMessageFrame::clear_auth_message() {
  _impl_.auth_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthenticationMessageFrame::auth_message() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AuthenticationMessageFrame.auth_message)
  return _internal_auth_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthenticationMessageFrame::set_auth_message(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_message_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.AuthenticationMessageFrame.auth_message)
}
inline std::string* AuthenticationMessageFrame::mutable_auth_message() {
  std::string* _s = _internal_mutable_auth_message();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.AuthenticationMessageFrame.auth_message)
  return _s;
}
inline const std::string& AuthenticationMessageFrame::_internal_auth_message() const {
  return _impl_.auth_message_.Get();
}
inline void AuthenticationMessageFrame::_internal_set_auth_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.auth_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticationMessageFrame::_internal_mutable_auth_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_message_.Mutable( GetArenaForAllocation());
}
inline std::string* AuthenticationMessageFrame::release_auth_message() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.AuthenticationMessageFrame.auth_message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.auth_message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AuthenticationMessageFrame::set_allocated_auth_message(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.auth_message_.IsDefault()) {
          _impl_.auth_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.AuthenticationMessageFrame.auth_message)
}

// -------------------------------------------------------------------

// AuthenticationResultFrame

// optional int32 result = 1;
inline bool AuthenticationResultFrame::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AuthenticationResultFrame::clear_result() {
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AuthenticationResultFrame::result() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AuthenticationResultFrame.result)
  return _internal_result();
}
inline void AuthenticationResultFrame::set_result(::int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AuthenticationResultFrame.result)
}
inline ::int32_t AuthenticationResultFrame::_internal_result() const {
  return _impl_.result_;
}
inline void AuthenticationResultFrame::_internal_set_result(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// AutoResumeFrame

// optional .location.nearby.connections.AutoResumeFrame.EventType event_type = 1;
inline bool AutoResumeFrame::has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AutoResumeFrame::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::AutoResumeFrame_EventType AutoResumeFrame::event_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoResumeFrame.event_type)
  return _internal_event_type();
}
inline void AutoResumeFrame::set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value) {
   _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoResumeFrame.event_type)
}
inline ::location::nearby::connections::AutoResumeFrame_EventType AutoResumeFrame::_internal_event_type() const {
  return static_cast<::location::nearby::connections::AutoResumeFrame_EventType>(_impl_.event_type_);
}
inline void AutoResumeFrame::_internal_set_event_type(::location::nearby::connections::AutoResumeFrame_EventType value) {
  assert(::location::nearby::connections::AutoResumeFrame_EventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_type_ = value;
}

// optional int64 pending_payload_id = 2;
inline bool AutoResumeFrame::has_pending_payload_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AutoResumeFrame::clear_pending_payload_id() {
  _impl_.pending_payload_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t AutoResumeFrame::pending_payload_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoResumeFrame.pending_payload_id)
  return _internal_pending_payload_id();
}
inline void AutoResumeFrame::set_pending_payload_id(::int64_t value) {
  _internal_set_pending_payload_id(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoResumeFrame.pending_payload_id)
}
inline ::int64_t AutoResumeFrame::_internal_pending_payload_id() const {
  return _impl_.pending_payload_id_;
}
inline void AutoResumeFrame::_internal_set_pending_payload_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pending_payload_id_ = value;
}

// optional int32 next_payload_chunk_index = 3;
inline bool AutoResumeFrame::has_next_payload_chunk_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AutoResumeFrame::clear_next_payload_chunk_index() {
  _impl_.next_payload_chunk_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AutoResumeFrame::next_payload_chunk_index() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoResumeFrame.next_payload_chunk_index)
  return _internal_next_payload_chunk_index();
}
inline void AutoResumeFrame::set_next_payload_chunk_index(::int32_t value) {
  _internal_set_next_payload_chunk_index(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoResumeFrame.next_payload_chunk_index)
}
inline ::int32_t AutoResumeFrame::_internal_next_payload_chunk_index() const {
  return _impl_.next_payload_chunk_index_;
}
inline void AutoResumeFrame::_internal_set_next_payload_chunk_index(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.next_payload_chunk_index_ = value;
}

// -------------------------------------------------------------------

// AutoReconnectFrame

// optional string endpoint_id = 1;
inline bool AutoReconnectFrame::has_endpoint_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AutoReconnectFrame::clear_endpoint_id() {
  _impl_.endpoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutoReconnectFrame::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoReconnectFrame.endpoint_id)
  return _internal_endpoint_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AutoReconnectFrame::set_endpoint_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.endpoint_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoReconnectFrame.endpoint_id)
}
inline std::string* AutoReconnectFrame::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.AutoReconnectFrame.endpoint_id)
  return _s;
}
inline const std::string& AutoReconnectFrame::_internal_endpoint_id() const {
  return _impl_.endpoint_id_.Get();
}
inline void AutoReconnectFrame::_internal_set_endpoint_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.endpoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoReconnectFrame::_internal_mutable_endpoint_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.endpoint_id_.Mutable( GetArenaForAllocation());
}
inline std::string* AutoReconnectFrame::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.AutoReconnectFrame.endpoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.endpoint_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AutoReconnectFrame::set_allocated_endpoint_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_id_.IsDefault()) {
          _impl_.endpoint_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.AutoReconnectFrame.endpoint_id)
}

// optional .location.nearby.connections.AutoReconnectFrame.EventType event_type = 2;
inline bool AutoReconnectFrame::has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AutoReconnectFrame::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::AutoReconnectFrame_EventType AutoReconnectFrame::event_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AutoReconnectFrame.event_type)
  return _internal_event_type();
}
inline void AutoReconnectFrame::set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value) {
   _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AutoReconnectFrame.event_type)
}
inline ::location::nearby::connections::AutoReconnectFrame_EventType AutoReconnectFrame::_internal_event_type() const {
  return static_cast<::location::nearby::connections::AutoReconnectFrame_EventType>(_impl_.event_type_);
}
inline void AutoReconnectFrame::_internal_set_event_type(::location::nearby::connections::AutoReconnectFrame_EventType value) {
  assert(::location::nearby::connections::AutoReconnectFrame_EventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_type_ = value;
}

// -------------------------------------------------------------------

// MediumMetadata

// optional bool supports_5_ghz = 1;
inline bool MediumMetadata::has_supports_5_ghz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MediumMetadata::clear_supports_5_ghz() {
  _impl_.supports_5_ghz_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool MediumMetadata::supports_5_ghz() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.supports_5_ghz)
  return _internal_supports_5_ghz();
}
inline void MediumMetadata::set_supports_5_ghz(bool value) {
  _internal_set_supports_5_ghz(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.supports_5_ghz)
}
inline bool MediumMetadata::_internal_supports_5_ghz() const {
  return _impl_.supports_5_ghz_;
}
inline void MediumMetadata::_internal_set_supports_5_ghz(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.supports_5_ghz_ = value;
}

// optional string bssid = 2;
inline bool MediumMetadata::has_bssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MediumMetadata::clear_bssid() {
  _impl_.bssid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MediumMetadata::bssid() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.bssid)
  return _internal_bssid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediumMetadata::set_bssid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bssid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.bssid)
}
inline std::string* MediumMetadata::mutable_bssid() {
  std::string* _s = _internal_mutable_bssid();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.bssid)
  return _s;
}
inline const std::string& MediumMetadata::_internal_bssid() const {
  return _impl_.bssid_.Get();
}
inline void MediumMetadata::_internal_set_bssid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.bssid_.Set(value, GetArenaForAllocation());
}
inline std::string* MediumMetadata::_internal_mutable_bssid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.bssid_.Mutable( GetArenaForAllocation());
}
inline std::string* MediumMetadata::release_bssid() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.bssid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.bssid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bssid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediumMetadata::set_allocated_bssid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bssid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bssid_.IsDefault()) {
          _impl_.bssid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.bssid)
}

// optional bytes ip_address = 3;
inline bool MediumMetadata::has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MediumMetadata::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MediumMetadata::ip_address() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MediumMetadata::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_address_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.ip_address)
}
inline std::string* MediumMetadata::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.ip_address)
  return _s;
}
inline const std::string& MediumMetadata::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void MediumMetadata::_internal_set_ip_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MediumMetadata::_internal_mutable_ip_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ip_address_.Mutable( GetArenaForAllocation());
}
inline std::string* MediumMetadata::release_ip_address() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.ip_address)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.ip_address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MediumMetadata::set_allocated_ip_address(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ip_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.ip_address)
}

// optional bool supports_6_ghz = 4;
inline bool MediumMetadata::has_supports_6_ghz() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MediumMetadata::clear_supports_6_ghz() {
  _impl_.supports_6_ghz_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool MediumMetadata::supports_6_ghz() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.supports_6_ghz)
  return _internal_supports_6_ghz();
}
inline void MediumMetadata::set_supports_6_ghz(bool value) {
  _internal_set_supports_6_ghz(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.supports_6_ghz)
}
inline bool MediumMetadata::_internal_supports_6_ghz() const {
  return _impl_.supports_6_ghz_;
}
inline void MediumMetadata::_internal_set_supports_6_ghz(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.supports_6_ghz_ = value;
}

// optional bool mobile_radio = 5;
inline bool MediumMetadata::has_mobile_radio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MediumMetadata::clear_mobile_radio() {
  _impl_.mobile_radio_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool MediumMetadata::mobile_radio() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.mobile_radio)
  return _internal_mobile_radio();
}
inline void MediumMetadata::set_mobile_radio(bool value) {
  _internal_set_mobile_radio(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.mobile_radio)
}
inline bool MediumMetadata::_internal_mobile_radio() const {
  return _impl_.mobile_radio_;
}
inline void MediumMetadata::_internal_set_mobile_radio(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.mobile_radio_ = value;
}

// optional int32 ap_frequency = 6 [default = -1];
inline bool MediumMetadata::has_ap_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void MediumMetadata::clear_ap_frequency() {
  _impl_.ap_frequency_ = -1;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t MediumMetadata::ap_frequency() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.ap_frequency)
  return _internal_ap_frequency();
}
inline void MediumMetadata::set_ap_frequency(::int32_t value) {
  _internal_set_ap_frequency(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.MediumMetadata.ap_frequency)
}
inline ::int32_t MediumMetadata::_internal_ap_frequency() const {
  return _impl_.ap_frequency_;
}
inline void MediumMetadata::_internal_set_ap_frequency(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.ap_frequency_ = value;
}

// optional .location.nearby.connections.AvailableChannels available_channels = 7;
inline bool MediumMetadata::has_available_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.available_channels_ != nullptr);
  return value;
}
inline void MediumMetadata::clear_available_channels() {
  if (_impl_.available_channels_ != nullptr) _impl_.available_channels_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::location::nearby::connections::AvailableChannels& MediumMetadata::_internal_available_channels() const {
  const ::location::nearby::connections::AvailableChannels* p = _impl_.available_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::AvailableChannels&>(
      ::location::nearby::connections::_AvailableChannels_default_instance_);
}
inline const ::location::nearby::connections::AvailableChannels& MediumMetadata::available_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.available_channels)
  return _internal_available_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_available_channels(
    ::location::nearby::connections::AvailableChannels* available_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.available_channels_);
  }
  _impl_.available_channels_ = available_channels;
  if (available_channels) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.available_channels)
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::release_available_channels() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::AvailableChannels* temp = _impl_.available_channels_;
  _impl_.available_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::unsafe_arena_release_available_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.available_channels)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::location::nearby::connections::AvailableChannels* temp = _impl_.available_channels_;
  _impl_.available_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::_internal_mutable_available_channels() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.available_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::AvailableChannels>(GetArenaForAllocation());
    _impl_.available_channels_ = p;
  }
  return _impl_.available_channels_;
}
inline ::location::nearby::connections::AvailableChannels* MediumMetadata::mutable_available_channels() {
  ::location::nearby::connections::AvailableChannels* _msg = _internal_mutable_available_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.available_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_available_channels(::location::nearby::connections::AvailableChannels* available_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.available_channels_;
  }
  if (available_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(available_channels);
    if (message_arena != submessage_arena) {
      available_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, available_channels, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.available_channels_ = available_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.available_channels)
}

// optional .location.nearby.connections.WifiDirectCliUsableChannels wifi_direct_cli_usable_channels = 8;
inline bool MediumMetadata::has_wifi_direct_cli_usable_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_direct_cli_usable_channels_ != nullptr);
  return value;
}
inline void MediumMetadata::clear_wifi_direct_cli_usable_channels() {
  if (_impl_.wifi_direct_cli_usable_channels_ != nullptr) _impl_.wifi_direct_cli_usable_channels_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::location::nearby::connections::WifiDirectCliUsableChannels& MediumMetadata::_internal_wifi_direct_cli_usable_channels() const {
  const ::location::nearby::connections::WifiDirectCliUsableChannels* p = _impl_.wifi_direct_cli_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiDirectCliUsableChannels&>(
      ::location::nearby::connections::_WifiDirectCliUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiDirectCliUsableChannels& MediumMetadata::wifi_direct_cli_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
  return _internal_wifi_direct_cli_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_direct_cli_usable_channels(
    ::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_direct_cli_usable_channels_);
  }
  _impl_.wifi_direct_cli_usable_channels_ = wifi_direct_cli_usable_channels;
  if (wifi_direct_cli_usable_channels) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::release_wifi_direct_cli_usable_channels() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::WifiDirectCliUsableChannels* temp = _impl_.wifi_direct_cli_usable_channels_;
  _impl_.wifi_direct_cli_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::unsafe_arena_release_wifi_direct_cli_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::location::nearby::connections::WifiDirectCliUsableChannels* temp = _impl_.wifi_direct_cli_usable_channels_;
  _impl_.wifi_direct_cli_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::_internal_mutable_wifi_direct_cli_usable_channels() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.wifi_direct_cli_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiDirectCliUsableChannels>(GetArenaForAllocation());
    _impl_.wifi_direct_cli_usable_channels_ = p;
  }
  return _impl_.wifi_direct_cli_usable_channels_;
}
inline ::location::nearby::connections::WifiDirectCliUsableChannels* MediumMetadata::mutable_wifi_direct_cli_usable_channels() {
  ::location::nearby::connections::WifiDirectCliUsableChannels* _msg = _internal_mutable_wifi_direct_cli_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_direct_cli_usable_channels(::location::nearby::connections::WifiDirectCliUsableChannels* wifi_direct_cli_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_direct_cli_usable_channels_;
  }
  if (wifi_direct_cli_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_direct_cli_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_direct_cli_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_direct_cli_usable_channels, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.wifi_direct_cli_usable_channels_ = wifi_direct_cli_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_direct_cli_usable_channels)
}

// optional .location.nearby.connections.WifiLanUsableChannels wifi_lan_usable_channels = 9;
inline bool MediumMetadata::has_wifi_lan_usable_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_lan_usable_channels_ != nullptr);
  return value;
}
inline void MediumMetadata::clear_wifi_lan_usable_channels() {
  if (_impl_.wifi_lan_usable_channels_ != nullptr) _impl_.wifi_lan_usable_channels_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::location::nearby::connections::WifiLanUsableChannels& MediumMetadata::_internal_wifi_lan_usable_channels() const {
  const ::location::nearby::connections::WifiLanUsableChannels* p = _impl_.wifi_lan_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiLanUsableChannels&>(
      ::location::nearby::connections::_WifiLanUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiLanUsableChannels& MediumMetadata::wifi_lan_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
  return _internal_wifi_lan_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_lan_usable_channels(
    ::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_lan_usable_channels_);
  }
  _impl_.wifi_lan_usable_channels_ = wifi_lan_usable_channels;
  if (wifi_lan_usable_channels) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::release_wifi_lan_usable_channels() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::WifiLanUsableChannels* temp = _impl_.wifi_lan_usable_channels_;
  _impl_.wifi_lan_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::unsafe_arena_release_wifi_lan_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::location::nearby::connections::WifiLanUsableChannels* temp = _impl_.wifi_lan_usable_channels_;
  _impl_.wifi_lan_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::_internal_mutable_wifi_lan_usable_channels() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.wifi_lan_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiLanUsableChannels>(GetArenaForAllocation());
    _impl_.wifi_lan_usable_channels_ = p;
  }
  return _impl_.wifi_lan_usable_channels_;
}
inline ::location::nearby::connections::WifiLanUsableChannels* MediumMetadata::mutable_wifi_lan_usable_channels() {
  ::location::nearby::connections::WifiLanUsableChannels* _msg = _internal_mutable_wifi_lan_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_lan_usable_channels(::location::nearby::connections::WifiLanUsableChannels* wifi_lan_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_lan_usable_channels_;
  }
  if (wifi_lan_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_lan_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_lan_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_lan_usable_channels, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.wifi_lan_usable_channels_ = wifi_lan_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_lan_usable_channels)
}

// optional .location.nearby.connections.WifiAwareUsableChannels wifi_aware_usable_channels = 10;
inline bool MediumMetadata::has_wifi_aware_usable_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_aware_usable_channels_ != nullptr);
  return value;
}
inline void MediumMetadata::clear_wifi_aware_usable_channels() {
  if (_impl_.wifi_aware_usable_channels_ != nullptr) _impl_.wifi_aware_usable_channels_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::location::nearby::connections::WifiAwareUsableChannels& MediumMetadata::_internal_wifi_aware_usable_channels() const {
  const ::location::nearby::connections::WifiAwareUsableChannels* p = _impl_.wifi_aware_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiAwareUsableChannels&>(
      ::location::nearby::connections::_WifiAwareUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiAwareUsableChannels& MediumMetadata::wifi_aware_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
  return _internal_wifi_aware_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_aware_usable_channels(
    ::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_aware_usable_channels_);
  }
  _impl_.wifi_aware_usable_channels_ = wifi_aware_usable_channels;
  if (wifi_aware_usable_channels) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::release_wifi_aware_usable_channels() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::WifiAwareUsableChannels* temp = _impl_.wifi_aware_usable_channels_;
  _impl_.wifi_aware_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::unsafe_arena_release_wifi_aware_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::location::nearby::connections::WifiAwareUsableChannels* temp = _impl_.wifi_aware_usable_channels_;
  _impl_.wifi_aware_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::_internal_mutable_wifi_aware_usable_channels() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.wifi_aware_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiAwareUsableChannels>(GetArenaForAllocation());
    _impl_.wifi_aware_usable_channels_ = p;
  }
  return _impl_.wifi_aware_usable_channels_;
}
inline ::location::nearby::connections::WifiAwareUsableChannels* MediumMetadata::mutable_wifi_aware_usable_channels() {
  ::location::nearby::connections::WifiAwareUsableChannels* _msg = _internal_mutable_wifi_aware_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_aware_usable_channels(::location::nearby::connections::WifiAwareUsableChannels* wifi_aware_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_aware_usable_channels_;
  }
  if (wifi_aware_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_aware_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_aware_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_aware_usable_channels, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.wifi_aware_usable_channels_ = wifi_aware_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_aware_usable_channels)
}

// optional .location.nearby.connections.WifiHotspotStaUsableChannels wifi_hotspot_sta_usable_channels = 11;
inline bool MediumMetadata::has_wifi_hotspot_sta_usable_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wifi_hotspot_sta_usable_channels_ != nullptr);
  return value;
}
inline void MediumMetadata::clear_wifi_hotspot_sta_usable_channels() {
  if (_impl_.wifi_hotspot_sta_usable_channels_ != nullptr) _impl_.wifi_hotspot_sta_usable_channels_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::location::nearby::connections::WifiHotspotStaUsableChannels& MediumMetadata::_internal_wifi_hotspot_sta_usable_channels() const {
  const ::location::nearby::connections::WifiHotspotStaUsableChannels* p = _impl_.wifi_hotspot_sta_usable_channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::location::nearby::connections::WifiHotspotStaUsableChannels&>(
      ::location::nearby::connections::_WifiHotspotStaUsableChannels_default_instance_);
}
inline const ::location::nearby::connections::WifiHotspotStaUsableChannels& MediumMetadata::wifi_hotspot_sta_usable_channels() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
  return _internal_wifi_hotspot_sta_usable_channels();
}
inline void MediumMetadata::unsafe_arena_set_allocated_wifi_hotspot_sta_usable_channels(
    ::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wifi_hotspot_sta_usable_channels_);
  }
  _impl_.wifi_hotspot_sta_usable_channels_ = wifi_hotspot_sta_usable_channels;
  if (wifi_hotspot_sta_usable_channels) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::release_wifi_hotspot_sta_usable_channels() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* temp = _impl_.wifi_hotspot_sta_usable_channels_;
  _impl_.wifi_hotspot_sta_usable_channels_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::unsafe_arena_release_wifi_hotspot_sta_usable_channels() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::location::nearby::connections::WifiHotspotStaUsableChannels* temp = _impl_.wifi_hotspot_sta_usable_channels_;
  _impl_.wifi_hotspot_sta_usable_channels_ = nullptr;
  return temp;
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::_internal_mutable_wifi_hotspot_sta_usable_channels() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.wifi_hotspot_sta_usable_channels_ == nullptr) {
    auto* p = CreateMaybeMessage<::location::nearby::connections::WifiHotspotStaUsableChannels>(GetArenaForAllocation());
    _impl_.wifi_hotspot_sta_usable_channels_ = p;
  }
  return _impl_.wifi_hotspot_sta_usable_channels_;
}
inline ::location::nearby::connections::WifiHotspotStaUsableChannels* MediumMetadata::mutable_wifi_hotspot_sta_usable_channels() {
  ::location::nearby::connections::WifiHotspotStaUsableChannels* _msg = _internal_mutable_wifi_hotspot_sta_usable_channels();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
  return _msg;
}
inline void MediumMetadata::set_allocated_wifi_hotspot_sta_usable_channels(::location::nearby::connections::WifiHotspotStaUsableChannels* wifi_hotspot_sta_usable_channels) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wifi_hotspot_sta_usable_channels_;
  }
  if (wifi_hotspot_sta_usable_channels) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wifi_hotspot_sta_usable_channels);
    if (message_arena != submessage_arena) {
      wifi_hotspot_sta_usable_channels = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wifi_hotspot_sta_usable_channels, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.wifi_hotspot_sta_usable_channels_ = wifi_hotspot_sta_usable_channels;
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.MediumMetadata.wifi_hotspot_sta_usable_channels)
}

// -------------------------------------------------------------------

// AvailableChannels

// repeated int32 channels = 1 [packed = true];
inline int AvailableChannels::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int AvailableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void AvailableChannels::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::int32_t AvailableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.AvailableChannels.channels)
  return _internal_channels(index);
}
inline void AvailableChannels::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.AvailableChannels.channels)
}
inline void AvailableChannels::add_channels(::int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.AvailableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& AvailableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.AvailableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* AvailableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.AvailableChannels.channels)
  return _internal_mutable_channels();
}

inline ::int32_t AvailableChannels::_internal_channels(int index) const {
  return _internal_channels().Get(index);
}
inline void AvailableChannels::_internal_add_channels(::int32_t value) {
  _internal_mutable_channels()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& AvailableChannels::_internal_channels() const {
  return _impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* AvailableChannels::_internal_mutable_channels() {
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// WifiDirectCliUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiDirectCliUsableChannels::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int WifiDirectCliUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiDirectCliUsableChannels::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::int32_t WifiDirectCliUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiDirectCliUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiDirectCliUsableChannels::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiDirectCliUsableChannels.channels)
}
inline void WifiDirectCliUsableChannels::add_channels(::int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiDirectCliUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiDirectCliUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiDirectCliUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiDirectCliUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiDirectCliUsableChannels.channels)
  return _internal_mutable_channels();
}

inline ::int32_t WifiDirectCliUsableChannels::_internal_channels(int index) const {
  return _internal_channels().Get(index);
}
inline void WifiDirectCliUsableChannels::_internal_add_channels(::int32_t value) {
  _internal_mutable_channels()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiDirectCliUsableChannels::_internal_channels() const {
  return _impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiDirectCliUsableChannels::_internal_mutable_channels() {
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// WifiLanUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiLanUsableChannels::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int WifiLanUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiLanUsableChannels::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::int32_t WifiLanUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiLanUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiLanUsableChannels::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiLanUsableChannels.channels)
}
inline void WifiLanUsableChannels::add_channels(::int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiLanUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiLanUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiLanUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiLanUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiLanUsableChannels.channels)
  return _internal_mutable_channels();
}

inline ::int32_t WifiLanUsableChannels::_internal_channels(int index) const {
  return _internal_channels().Get(index);
}
inline void WifiLanUsableChannels::_internal_add_channels(::int32_t value) {
  _internal_mutable_channels()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiLanUsableChannels::_internal_channels() const {
  return _impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiLanUsableChannels::_internal_mutable_channels() {
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// WifiAwareUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiAwareUsableChannels::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int WifiAwareUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiAwareUsableChannels::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::int32_t WifiAwareUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiAwareUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiAwareUsableChannels::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiAwareUsableChannels.channels)
}
inline void WifiAwareUsableChannels::add_channels(::int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiAwareUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiAwareUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiAwareUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiAwareUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiAwareUsableChannels.channels)
  return _internal_mutable_channels();
}

inline ::int32_t WifiAwareUsableChannels::_internal_channels(int index) const {
  return _internal_channels().Get(index);
}
inline void WifiAwareUsableChannels::_internal_add_channels(::int32_t value) {
  _internal_mutable_channels()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiAwareUsableChannels::_internal_channels() const {
  return _impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiAwareUsableChannels::_internal_mutable_channels() {
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// WifiHotspotStaUsableChannels

// repeated int32 channels = 1 [packed = true];
inline int WifiHotspotStaUsableChannels::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int WifiHotspotStaUsableChannels::channels_size() const {
  return _internal_channels_size();
}
inline void WifiHotspotStaUsableChannels::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::int32_t WifiHotspotStaUsableChannels::channels(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
  return _internal_channels(index);
}
inline void WifiHotspotStaUsableChannels::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
}
inline void WifiHotspotStaUsableChannels::add_channels(::int32_t value) {
  _internal_add_channels(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiHotspotStaUsableChannels::channels() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
  return _internal_channels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiHotspotStaUsableChannels::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.WifiHotspotStaUsableChannels.channels)
  return _internal_mutable_channels();
}

inline ::int32_t WifiHotspotStaUsableChannels::_internal_channels(int index) const {
  return _internal_channels().Get(index);
}
inline void WifiHotspotStaUsableChannels::_internal_add_channels(::int32_t value) {
  _internal_mutable_channels()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& WifiHotspotStaUsableChannels::_internal_channels() const {
  return _impl_.channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* WifiHotspotStaUsableChannels::_internal_mutable_channels() {
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// LocationHint

// optional string location = 1;
inline bool LocationHint::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LocationHint::clear_location() {
  _impl_.location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocationHint::location() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.LocationHint.location)
  return _internal_location();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LocationHint::set_location(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.LocationHint.location)
}
inline std::string* LocationHint::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.LocationHint.location)
  return _s;
}
inline const std::string& LocationHint::_internal_location() const {
  return _impl_.location_.Get();
}
inline void LocationHint::_internal_set_location(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* LocationHint::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.location_.Mutable( GetArenaForAllocation());
}
inline std::string* LocationHint::release_location() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.LocationHint.location)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.location_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.location_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LocationHint::set_allocated_location(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.location_.IsDefault()) {
          _impl_.location_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.LocationHint.location)
}

// optional .location.nearby.connections.LocationStandard.Format format = 2;
inline bool LocationHint::has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LocationHint::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::connections::LocationStandard_Format LocationHint::format() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.LocationHint.format)
  return _internal_format();
}
inline void LocationHint::set_format(::location::nearby::connections::LocationStandard_Format value) {
   _internal_set_format(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.LocationHint.format)
}
inline ::location::nearby::connections::LocationStandard_Format LocationHint::_internal_format() const {
  return static_cast<::location::nearby::connections::LocationStandard_Format>(_impl_.format_);
}
inline void LocationHint::_internal_set_format(::location::nearby::connections::LocationStandard_Format value) {
  assert(::location::nearby::connections::LocationStandard_Format_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.format_ = value;
}

// -------------------------------------------------------------------

// LocationStandard

// -------------------------------------------------------------------

// OsInfo

// optional .location.nearby.connections.OsInfo.OsType type = 1;
inline bool OsInfo::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OsInfo::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::location::nearby::connections::OsInfo_OsType OsInfo::type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.OsInfo.type)
  return _internal_type();
}
inline void OsInfo::set_type(::location::nearby::connections::OsInfo_OsType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.OsInfo.type)
}
inline ::location::nearby::connections::OsInfo_OsType OsInfo::_internal_type() const {
  return static_cast<::location::nearby::connections::OsInfo_OsType>(_impl_.type_);
}
inline void OsInfo::_internal_set_type(::location::nearby::connections::OsInfo_OsType value) {
  assert(::location::nearby::connections::OsInfo_OsType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// ConnectionsDevice

// optional string endpoint_id = 1;
inline bool ConnectionsDevice::has_endpoint_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConnectionsDevice::clear_endpoint_id() {
  _impl_.endpoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionsDevice::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.endpoint_id)
  return _internal_endpoint_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionsDevice::set_endpoint_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.endpoint_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.endpoint_id)
}
inline std::string* ConnectionsDevice::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionsDevice.endpoint_id)
  return _s;
}
inline const std::string& ConnectionsDevice::_internal_endpoint_id() const {
  return _impl_.endpoint_id_.Get();
}
inline void ConnectionsDevice::_internal_set_endpoint_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.endpoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::_internal_mutable_endpoint_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.endpoint_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionsDevice.endpoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.endpoint_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionsDevice::set_allocated_endpoint_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_id_.IsDefault()) {
          _impl_.endpoint_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionsDevice.endpoint_id)
}

// optional .location.nearby.connections.EndpointType endpoint_type = 2;
inline bool ConnectionsDevice::has_endpoint_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ConnectionsDevice::clear_endpoint_type() {
  _impl_.endpoint_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::location::nearby::connections::EndpointType ConnectionsDevice::endpoint_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.endpoint_type)
  return _internal_endpoint_type();
}
inline void ConnectionsDevice::set_endpoint_type(::location::nearby::connections::EndpointType value) {
   _internal_set_endpoint_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.endpoint_type)
}
inline ::location::nearby::connections::EndpointType ConnectionsDevice::_internal_endpoint_type() const {
  return static_cast<::location::nearby::connections::EndpointType>(_impl_.endpoint_type_);
}
inline void ConnectionsDevice::_internal_set_endpoint_type(::location::nearby::connections::EndpointType value) {
  assert(::location::nearby::connections::EndpointType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endpoint_type_ = value;
}

// optional bytes connectivity_info_list = 3;
inline bool ConnectionsDevice::has_connectivity_info_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ConnectionsDevice::clear_connectivity_info_list() {
  _impl_.connectivity_info_list_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectionsDevice::connectivity_info_list() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
  return _internal_connectivity_info_list();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionsDevice::set_connectivity_info_list(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.connectivity_info_list_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
}
inline std::string* ConnectionsDevice::mutable_connectivity_info_list() {
  std::string* _s = _internal_mutable_connectivity_info_list();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
  return _s;
}
inline const std::string& ConnectionsDevice::_internal_connectivity_info_list() const {
  return _impl_.connectivity_info_list_.Get();
}
inline void ConnectionsDevice::_internal_set_connectivity_info_list(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.connectivity_info_list_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::_internal_mutable_connectivity_info_list() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.connectivity_info_list_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::release_connectivity_info_list() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.connectivity_info_list_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connectivity_info_list_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionsDevice::set_allocated_connectivity_info_list(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.connectivity_info_list_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectivity_info_list_.IsDefault()) {
          _impl_.connectivity_info_list_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionsDevice.connectivity_info_list)
}

// optional bytes endpoint_info = 4;
inline bool ConnectionsDevice::has_endpoint_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ConnectionsDevice::clear_endpoint_info() {
  _impl_.endpoint_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConnectionsDevice::endpoint_info() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.ConnectionsDevice.endpoint_info)
  return _internal_endpoint_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectionsDevice::set_endpoint_info(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endpoint_info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.ConnectionsDevice.endpoint_info)
}
inline std::string* ConnectionsDevice::mutable_endpoint_info() {
  std::string* _s = _internal_mutable_endpoint_info();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.ConnectionsDevice.endpoint_info)
  return _s;
}
inline const std::string& ConnectionsDevice::_internal_endpoint_info() const {
  return _impl_.endpoint_info_.Get();
}
inline void ConnectionsDevice::_internal_set_endpoint_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.endpoint_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::_internal_mutable_endpoint_info() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.endpoint_info_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectionsDevice::release_endpoint_info() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.ConnectionsDevice.endpoint_info)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.endpoint_info_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_info_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ConnectionsDevice::set_allocated_endpoint_info(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.endpoint_info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_info_.IsDefault()) {
          _impl_.endpoint_info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.ConnectionsDevice.endpoint_info)
}

// -------------------------------------------------------------------

// PresenceDevice

// optional string endpoint_id = 1;
inline bool PresenceDevice::has_endpoint_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PresenceDevice::clear_endpoint_id() {
  _impl_.endpoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PresenceDevice::endpoint_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.endpoint_id)
  return _internal_endpoint_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PresenceDevice::set_endpoint_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.endpoint_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.endpoint_id)
}
inline std::string* PresenceDevice::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.endpoint_id)
  return _s;
}
inline const std::string& PresenceDevice::_internal_endpoint_id() const {
  return _impl_.endpoint_id_.Get();
}
inline void PresenceDevice::_internal_set_endpoint_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.endpoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_endpoint_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.endpoint_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.endpoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.endpoint_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endpoint_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PresenceDevice::set_allocated_endpoint_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endpoint_id_.IsDefault()) {
          _impl_.endpoint_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.endpoint_id)
}

// optional .location.nearby.connections.EndpointType endpoint_type = 2;
inline bool PresenceDevice::has_endpoint_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PresenceDevice::clear_endpoint_type() {
  _impl_.endpoint_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::location::nearby::connections::EndpointType PresenceDevice::endpoint_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.endpoint_type)
  return _internal_endpoint_type();
}
inline void PresenceDevice::set_endpoint_type(::location::nearby::connections::EndpointType value) {
   _internal_set_endpoint_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.endpoint_type)
}
inline ::location::nearby::connections::EndpointType PresenceDevice::_internal_endpoint_type() const {
  return static_cast<::location::nearby::connections::EndpointType>(_impl_.endpoint_type_);
}
inline void PresenceDevice::_internal_set_endpoint_type(::location::nearby::connections::EndpointType value) {
  assert(::location::nearby::connections::EndpointType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.endpoint_type_ = value;
}

// optional bytes connectivity_info_list = 3;
inline bool PresenceDevice::has_connectivity_info_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PresenceDevice::clear_connectivity_info_list() {
  _impl_.connectivity_info_list_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PresenceDevice::connectivity_info_list() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.connectivity_info_list)
  return _internal_connectivity_info_list();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PresenceDevice::set_connectivity_info_list(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.connectivity_info_list_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.connectivity_info_list)
}
inline std::string* PresenceDevice::mutable_connectivity_info_list() {
  std::string* _s = _internal_mutable_connectivity_info_list();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.connectivity_info_list)
  return _s;
}
inline const std::string& PresenceDevice::_internal_connectivity_info_list() const {
  return _impl_.connectivity_info_list_.Get();
}
inline void PresenceDevice::_internal_set_connectivity_info_list(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.connectivity_info_list_.Set(value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_connectivity_info_list() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.connectivity_info_list_.Mutable( GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_connectivity_info_list() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.connectivity_info_list)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.connectivity_info_list_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connectivity_info_list_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PresenceDevice::set_allocated_connectivity_info_list(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.connectivity_info_list_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectivity_info_list_.IsDefault()) {
          _impl_.connectivity_info_list_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.connectivity_info_list)
}

// optional int64 device_id = 4;
inline bool PresenceDevice::has_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PresenceDevice::clear_device_id() {
  _impl_.device_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t PresenceDevice::device_id() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_id)
  return _internal_device_id();
}
inline void PresenceDevice::set_device_id(::int64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_id)
}
inline ::int64_t PresenceDevice::_internal_device_id() const {
  return _impl_.device_id_;
}
inline void PresenceDevice::_internal_set_device_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.device_id_ = value;
}

// optional string device_name = 5;
inline bool PresenceDevice::has_device_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PresenceDevice::clear_device_name() {
  _impl_.device_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PresenceDevice::device_name() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_name)
  return _internal_device_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PresenceDevice::set_device_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.device_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_name)
}
inline std::string* PresenceDevice::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.device_name)
  return _s;
}
inline const std::string& PresenceDevice::_internal_device_name() const {
  return _impl_.device_name_.Get();
}
inline void PresenceDevice::_internal_set_device_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_device_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.device_name_.Mutable( GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_device_name() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.device_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.device_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PresenceDevice::set_allocated_device_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.device_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_name_.IsDefault()) {
          _impl_.device_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.device_name)
}

// optional .location.nearby.connections.PresenceDevice.DeviceType device_type = 6;
inline bool PresenceDevice::has_device_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PresenceDevice::clear_device_type() {
  _impl_.device_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::location::nearby::connections::PresenceDevice_DeviceType PresenceDevice::device_type() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_type)
  return _internal_device_type();
}
inline void PresenceDevice::set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value) {
   _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_type)
}
inline ::location::nearby::connections::PresenceDevice_DeviceType PresenceDevice::_internal_device_type() const {
  return static_cast<::location::nearby::connections::PresenceDevice_DeviceType>(_impl_.device_type_);
}
inline void PresenceDevice::_internal_set_device_type(::location::nearby::connections::PresenceDevice_DeviceType value) {
  assert(::location::nearby::connections::PresenceDevice_DeviceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.device_type_ = value;
}

// optional string device_image_url = 7;
inline bool PresenceDevice::has_device_image_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PresenceDevice::clear_device_image_url() {
  _impl_.device_image_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PresenceDevice::device_image_url() const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.device_image_url)
  return _internal_device_image_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PresenceDevice::set_device_image_url(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.device_image_url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.device_image_url)
}
inline std::string* PresenceDevice::mutable_device_image_url() {
  std::string* _s = _internal_mutable_device_image_url();
  // @@protoc_insertion_point(field_mutable:location.nearby.connections.PresenceDevice.device_image_url)
  return _s;
}
inline const std::string& PresenceDevice::_internal_device_image_url() const {
  return _impl_.device_image_url_.Get();
}
inline void PresenceDevice::_internal_set_device_image_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.device_image_url_.Set(value, GetArenaForAllocation());
}
inline std::string* PresenceDevice::_internal_mutable_device_image_url() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.device_image_url_.Mutable( GetArenaForAllocation());
}
inline std::string* PresenceDevice::release_device_image_url() {
  // @@protoc_insertion_point(field_release:location.nearby.connections.PresenceDevice.device_image_url)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.device_image_url_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_image_url_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PresenceDevice::set_allocated_device_image_url(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.device_image_url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_image_url_.IsDefault()) {
          _impl_.device_image_url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:location.nearby.connections.PresenceDevice.device_image_url)
}

// repeated .location.nearby.connections.ConnectionRequestFrame.Medium discovery_medium = 8 [packed = true];
inline int PresenceDevice::_internal_discovery_medium_size() const {
  return _impl_.discovery_medium_.size();
}
inline int PresenceDevice::discovery_medium_size() const {
  return _internal_discovery_medium_size();
}
inline void PresenceDevice::clear_discovery_medium() {
  _internal_mutable_discovery_medium()->Clear();
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium PresenceDevice::discovery_medium(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.discovery_medium)
  return _internal_discovery_medium(index);
}
inline void PresenceDevice::set_discovery_medium(int index, ::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  _internal_mutable_discovery_medium()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.discovery_medium)
}
inline void PresenceDevice::add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  _internal_add_discovery_medium(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.PresenceDevice.discovery_medium)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& PresenceDevice::discovery_medium() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.PresenceDevice.discovery_medium)
  return _internal_discovery_medium();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* PresenceDevice::mutable_discovery_medium() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.PresenceDevice.discovery_medium)
  return _internal_mutable_discovery_medium();
}
inline ::location::nearby::connections::ConnectionRequestFrame_Medium PresenceDevice::_internal_discovery_medium(int index) const {
  return static_cast<::location::nearby::connections::ConnectionRequestFrame_Medium>(_internal_discovery_medium().Get(index));
}
inline void PresenceDevice::_internal_add_discovery_medium(::location::nearby::connections::ConnectionRequestFrame_Medium value) {
  assert(::location::nearby::connections::ConnectionRequestFrame_Medium_IsValid(value));
  _internal_mutable_discovery_medium()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& PresenceDevice::_internal_discovery_medium() const {
  return _impl_.discovery_medium_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* PresenceDevice::_internal_mutable_discovery_medium() {
  return &_impl_.discovery_medium_;
}

// repeated int32 actions = 9 [packed = true];
inline int PresenceDevice::_internal_actions_size() const {
  return _impl_.actions_.size();
}
inline int PresenceDevice::actions_size() const {
  return _internal_actions_size();
}
inline void PresenceDevice::clear_actions() {
  _internal_mutable_actions()->Clear();
}
inline ::int32_t PresenceDevice::actions(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.actions)
  return _internal_actions(index);
}
inline void PresenceDevice::set_actions(int index, ::int32_t value) {
  _internal_mutable_actions()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.actions)
}
inline void PresenceDevice::add_actions(::int32_t value) {
  _internal_add_actions(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.PresenceDevice.actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& PresenceDevice::actions() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.PresenceDevice.actions)
  return _internal_actions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* PresenceDevice::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.PresenceDevice.actions)
  return _internal_mutable_actions();
}

inline ::int32_t PresenceDevice::_internal_actions(int index) const {
  return _internal_actions().Get(index);
}
inline void PresenceDevice::_internal_add_actions(::int32_t value) {
  _internal_mutable_actions()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& PresenceDevice::_internal_actions() const {
  return _impl_.actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* PresenceDevice::_internal_mutable_actions() {
  return &_impl_.actions_;
}

// repeated int64 identity_type = 10 [packed = true];
inline int PresenceDevice::_internal_identity_type_size() const {
  return _impl_.identity_type_.size();
}
inline int PresenceDevice::identity_type_size() const {
  return _internal_identity_type_size();
}
inline void PresenceDevice::clear_identity_type() {
  _internal_mutable_identity_type()->Clear();
}
inline ::int64_t PresenceDevice::identity_type(int index) const {
  // @@protoc_insertion_point(field_get:location.nearby.connections.PresenceDevice.identity_type)
  return _internal_identity_type(index);
}
inline void PresenceDevice::set_identity_type(int index, ::int64_t value) {
  _internal_mutable_identity_type()->Set(index, value);
  // @@protoc_insertion_point(field_set:location.nearby.connections.PresenceDevice.identity_type)
}
inline void PresenceDevice::add_identity_type(::int64_t value) {
  _internal_add_identity_type(value);
  // @@protoc_insertion_point(field_add:location.nearby.connections.PresenceDevice.identity_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& PresenceDevice::identity_type() const {
  // @@protoc_insertion_point(field_list:location.nearby.connections.PresenceDevice.identity_type)
  return _internal_identity_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* PresenceDevice::mutable_identity_type() {
  // @@protoc_insertion_point(field_mutable_list:location.nearby.connections.PresenceDevice.identity_type)
  return _internal_mutable_identity_type();
}

inline ::int64_t PresenceDevice::_internal_identity_type(int index) const {
  return _internal_identity_type().Get(index);
}
inline void PresenceDevice::_internal_add_identity_type(::int64_t value) {
  _internal_mutable_identity_type()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& PresenceDevice::_internal_identity_type() const {
  return _impl_.identity_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* PresenceDevice::_internal_mutable_identity_type() {
  return &_impl_.identity_type_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace connections
}  // namespace nearby
}  // namespace location


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::location::nearby::connections::OfflineFrame_Version> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::V1Frame_FrameType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::ConnectionRequestFrame_Medium> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::ConnectionResponseFrame_ResponseStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::PayloadTransferFrame_PayloadHeader_PayloadType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::PayloadTransferFrame_PayloadChunk_Flags> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::PayloadTransferFrame_ControlMessage_EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::PayloadTransferFrame_PacketType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_UpgradePathInfo_Medium> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::BandwidthUpgradeNegotiationFrame_EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::BandwidthUpgradeRetryFrame_Medium> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::AutoResumeFrame_EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::AutoReconnectFrame_EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::LocationStandard_Format> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::OsInfo_OsType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::PresenceDevice_DeviceType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::connections::EndpointType> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_connections_2fimplementation_2fproto_2foffline_5fwire_5fformats_2eproto_2epb_2eh
