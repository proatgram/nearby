// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/errorcode/error_code_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2ferrorcode_2ferror_5fcode_5fenums_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2ferrorcode_2ferror_5fcode_5fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2ferrorcode_2ferror_5fcode_5fenums_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2ferrorcode_2ferror_5fcode_5fenums_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

namespace location {
namespace nearby {
namespace errorcode {
namespace proto {
enum ErrorType : int {
  UNKNOWN_TYPE = 0,
  DEVELOPING = 1,
  DEVICE = 2,
  SYSTEM = 3,
  NETWORK = 4,
  OTHERS = 5,
};

bool ErrorType_IsValid(int value);
constexpr ErrorType ErrorType_MIN = static_cast<ErrorType>(0);
constexpr ErrorType ErrorType_MAX = static_cast<ErrorType>(5);
constexpr int ErrorType_ARRAYSIZE = 5 + 1;
const std::string& ErrorType_Name(ErrorType value);
template <typename T>
const std::string& ErrorType_Name(T value) {
  static_assert(std::is_same<T, ErrorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorType_Name().");
  return ErrorType_Name(static_cast<ErrorType>(value));
}
const std::string& ErrorType_Name(ErrorType value);
bool ErrorType_Parse(absl::string_view name, ErrorType* value);
enum Event : int {
  UNKNOWN_EVENT = 0,
  START_ADVERTISING = 1,
  STOP_ADVERTISING = 2,
  START_LISTENING_INCOMING_CONNECTION = 3,
  STOP_LISTENING_INCOMING_CONNECTION = 4,
  START_DISCOVERING = 5,
  STOP_DISCOVERING = 6,
  CONNECT = 7,
  DISCONNECT = 8,
  ACCEPT_CONNECTION = 9,
  REJECT_CONNECTION = 10,
  SEND_PAYLOAD = 11,
  CANCEL_PAYLOAD = 12,
  RECEIVE_PAYLOAD = 13,
  UPGRADE = 14,
};

bool Event_IsValid(int value);
constexpr Event Event_MIN = static_cast<Event>(0);
constexpr Event Event_MAX = static_cast<Event>(14);
constexpr int Event_ARRAYSIZE = 14 + 1;
const std::string& Event_Name(Event value);
template <typename T>
const std::string& Event_Name(T value) {
  static_assert(std::is_same<T, Event>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Event_Name().");
  return Event_Name(static_cast<Event>(value));
}
const std::string& Event_Name(Event value);
bool Event_Parse(absl::string_view name, Event* value);
enum CommonError : int {
  UNKNOWN_ERROR = 0,
  INVALID_PARAMETER = 1,
  MEDIUM_NOT_AVAILABLE = 2,
  UNEXPECTED_MEDIUM_STATE = 3,
  OUT_OF_RESOURCE = 4,
  FLOW_CANCELED = 5,
  UNEXPECTED_CALL = 6,
};

bool CommonError_IsValid(int value);
constexpr CommonError CommonError_MIN = static_cast<CommonError>(0);
constexpr CommonError CommonError_MAX = static_cast<CommonError>(6);
constexpr int CommonError_ARRAYSIZE = 6 + 1;
const std::string& CommonError_Name(CommonError value);
template <typename T>
const std::string& CommonError_Name(T value) {
  static_assert(std::is_same<T, CommonError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CommonError_Name().");
  return CommonError_Name(static_cast<CommonError>(value));
}
const std::string& CommonError_Name(CommonError value);
bool CommonError_Parse(absl::string_view name, CommonError* value);
enum StartAdvertisingError : int {
  MULTIPLE_FAST_ADVERTISEMENT_NOT_ALLOWED = 31,
  FAST_ADVERTISEMENT_ALREADY_ADVERTISED = 32,
  DUPLICATE_ADVERTISING_REQUESTED = 33,
  START_GATT_SERVER_FAILED = 34,
  BLE_MAX_GATT_ADVERTISEMENT_SLOT_REACHED = 35,
  START_LEGACY_ADVERTISING_FAILED = 36,
  START_EXTENDED_ADVERTISING_FAILED = 38,
  BLUETOOTH_ALREADY_ADVERTISED = 40,
  MODIFY_BLUETOOTH_NAME_FAILED = 41,
  PERSIST_ORIGINAL_BLUETOOTH_NAME_FAILED = 42,
  START_ADVERTISING_FAILED = 43,
  SHOULD_ACCEPT_CONNECTIONS_BEFORE_ADVERTISING_ON_WIFI_LAN = 44,
  ACQUIRE_WIFI_AWARE_SESSION_FAILED = 45,
  UNKNOWN_START_ADVERTISING_ERROR = 46,
  AWARE_UPDATE_PUBLISHING_FAILED = 47,
};

bool StartAdvertisingError_IsValid(int value);
constexpr StartAdvertisingError StartAdvertisingError_MIN = static_cast<StartAdvertisingError>(31);
constexpr StartAdvertisingError StartAdvertisingError_MAX = static_cast<StartAdvertisingError>(47);
constexpr int StartAdvertisingError_ARRAYSIZE = 47 + 1;
const std::string& StartAdvertisingError_Name(StartAdvertisingError value);
template <typename T>
const std::string& StartAdvertisingError_Name(T value) {
  static_assert(std::is_same<T, StartAdvertisingError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StartAdvertisingError_Name().");
  return StartAdvertisingError_Name(static_cast<StartAdvertisingError>(value));
}
const std::string& StartAdvertisingError_Name(StartAdvertisingError value);
bool StartAdvertisingError_Parse(absl::string_view name, StartAdvertisingError* value);
enum StopAdvertisingError : int {
  STOP_ADVERTISING_FAILED = 31,
  RESTORE_BLUETOOTH_NAME_FAILED = 32,
  STOP_LEGACY_ADVERTISING_FAILED = 33,
  STOP_EXTENDED_ADVERTISING_FAILED = 34,
  UNKNOWN_STOP_ADVERTISING_ERROR = 35,
};

bool StopAdvertisingError_IsValid(int value);
constexpr StopAdvertisingError StopAdvertisingError_MIN = static_cast<StopAdvertisingError>(31);
constexpr StopAdvertisingError StopAdvertisingError_MAX = static_cast<StopAdvertisingError>(35);
constexpr int StopAdvertisingError_ARRAYSIZE = 35 + 1;
const std::string& StopAdvertisingError_Name(StopAdvertisingError value);
template <typename T>
const std::string& StopAdvertisingError_Name(T value) {
  static_assert(std::is_same<T, StopAdvertisingError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StopAdvertisingError_Name().");
  return StopAdvertisingError_Name(static_cast<StopAdvertisingError>(value));
}
const std::string& StopAdvertisingError_Name(StopAdvertisingError value);
bool StopAdvertisingError_Parse(absl::string_view name, StopAdvertisingError* value);
enum StartDiscoveringError : int {
  DUPLICATE_DISCOVERING_REQUESTED = 31,
  START_LEGACY_DISCOVERING_FAILED = 32,
  START_EXTENDED_DISCOVERING_FAILED = 33,
  START_DISCOVERING_FAILED = 34,
  INVALID_TARGET_INFO = 35,
  FETCH_ADVERTISEMENT_FAILED = 36,
  GATT_FETCH_ADVERTISEMENT_FAILED = 37,
  L2CAP_FETCH_ADVERTISEMENT_FAILED = 38,
  NOT_AVAILABLE_TO_FETCH_ADVERTISEMENT = 39,
  ACQUIRE_WIFI_AWARE_SESSION_FOR_DISCOVERING_FAILED = 40,
  UNKNOWN_START_DISCOVERING_ERROR = 41,
};

bool StartDiscoveringError_IsValid(int value);
constexpr StartDiscoveringError StartDiscoveringError_MIN = static_cast<StartDiscoveringError>(31);
constexpr StartDiscoveringError StartDiscoveringError_MAX = static_cast<StartDiscoveringError>(41);
constexpr int StartDiscoveringError_ARRAYSIZE = 41 + 1;
const std::string& StartDiscoveringError_Name(StartDiscoveringError value);
template <typename T>
const std::string& StartDiscoveringError_Name(T value) {
  static_assert(std::is_same<T, StartDiscoveringError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StartDiscoveringError_Name().");
  return StartDiscoveringError_Name(static_cast<StartDiscoveringError>(value));
}
const std::string& StartDiscoveringError_Name(StartDiscoveringError value);
bool StartDiscoveringError_Parse(absl::string_view name, StartDiscoveringError* value);
enum StopDiscoveringError : int {
  STOP_DISCOVERING_FAILED = 31,
  STOP_LEGACY_DISCOVERING_FAILED = 32,
  STOP_EXTENDED_DISCOVERING_FAILED = 33,
  UNKNOWN_STOP_DISCOVERING_ERROR = 34,
};

bool StopDiscoveringError_IsValid(int value);
constexpr StopDiscoveringError StopDiscoveringError_MIN = static_cast<StopDiscoveringError>(31);
constexpr StopDiscoveringError StopDiscoveringError_MAX = static_cast<StopDiscoveringError>(34);
constexpr int StopDiscoveringError_ARRAYSIZE = 34 + 1;
const std::string& StopDiscoveringError_Name(StopDiscoveringError value);
template <typename T>
const std::string& StopDiscoveringError_Name(T value) {
  static_assert(std::is_same<T, StopDiscoveringError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StopDiscoveringError_Name().");
  return StopDiscoveringError_Name(static_cast<StopDiscoveringError>(value));
}
const std::string& StopDiscoveringError_Name(StopDiscoveringError value);
bool StopDiscoveringError_Parse(absl::string_view name, StopDiscoveringError* value);
enum StartListeningIncomingConnectionError : int {
  DUPLICATE_ACCEPTING_CONNECTION_REQUESTED = 31,
  OPEN_GATT_SERVER_FAILED = 32,
  ACCEPT_GATT_CONNECTION_FAILED = 33,
  ACCEPT_L2CAP_CONNECTION_FAILED = 34,
  CREATE_GATT_SERVER_SOCKET_NOT_READY = 35,
  ACCEPT_CONNECTION_FAILED = 36,
  CREATE_SERVER_SOCKET_FAILED = 37,
  UNKNOWN_START_LISTENING_INCOMING_CONNECTION_ERROR = 38,
  ACCEPT_SEND_AWARE_L2_MESSAGE_FAILED = 39,
  ACCEPT_RECEIVE_AWARE_L2_MESSAGE_FAILED = 40,
};

bool StartListeningIncomingConnectionError_IsValid(int value);
constexpr StartListeningIncomingConnectionError StartListeningIncomingConnectionError_MIN = static_cast<StartListeningIncomingConnectionError>(31);
constexpr StartListeningIncomingConnectionError StartListeningIncomingConnectionError_MAX = static_cast<StartListeningIncomingConnectionError>(40);
constexpr int StartListeningIncomingConnectionError_ARRAYSIZE = 40 + 1;
const std::string& StartListeningIncomingConnectionError_Name(StartListeningIncomingConnectionError value);
template <typename T>
const std::string& StartListeningIncomingConnectionError_Name(T value) {
  static_assert(std::is_same<T, StartListeningIncomingConnectionError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StartListeningIncomingConnectionError_Name().");
  return StartListeningIncomingConnectionError_Name(static_cast<StartListeningIncomingConnectionError>(value));
}
const std::string& StartListeningIncomingConnectionError_Name(StartListeningIncomingConnectionError value);
bool StartListeningIncomingConnectionError_Parse(absl::string_view name, StartListeningIncomingConnectionError* value);
enum StopListeningIncomingConnectionError : int {
  STOP_ACCEPTING_CONNECTION_FAILED = 31,
  UNKNOWN_STOP_LISTENING_INCOMING_CONNECTION_ERROR = 32,
};

bool StopListeningIncomingConnectionError_IsValid(int value);
constexpr StopListeningIncomingConnectionError StopListeningIncomingConnectionError_MIN = static_cast<StopListeningIncomingConnectionError>(31);
constexpr StopListeningIncomingConnectionError StopListeningIncomingConnectionError_MAX = static_cast<StopListeningIncomingConnectionError>(32);
constexpr int StopListeningIncomingConnectionError_ARRAYSIZE = 32 + 1;
const std::string& StopListeningIncomingConnectionError_Name(StopListeningIncomingConnectionError value);
template <typename T>
const std::string& StopListeningIncomingConnectionError_Name(T value) {
  static_assert(std::is_same<T, StopListeningIncomingConnectionError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StopListeningIncomingConnectionError_Name().");
  return StopListeningIncomingConnectionError_Name(static_cast<StopListeningIncomingConnectionError>(value));
}
const std::string& StopListeningIncomingConnectionError_Name(StopListeningIncomingConnectionError value);
bool StopListeningIncomingConnectionError_Parse(absl::string_view name, StopListeningIncomingConnectionError* value);
enum ConnectError : int {
  UNEXPECT_TARGET_LOST = 31,
  ESTABLISH_GATT_CONNECTION_FAILED = 32,
  ESTABLISH_L2CAP_CONNECTION_FAILED = 33,
  INVALID_MAC_ADDRESS = 34,
  SLEEP_BEFORE_CONNECT_GATT_INTERRUPTED = 35,
  SLEEP_AFTER_GATT_CONNECTED_INTERRUPTED = 36,
  REQUEST_GATT_CONNECTION_PRIORITY_FAILED = 37,
  L2CAP_SWITCH_TO_DATA_TRANSFERRING_FAILED = 38,
  GATT_SWITCH_TO_DATA_TRANSFERRING_FAILED = 39,
  ESTABLISH_CONNECTION_FAILED = 40,
  DUPLICATE_CONNECTION_REQUESTED = 41,
  CONNECTION_LOST = 42,
  CONNECT_TO_NETWORK_FAILED = 43,
  UNKNOWN_CONNECT_ERROR = 44,
  CONNECT_SEND_AWARE_L2_MESSAGE_FAILED = 45,
  CONNECT_READ_AWARE_L2_MESSAGE_FAILED = 46,
};

bool ConnectError_IsValid(int value);
constexpr ConnectError ConnectError_MIN = static_cast<ConnectError>(31);
constexpr ConnectError ConnectError_MAX = static_cast<ConnectError>(46);
constexpr int ConnectError_ARRAYSIZE = 46 + 1;
const std::string& ConnectError_Name(ConnectError value);
template <typename T>
const std::string& ConnectError_Name(T value) {
  static_assert(std::is_same<T, ConnectError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConnectError_Name().");
  return ConnectError_Name(static_cast<ConnectError>(value));
}
const std::string& ConnectError_Name(ConnectError value);
bool ConnectError_Parse(absl::string_view name, ConnectError* value);
enum DisconnectError : int {
  DISCONNECT_NETWORK_FAILED = 31,
  UNKNOWN_DISCONNECT_ERROR = 32,
};

bool DisconnectError_IsValid(int value);
constexpr DisconnectError DisconnectError_MIN = static_cast<DisconnectError>(31);
constexpr DisconnectError DisconnectError_MAX = static_cast<DisconnectError>(32);
constexpr int DisconnectError_ARRAYSIZE = 32 + 1;
const std::string& DisconnectError_Name(DisconnectError value);
template <typename T>
const std::string& DisconnectError_Name(T value) {
  static_assert(std::is_same<T, DisconnectError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DisconnectError_Name().");
  return DisconnectError_Name(static_cast<DisconnectError>(value));
}
const std::string& DisconnectError_Name(DisconnectError value);
bool DisconnectError_Parse(absl::string_view name, DisconnectError* value);
enum SendPayloadError : int {
  UNKNOWN_SEND_PAYLOAD_ERROR = 31,
  SEND_PAYLOAD_FAILED = 32,
};

bool SendPayloadError_IsValid(int value);
constexpr SendPayloadError SendPayloadError_MIN = static_cast<SendPayloadError>(31);
constexpr SendPayloadError SendPayloadError_MAX = static_cast<SendPayloadError>(32);
constexpr int SendPayloadError_ARRAYSIZE = 32 + 1;
const std::string& SendPayloadError_Name(SendPayloadError value);
template <typename T>
const std::string& SendPayloadError_Name(T value) {
  static_assert(std::is_same<T, SendPayloadError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SendPayloadError_Name().");
  return SendPayloadError_Name(static_cast<SendPayloadError>(value));
}
const std::string& SendPayloadError_Name(SendPayloadError value);
bool SendPayloadError_Parse(absl::string_view name, SendPayloadError* value);
enum ReceivePayloadError : int {
  UNKNOWN_RECEIVE_PAYLOAD_ERROR = 31,
  RECEIVE_PAYLOAD_FAILED = 32,
};

bool ReceivePayloadError_IsValid(int value);
constexpr ReceivePayloadError ReceivePayloadError_MIN = static_cast<ReceivePayloadError>(31);
constexpr ReceivePayloadError ReceivePayloadError_MAX = static_cast<ReceivePayloadError>(32);
constexpr int ReceivePayloadError_ARRAYSIZE = 32 + 1;
const std::string& ReceivePayloadError_Name(ReceivePayloadError value);
template <typename T>
const std::string& ReceivePayloadError_Name(T value) {
  static_assert(std::is_same<T, ReceivePayloadError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReceivePayloadError_Name().");
  return ReceivePayloadError_Name(static_cast<ReceivePayloadError>(value));
}
const std::string& ReceivePayloadError_Name(ReceivePayloadError value);
bool ReceivePayloadError_Parse(absl::string_view name, ReceivePayloadError* value);
enum UpgradeError : int {
  UNKNOWN_UPGRADE_ERROR = 31,
  CREATE_P2P_GROUP_FAILED = 32,
};

bool UpgradeError_IsValid(int value);
constexpr UpgradeError UpgradeError_MIN = static_cast<UpgradeError>(31);
constexpr UpgradeError UpgradeError_MAX = static_cast<UpgradeError>(32);
constexpr int UpgradeError_ARRAYSIZE = 32 + 1;
const std::string& UpgradeError_Name(UpgradeError value);
template <typename T>
const std::string& UpgradeError_Name(T value) {
  static_assert(std::is_same<T, UpgradeError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UpgradeError_Name().");
  return UpgradeError_Name(static_cast<UpgradeError>(value));
}
const std::string& UpgradeError_Name(UpgradeError value);
bool UpgradeError_Parse(absl::string_view name, UpgradeError* value);
enum AcceptConnectionError : int {
  UNKNOWN_ACCEPT_CONNECTION_ERROR = 31,
  RESPOND_ACCEPT_CONNECTION_FAILED = 32,
};

bool AcceptConnectionError_IsValid(int value);
constexpr AcceptConnectionError AcceptConnectionError_MIN = static_cast<AcceptConnectionError>(31);
constexpr AcceptConnectionError AcceptConnectionError_MAX = static_cast<AcceptConnectionError>(32);
constexpr int AcceptConnectionError_ARRAYSIZE = 32 + 1;
const std::string& AcceptConnectionError_Name(AcceptConnectionError value);
template <typename T>
const std::string& AcceptConnectionError_Name(T value) {
  static_assert(std::is_same<T, AcceptConnectionError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AcceptConnectionError_Name().");
  return AcceptConnectionError_Name(static_cast<AcceptConnectionError>(value));
}
const std::string& AcceptConnectionError_Name(AcceptConnectionError value);
bool AcceptConnectionError_Parse(absl::string_view name, AcceptConnectionError* value);
enum RejectConnectionError : int {
  UNKNOWN_REJECT_CONNECTION_ERROR = 31,
  RESPOND_REJECT_CONNECTION_FAILED = 32,
};

bool RejectConnectionError_IsValid(int value);
constexpr RejectConnectionError RejectConnectionError_MIN = static_cast<RejectConnectionError>(31);
constexpr RejectConnectionError RejectConnectionError_MAX = static_cast<RejectConnectionError>(32);
constexpr int RejectConnectionError_ARRAYSIZE = 32 + 1;
const std::string& RejectConnectionError_Name(RejectConnectionError value);
template <typename T>
const std::string& RejectConnectionError_Name(T value) {
  static_assert(std::is_same<T, RejectConnectionError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RejectConnectionError_Name().");
  return RejectConnectionError_Name(static_cast<RejectConnectionError>(value));
}
const std::string& RejectConnectionError_Name(RejectConnectionError value);
bool RejectConnectionError_Parse(absl::string_view name, RejectConnectionError* value);
enum Description : int {
  UNKNOWN = 0,
  NULL_SERVICE_ID = 1,
  NULL_ADVERTISEMENT_BYTES = 2,
  CONNECTIONS_FEATURE_DISABLED = 3,
  STALE_SDK_VERSION = 4,
  FEATURE_BLUETOOTH_NOT_SUPPORTED = 5,
  FEATURE_BLUETOOTH_LE_NOT_SUPPORTED = 6,
  NULL_BLUETOOTH_MANAGER = 7,
  NULL_BLUETOOTH_ADAPTER = 8,
  INVALID_FAST_PAIR_MODEL_ID = 9,
  INVALID_FAST_ADVERTISEMENT_DATA = 10,
  INVALID_ADVERTISEMENT_HEADER_DATA = 11,
  INVALID_REGULAR_ADVERTISEMENT_DATA = 12,
  NULL_BLUETOOTH_LE_ADVERTISER_COMPAT = 13,
  ADVERTISE_FAILED_ALREADY_STARTED = 14,
  ADVERTISE_FAILED_DATA_TOO_LARGE = 15,
  ADVERTISE_FAILED_FEATURE_UNSUPPORTED = 16,
  ADVERTISE_FAILED_INTERNAL_ERROR = 17,
  ADVERTISE_FAILED_TOO_MANY_ADVERTISERS = 18,
  INTERRUPTED_EXCEPTION = 19,
  EXECUTION_EXCEPTION = 20,
  NULL_BLUETOOTH_DEVICE_NAME = 21,
  SET_SCAN_MODE_FAILED = 22,
  INVOKE_API_FAILED = 23,
  TIMEOUT = 24,
  NULL_NFC_TAG = 25,
  FEATURE_NFC_NOT_SUPPORTED = 26,
  FEATURE_NFC_HOST_CARD_EMULATION_NOT_SUPPORTED = 27,
  MULTICAST_NOT_SUPPORTED = 30,
  NSD_NOT_ENABLED = 31,
  INVALID_PORT_NUMBER = 32,
  NULL_SERVICE_NAME = 33,
  NULL_SERVICE_TYPE = 34,
  WITHOUT_CONNECTED_WIFI_NETWORK = 35,
  FEATURE_WIFI_AWARE_NOT_SUPPORTED = 36,
  NULL_CONNECTIVITY_MANAGER = 37,
  NULL_WIFI_AWARE_MANAGER = 38,
  STALE_ANDROID_VERSION = 39,
  NULL_SERVICE_INFO = 40,
  NULL_WORK_SOURCE = 41,
  NULL_CALLBACK = 42,
  NULL_BLUETOOTH_LE_SCANNER_COMPAT = 43,
  EMPTY_WORK_SOURCE_CACHE = 44,
  SCAN_FAILED_ALREADY_STARTED = 45,
  SCAN_FAILED_APPLICATION_REGISTRATION_FAILED = 46,
  SCAN_FAILED_INTERNAL_ERROR = 47,
  SCAN_FAILED_FEATURE_UNSUPPORTED = 48,
  SCAN_FAILED_BLUETOOTH_DISABLED = 49,
  SCAN_FILTERS_NOT_ALLOWED_FOR_LOCATION = 50,
  BLUETOOTH_SCAN_REJUVENATE_FAILED = 51,
  NULL_BLE_PERIPHERAL = 52,
  NULL_BLUETOOTH_GATT = 53,
  UNEXPECTED_BLUETOOTH_STATE = 54,
  REMOTE_EXCEPTION = 55,
  INVALID_BLUETOOTH_SOCKET_STATE_BEFORE_CONNECT = 56,
  BLUETOOTH_SOCKET_CLOSED_AFTER_CONNECTED = 57,
  INVALID_BLUETOOTH_CHANNEL = 58,
  NULL_BLUETOOTH_DEVICE = 59,
  NULL_BLUETOOTH_PROXY = 60,
  INVALID_PACKET_LENGTH = 61,
  INVALID_PACKET_BYTES = 62,
  UNEXPECTED_EOF_EXCEPTION = 63,
  SOCKET_CLOSED_OR_TIMEOUT = 64,
  INVALID_IPV4_ADDRESS = 65,
  INVALID_IPV6_ADDRESS = 66,
  NULL_ADDRESS = 67,
  INVALID_VERSION = 68,
  SET_CONNECTION_PRIORITY_FAILED = 69,
  SET_CONNECTION_PRIORITY_INTERRUPTED = 70,
  UNKNOWN_IO_EXCEPTION = 71,
  READ_CHARACTERISTIC_FAILED = 72,
  WIFI_HOTSPOT_ENABLED = 73,
  AWARE_UNAVAILABLE = 74,
  IN_BLACK_LIST = 75,
  FEATURE_WIFI_NOT_SUPPORTED = 76,
  NULL_WIFI_MANAGER = 77,
  SOCKET_CLOSED = 78,
  SOCKET_ALREADY_CONNECTED = 79,
  NFC_TECH_NOT_SUPPORTED = 80,
  NFC_SERVICE_DIED = 81,
  BIND_NFC_SERVICE_FAILED = 82,
  NFC_CREATE_SOCKET_FAILED = 83,
  NULL_WIFI_AWARE_PEER = 84,
  NETWORK_ALREADY_JOINED = 85,
  JOIN_AWARE_NETWORK_CANCELLED = 86,
  NETWORK_UNAVAILABLE = 87,
  WITHOUT_ACTIVE_AWARE_NETWORK = 88,
  WITHOUT_JOINED_AWARE_NETWORK = 89,
  CONNET_TO_SOCKET_CANCELLED = 90,
  NULL_SSID = 91,
  NULL_PASSWORD = 92,
  FEATURE_WIFI_DIRECT_NOT_SUPPORTED = 93,
  NULL_WIFI_P2P_MANAGER = 94,
  P2P_GROUP_FORMED = 95,
  ACQUIRE_P2P_CHANNEL_FAILED = 96,
  P2P_UNSUPPORTED = 97,
  INTERNAL_ERROR = 98,
  BUSY = 99,
  REFLECTION_ERROR = 100,
  NETWORK_ERROR_EHOSTUNREACH = 101,
  NETWORK_ERROR_ENETUNREACH = 102,
  ADD_NETWORK_FAILED = 103,
  UPDATE_NETWORK_FAILED = 104,
  ALREADY_IN_PROGRESS = 105,
  INVALID_ARGS = 106,
  NOT_AUTHORIZED = 107,
  INVALID_NETWORK_ID = 108,
  WIFI_MANAGER_ENABLE_NETWORK_FAILED = 109,
  WIFI_MANAGER_RECONNECT_FAILED = 110,
  WITHOUT_ACTIVE_NETWORK = 111,
  WEBRTC_CONNECTION_FLOW_EXIST = 112,
  NULL_DROID_GUARD_RESULT = 113,
  TACHYON_SIGNALING_MESSENGER_EXIST = 114,
  TACHYON_ALREADY_START_RECEIVE_MESSAGE = 115,
  TACHYON_RECEIVE_MESSAGE_FAILED = 116,
  TACHYON_RECEIVE_MESSAGE_INTERRUPTED = 117,
  TACHYON_RECEIVE_MESSAGE_EXECUTION_EXCEPTION = 118,
  TACHYON_RECEIVE_MESSAGE_TIMEOUT = 119,
  TACHYON_RECEIVE_MESSAGE_AUTH_EXCEPTION = 120,
  TACHYON_RECEIVE_MESSAGE_STATUS_EXCEPTION = 121,
  TACHYON_SEND_MESSAGE_AUTH_EXCEPTION = 122,
  TACHYON_SEND_MESSAGE_STATUS_EXCEPTION = 123,
  TACHYON_GET_ICE_SERVER_AUTH_EXCEPTION = 124,
  TACHYON_GET_ICE_SERVER_STATUS_EXCEPTION = 125,
  EMPTY_TACHYON_ICE_SERVER = 126,
  POTENTIAL_WEBRTC_LIB_LOADING_FAILURE = 127,
  UNEXPECTED_GATT_DESCRIPTOR = 128,
  FAIL_TO_RECEIVE_L2CAP_PACKET = 129,
  WITHOUT_PSM_VALUE = 130,
  SOCKET_BIND_LISTEN_FAILED = 131,
  UNEXPECTED_PACKET_CONTENT = 132,
  UNREGISTER_NSD_MANAGER_FAILED = 133,
  PUBLISH_EMPTY_ADVERTISEMENT_FAILED = 134,
  BLUETOOTH_SOCKET_NOT_IN_LISTENING_STATE = 135,
  INVALID_BLUETOOTH_SOCKET_SIGNAL_SIZE = 136,
  INVALID_BLUETOOTH_SOCKET_SIGNAL_STATUS = 137,
  GET_ADDRESS_FAILED = 138,
  NULL_LOCAL_ADDRESS = 139,
  IS_LOOPBACK_ADDRESS = 140,
  SOCKET_NOT_BOUND = 141,
  INVALID_REMOTE_ADDRESS = 142,
  SOCKET_ALREADY_BOUND = 143,
  HOTSPOT_NOT_STARTED = 144,
  WEBRTC_ALREADY_INITIALIZED = 145,
  INVALID_WEBRTC_STATE = 146,
  NULL_DATA_CHANNEL = 147,
  CREATE_OFFER_FAILED = 148,
  CLOSE_SERVER_SOCKET_FAILED = 149,
  WIFI_AWARE_STARTED = 150,
  AWARE_PUBLISH_SESSION_RAN_OUT = 151,
  AWARE_SUBSCRIBE_SESSION_RAN_OUT = 152,
  AWARE_DATA_PATH_RAN_OUT = 153,
  WIFI_SIGNAL_STRENGTH_POOR = 154,
  POTENTIAL_SRD_ISSUE = 155,
  AWARE_L2_MESSAGE_HOST_NETWORK_ERROR = 156,
  AWARE_L2_MESSAGE_NETWORK_AVAILABLE_ERROR = 157,
  AWARE_L2_MESSAGE_IP_AVAILABLE_ERROR = 158,
  AWARE_L2_MESSAGE_CANCELLATION_RECEIVED = 159,
  TIE_BREAK_LOSER = 160,
  SERVER_SOCKET_UNAVAILABLE = 161,
  HOSTED_NETWORK_UNAVAILABLE = 162,
  AWARE_UPDATE_PUBLISHING_CONFIG_FAILED = 163,
  L2CAP_UNAVAILABLE = 164,
  ALREADY_HAS_GATT_CONNECTION = 165,
  UNSUPPORTED_DEVICE_TYPE = 166,
  UNSUPPORTED_DEVICE_TYPE_CHROME_OS = 167,
  UNSUPPORTED_DEVICE_TYPE_AUTO = 168,
  UNSUPPORTED_DEVICE_TYPE_TV = 169,
  UNSUPPORTED_DEVICE_TYPE_WEAR = 170,
  NULL_MESSAGE = 171,
  USER_RESTRICTION_DISALLOWED = 172,
  UNSUPPORTED_DEVICE_TYPE_PHONE = 173,
  UNSUPPORTED_DEVICE_TYPE_TABLET = 174,
  BROKEN_PIPE = 175,
  CONNECTION_ABORT = 176,
  FEATURE_USB_HOST_NOT_SUPPORTED = 177,
  FEATURE_USB_ACCESSORY_NOT_SUPPORTED = 178,
  FEATURE_USB_PORTS_NOT_FOUND = 179,
  MULTIPLEX_SOCKET_UNKNOWN_ERROR = 180,
  MULTIPLEX_SOCKET_NOT_LISTENING = 181,
  MULTIPLEX_SOCKET_DISABLED = 182,
  MULTIPLEX_SOCKET_TIMEOUT = 183,
  MULTIPLEX_SOCKET_IOEXCEPTION = 184,
  MULTIPLEX_SOCKET_UNKNOWN_RESPONSE_CODE = 185,
  MULTIPLEX_SOCKET_EXECUTION_EXCEPTION = 186,
  MULTIPLEX_SOCKET_INTERRUPTED_EXCEPTION = 187,
};

bool Description_IsValid(int value);
constexpr Description Description_MIN = static_cast<Description>(0);
constexpr Description Description_MAX = static_cast<Description>(187);
constexpr int Description_ARRAYSIZE = 187 + 1;
const std::string& Description_Name(Description value);
template <typename T>
const std::string& Description_Name(T value) {
  static_assert(std::is_same<T, Description>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Description_Name().");
  return Description_Name(static_cast<Description>(value));
}
const std::string& Description_Name(Description value);
bool Description_Parse(absl::string_view name, Description* value);

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace errorcode
}  // namespace nearby
}  // namespace location


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::location::nearby::errorcode::proto::ErrorType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::Event> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::CommonError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::StartAdvertisingError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::StopAdvertisingError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::StartDiscoveringError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::StopDiscoveringError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::StartListeningIncomingConnectionError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::StopListeningIncomingConnectionError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::ConnectError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::DisconnectError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::SendPayloadError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::ReceivePayloadError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::UpgradeError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::AcceptConnectionError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::RejectConnectionError> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::errorcode::proto::Description> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2ferrorcode_2ferror_5fcode_5fenums_2eproto_2epb_2eh
