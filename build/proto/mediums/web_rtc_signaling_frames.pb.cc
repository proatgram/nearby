// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/mediums/web_rtc_signaling_frames.proto

#include "proto/mediums/web_rtc_signaling_frames.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace location {
namespace nearby {
namespace mediums {
PROTOBUF_CONSTEXPR WebRtcSignalingFrame::WebRtcSignalingFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sender_id_)*/nullptr
  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_.Frame_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct WebRtcSignalingFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WebRtcSignalingFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WebRtcSignalingFrameDefaultTypeInternal() {}
  union {
    WebRtcSignalingFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebRtcSignalingFrameDefaultTypeInternal _WebRtcSignalingFrame_default_instance_;
PROTOBUF_CONSTEXPR PeerId::PeerId(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct PeerIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeerIdDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeerIdDefaultTypeInternal() {}
  union {
    PeerId _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeerIdDefaultTypeInternal _PeerId_default_instance_;
PROTOBUF_CONSTEXPR SessionDescription::SessionDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.description_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct SessionDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SessionDescriptionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SessionDescriptionDefaultTypeInternal() {}
  union {
    SessionDescription _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionDescriptionDefaultTypeInternal _SessionDescription_default_instance_;
PROTOBUF_CONSTEXPR IceCandidate::IceCandidate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sdp_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.sdp_mid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.sdp_m_line_index_)*/ 0
} {}
struct IceCandidateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IceCandidateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IceCandidateDefaultTypeInternal() {}
  union {
    IceCandidate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IceCandidateDefaultTypeInternal _IceCandidate_default_instance_;
PROTOBUF_CONSTEXPR IceCandidates::IceCandidates(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ice_candidates_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IceCandidatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IceCandidatesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IceCandidatesDefaultTypeInternal() {}
  union {
    IceCandidates _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IceCandidatesDefaultTypeInternal _IceCandidates_default_instance_;
PROTOBUF_CONSTEXPR Offer::Offer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.session_description_)*/nullptr} {}
struct OfferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfferDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfferDefaultTypeInternal() {}
  union {
    Offer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfferDefaultTypeInternal _Offer_default_instance_;
PROTOBUF_CONSTEXPR Answer::Answer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.session_description_)*/nullptr} {}
struct AnswerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnswerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnswerDefaultTypeInternal() {}
  union {
    Answer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnswerDefaultTypeInternal _Answer_default_instance_;
PROTOBUF_CONSTEXPR ReadyForSignalingPoke::ReadyForSignalingPoke(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._cached_size_)*/{}} {}
struct ReadyForSignalingPokeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadyForSignalingPokeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadyForSignalingPokeDefaultTypeInternal() {}
  union {
    ReadyForSignalingPoke _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadyForSignalingPokeDefaultTypeInternal _ReadyForSignalingPoke_default_instance_;
}  // namespace mediums
}  // namespace nearby
}  // namespace location
namespace location {
namespace nearby {
namespace mediums {
bool WebRtcSignalingFrame_FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    WebRtcSignalingFrame_FrameType_strings[5] = {};

static const char WebRtcSignalingFrame_FrameType_names[] = {
    "ANSWER_TYPE"
    "ICE_CANDIDATES_TYPE"
    "OFFER_TYPE"
    "READY_FOR_SIGNALING_POKE_TYPE"
    "UNKNOWN_FRAME_TYPE"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WebRtcSignalingFrame_FrameType_entries[] =
    {
        {{&WebRtcSignalingFrame_FrameType_names[0], 11}, 2},
        {{&WebRtcSignalingFrame_FrameType_names[11], 19}, 3},
        {{&WebRtcSignalingFrame_FrameType_names[30], 10}, 1},
        {{&WebRtcSignalingFrame_FrameType_names[40], 29}, 4},
        {{&WebRtcSignalingFrame_FrameType_names[69], 18}, 0},
};

static const int WebRtcSignalingFrame_FrameType_entries_by_number[] = {
    4,  // 0 -> UNKNOWN_FRAME_TYPE
    2,  // 1 -> OFFER_TYPE
    0,  // 2 -> ANSWER_TYPE
    1,  // 3 -> ICE_CANDIDATES_TYPE
    3,  // 4 -> READY_FOR_SIGNALING_POKE_TYPE
};

const std::string& WebRtcSignalingFrame_FrameType_Name(WebRtcSignalingFrame_FrameType value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WebRtcSignalingFrame_FrameType_entries, WebRtcSignalingFrame_FrameType_entries_by_number,
          5, WebRtcSignalingFrame_FrameType_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WebRtcSignalingFrame_FrameType_entries, WebRtcSignalingFrame_FrameType_entries_by_number, 5,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : WebRtcSignalingFrame_FrameType_strings[idx].get();
}

bool WebRtcSignalingFrame_FrameType_Parse(absl::string_view name, WebRtcSignalingFrame_FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WebRtcSignalingFrame_FrameType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<WebRtcSignalingFrame_FrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::UNKNOWN_FRAME_TYPE;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::OFFER_TYPE;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::ANSWER_TYPE;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::ICE_CANDIDATES_TYPE;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::READY_FOR_SIGNALING_POKE_TYPE;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::FrameType_MIN;
constexpr WebRtcSignalingFrame_FrameType WebRtcSignalingFrame::FrameType_MAX;
constexpr int WebRtcSignalingFrame::FrameType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class WebRtcSignalingFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<WebRtcSignalingFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WebRtcSignalingFrame, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::location::nearby::mediums::WebRtcSignalingFrame, _impl_._oneof_case_);
  static const ::location::nearby::mediums::PeerId& sender_id(const WebRtcSignalingFrame* msg);
  static void set_has_sender_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::location::nearby::mediums::Offer& offer(const WebRtcSignalingFrame* msg);
  static const ::location::nearby::mediums::Answer& answer(const WebRtcSignalingFrame* msg);
  static const ::location::nearby::mediums::IceCandidates& ice_candidates(const WebRtcSignalingFrame* msg);
  static const ::location::nearby::mediums::ReadyForSignalingPoke& ready_for_signaling_poke(const WebRtcSignalingFrame* msg);
};

const ::location::nearby::mediums::PeerId&
WebRtcSignalingFrame::_Internal::sender_id(const WebRtcSignalingFrame* msg) {
  return *msg->_impl_.sender_id_;
}
const ::location::nearby::mediums::Offer&
WebRtcSignalingFrame::_Internal::offer(const WebRtcSignalingFrame* msg) {
  return *msg->_impl_.Frame_.offer_;
}
const ::location::nearby::mediums::Answer&
WebRtcSignalingFrame::_Internal::answer(const WebRtcSignalingFrame* msg) {
  return *msg->_impl_.Frame_.answer_;
}
const ::location::nearby::mediums::IceCandidates&
WebRtcSignalingFrame::_Internal::ice_candidates(const WebRtcSignalingFrame* msg) {
  return *msg->_impl_.Frame_.ice_candidates_;
}
const ::location::nearby::mediums::ReadyForSignalingPoke&
WebRtcSignalingFrame::_Internal::ready_for_signaling_poke(const WebRtcSignalingFrame* msg) {
  return *msg->_impl_.Frame_.ready_for_signaling_poke_;
}
void WebRtcSignalingFrame::set_allocated_offer(::location::nearby::mediums::Offer* offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Frame();
  if (offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offer);
    if (message_arena != submessage_arena) {
      offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offer, submessage_arena);
    }
    set_has_offer();
    _impl_.Frame_.offer_ = offer;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.offer)
}
void WebRtcSignalingFrame::set_allocated_answer(::location::nearby::mediums::Answer* answer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Frame();
  if (answer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(answer);
    if (message_arena != submessage_arena) {
      answer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, answer, submessage_arena);
    }
    set_has_answer();
    _impl_.Frame_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.answer)
}
void WebRtcSignalingFrame::set_allocated_ice_candidates(::location::nearby::mediums::IceCandidates* ice_candidates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Frame();
  if (ice_candidates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ice_candidates);
    if (message_arena != submessage_arena) {
      ice_candidates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ice_candidates, submessage_arena);
    }
    set_has_ice_candidates();
    _impl_.Frame_.ice_candidates_ = ice_candidates;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.ice_candidates)
}
void WebRtcSignalingFrame::set_allocated_ready_for_signaling_poke(::location::nearby::mediums::ReadyForSignalingPoke* ready_for_signaling_poke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Frame();
  if (ready_for_signaling_poke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ready_for_signaling_poke);
    if (message_arena != submessage_arena) {
      ready_for_signaling_poke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ready_for_signaling_poke, submessage_arena);
    }
    set_has_ready_for_signaling_poke();
    _impl_.Frame_.ready_for_signaling_poke_ = ready_for_signaling_poke;
  }
  // @@protoc_insertion_point(field_set_allocated:location.nearby.mediums.WebRtcSignalingFrame.ready_for_signaling_poke)
}
WebRtcSignalingFrame::WebRtcSignalingFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.WebRtcSignalingFrame)
}
WebRtcSignalingFrame::WebRtcSignalingFrame(const WebRtcSignalingFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WebRtcSignalingFrame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_id_){nullptr}
    , decltype(_impl_.type_) {}

    , decltype(_impl_.Frame_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.sender_id_ = new ::location::nearby::mediums::PeerId(*from._impl_.sender_id_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  clear_has_Frame();
  switch (from.Frame_case()) {
    case kOffer: {
      _this->_internal_mutable_offer()->::location::nearby::mediums::Offer::MergeFrom(
          from._internal_offer());
      break;
    }
    case kAnswer: {
      _this->_internal_mutable_answer()->::location::nearby::mediums::Answer::MergeFrom(
          from._internal_answer());
      break;
    }
    case kIceCandidates: {
      _this->_internal_mutable_ice_candidates()->::location::nearby::mediums::IceCandidates::MergeFrom(
          from._internal_ice_candidates());
      break;
    }
    case kReadyForSignalingPoke: {
      _this->_internal_mutable_ready_for_signaling_poke()->::location::nearby::mediums::ReadyForSignalingPoke::MergeFrom(
          from._internal_ready_for_signaling_poke());
      break;
    }
    case FRAME_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.WebRtcSignalingFrame)
}

inline void WebRtcSignalingFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_id_){nullptr}
    , decltype(_impl_.type_) { 0 }

    , decltype(_impl_.Frame_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_Frame();
}

WebRtcSignalingFrame::~WebRtcSignalingFrame() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.WebRtcSignalingFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WebRtcSignalingFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sender_id_;
  if (has_Frame()) {
    clear_Frame();
  }
}

void WebRtcSignalingFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WebRtcSignalingFrame::clear_Frame() {
// @@protoc_insertion_point(one_of_clear_start:location.nearby.mediums.WebRtcSignalingFrame)
  switch (Frame_case()) {
    case kOffer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Frame_.offer_;
      }
      break;
    }
    case kAnswer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Frame_.answer_;
      }
      break;
    }
    case kIceCandidates: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Frame_.ice_candidates_;
      }
      break;
    }
    case kReadyForSignalingPoke: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Frame_.ready_for_signaling_poke_;
      }
      break;
    }
    case FRAME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = FRAME_NOT_SET;
}


void WebRtcSignalingFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.WebRtcSignalingFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.sender_id_ != nullptr);
    _impl_.sender_id_->Clear();
  }
  _impl_.type_ = 0;
  clear_Frame();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WebRtcSignalingFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.mediums.PeerId sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sender_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.mediums.WebRtcSignalingFrame.FrameType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::mediums::WebRtcSignalingFrame_FrameType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::location::nearby::mediums::WebRtcSignalingFrame_FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.mediums.Offer offer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_offer(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.mediums.Answer answer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_answer(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.mediums.IceCandidates ice_candidates = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ice_candidates(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .location.nearby.mediums.ReadyForSignalingPoke ready_for_signaling_poke = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ready_for_signaling_poke(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WebRtcSignalingFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.WebRtcSignalingFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.mediums.PeerId sender_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sender_id(this),
        _Internal::sender_id(this).GetCachedSize(), target, stream);
  }

  // optional .location.nearby.mediums.WebRtcSignalingFrame.FrameType type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_type(), target);
  }

  switch (Frame_case()) {
    case kOffer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::offer(this),
          _Internal::offer(this).GetCachedSize(), target, stream);
      break;
    }
    case kAnswer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::answer(this),
          _Internal::answer(this).GetCachedSize(), target, stream);
      break;
    }
    case kIceCandidates: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::ice_candidates(this),
          _Internal::ice_candidates(this).GetCachedSize(), target, stream);
      break;
    }
    case kReadyForSignalingPoke: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::ready_for_signaling_poke(this),
          _Internal::ready_for_signaling_poke(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.WebRtcSignalingFrame)
  return target;
}

::size_t WebRtcSignalingFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.WebRtcSignalingFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .location.nearby.mediums.PeerId sender_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sender_id_);
    }

    // optional .location.nearby.mediums.WebRtcSignalingFrame.FrameType type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  switch (Frame_case()) {
    // .location.nearby.mediums.Offer offer = 3;
    case kOffer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Frame_.offer_);
      break;
    }
    // .location.nearby.mediums.Answer answer = 4;
    case kAnswer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Frame_.answer_);
      break;
    }
    // .location.nearby.mediums.IceCandidates ice_candidates = 5;
    case kIceCandidates: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Frame_.ice_candidates_);
      break;
    }
    // .location.nearby.mediums.ReadyForSignalingPoke ready_for_signaling_poke = 6;
    case kReadyForSignalingPoke: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Frame_.ready_for_signaling_poke_);
      break;
    }
    case FRAME_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WebRtcSignalingFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WebRtcSignalingFrame*>(
      &from));
}

void WebRtcSignalingFrame::MergeFrom(const WebRtcSignalingFrame& from) {
  WebRtcSignalingFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.WebRtcSignalingFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sender_id()->::location::nearby::mediums::PeerId::MergeFrom(
          from._internal_sender_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.Frame_case()) {
    case kOffer: {
      _this->_internal_mutable_offer()->::location::nearby::mediums::Offer::MergeFrom(
          from._internal_offer());
      break;
    }
    case kAnswer: {
      _this->_internal_mutable_answer()->::location::nearby::mediums::Answer::MergeFrom(
          from._internal_answer());
      break;
    }
    case kIceCandidates: {
      _this->_internal_mutable_ice_candidates()->::location::nearby::mediums::IceCandidates::MergeFrom(
          from._internal_ice_candidates());
      break;
    }
    case kReadyForSignalingPoke: {
      _this->_internal_mutable_ready_for_signaling_poke()->::location::nearby::mediums::ReadyForSignalingPoke::MergeFrom(
          from._internal_ready_for_signaling_poke());
      break;
    }
    case FRAME_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebRtcSignalingFrame::CopyFrom(const WebRtcSignalingFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.WebRtcSignalingFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WebRtcSignalingFrame::IsInitialized() const {
  return true;
}

void WebRtcSignalingFrame::InternalSwap(WebRtcSignalingFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WebRtcSignalingFrame, _impl_.type_)
      + sizeof(WebRtcSignalingFrame::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(WebRtcSignalingFrame, _impl_.sender_id_)>(
          reinterpret_cast<char*>(&_impl_.sender_id_),
          reinterpret_cast<char*>(&other->_impl_.sender_id_));
  swap(_impl_.Frame_, other->_impl_.Frame_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string WebRtcSignalingFrame::GetTypeName() const {
  return "location.nearby.mediums.WebRtcSignalingFrame";
}

// ===================================================================

class PeerId::_Internal {
 public:
  using HasBits = decltype(std::declval<PeerId>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PeerId, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PeerId::PeerId(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.PeerId)
}
PeerId::PeerId(const PeerId& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PeerId* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.PeerId)
}

inline void PeerId::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PeerId::~PeerId() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.PeerId)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PeerId::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
}

void PeerId::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PeerId::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.PeerId)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PeerId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PeerId::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.PeerId)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.PeerId)
  return target;
}

::size_t PeerId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.PeerId)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PeerId::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PeerId*>(
      &from));
}

void PeerId::MergeFrom(const PeerId& from) {
  PeerId* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.PeerId)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PeerId::CopyFrom(const PeerId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.PeerId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerId::IsInitialized() const {
  return true;
}

void PeerId::InternalSwap(PeerId* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
}

std::string PeerId::GetTypeName() const {
  return "location.nearby.mediums.PeerId";
}

// ===================================================================

class SessionDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<SessionDescription>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SessionDescription, _impl_._has_bits_);
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SessionDescription::SessionDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.SessionDescription)
}
SessionDescription::SessionDescription(const SessionDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SessionDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.SessionDescription)
}

inline void SessionDescription::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.description_) {}

  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SessionDescription::~SessionDescription() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.SessionDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SessionDescription::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.description_.Destroy();
}

void SessionDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SessionDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.SessionDescription)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.description_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SessionDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SessionDescription::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.SessionDescription)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string description = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_description();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.SessionDescription)
  return target;
}

::size_t SessionDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.SessionDescription)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string description = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SessionDescription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SessionDescription*>(
      &from));
}

void SessionDescription::MergeFrom(const SessionDescription& from) {
  SessionDescription* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.SessionDescription)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_description(from._internal_description());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionDescription::CopyFrom(const SessionDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.SessionDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionDescription::IsInitialized() const {
  return true;
}

void SessionDescription::InternalSwap(SessionDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena,
                                       &other->_impl_.description_, rhs_arena);
}

std::string SessionDescription::GetTypeName() const {
  return "location.nearby.mediums.SessionDescription";
}

// ===================================================================

class IceCandidate::_Internal {
 public:
  using HasBits = decltype(std::declval<IceCandidate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IceCandidate, _impl_._has_bits_);
  static void set_has_sdp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sdp_mid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sdp_m_line_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IceCandidate::IceCandidate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.IceCandidate)
}
IceCandidate::IceCandidate(const IceCandidate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IceCandidate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sdp_) {}

    , decltype(_impl_.sdp_mid_) {}

    , decltype(_impl_.sdp_m_line_index_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.sdp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sdp_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.sdp_.Set(from._internal_sdp(), _this->GetArenaForAllocation());
  }
  _impl_.sdp_mid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sdp_mid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.sdp_mid_.Set(from._internal_sdp_mid(), _this->GetArenaForAllocation());
  }
  _this->_impl_.sdp_m_line_index_ = from._impl_.sdp_m_line_index_;
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.IceCandidate)
}

inline void IceCandidate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sdp_) {}

    , decltype(_impl_.sdp_mid_) {}

    , decltype(_impl_.sdp_m_line_index_) { 0 }

  };
  _impl_.sdp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sdp_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sdp_mid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.sdp_mid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IceCandidate::~IceCandidate() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.IceCandidate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IceCandidate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sdp_.Destroy();
  _impl_.sdp_mid_.Destroy();
}

void IceCandidate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IceCandidate::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.IceCandidate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sdp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sdp_mid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.sdp_m_line_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IceCandidate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sdp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sdp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string sdp_mid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sdp_mid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 sdp_m_line_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_sdp_m_line_index(&has_bits);
          _impl_.sdp_m_line_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IceCandidate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.IceCandidate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string sdp = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_sdp();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string sdp_mid = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_sdp_mid();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 sdp_m_line_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_sdp_m_line_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.IceCandidate)
  return target;
}

::size_t IceCandidate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.IceCandidate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sdp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_sdp());
    }

    // optional string sdp_mid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_sdp_mid());
    }

    // optional int32 sdp_m_line_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_sdp_m_line_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IceCandidate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IceCandidate*>(
      &from));
}

void IceCandidate::MergeFrom(const IceCandidate& from) {
  IceCandidate* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.IceCandidate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sdp(from._internal_sdp());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sdp_mid(from._internal_sdp_mid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sdp_m_line_index_ = from._impl_.sdp_m_line_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IceCandidate::CopyFrom(const IceCandidate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.IceCandidate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IceCandidate::IsInitialized() const {
  return true;
}

void IceCandidate::InternalSwap(IceCandidate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.sdp_, lhs_arena,
                                       &other->_impl_.sdp_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.sdp_mid_, lhs_arena,
                                       &other->_impl_.sdp_mid_, rhs_arena);

  swap(_impl_.sdp_m_line_index_, other->_impl_.sdp_m_line_index_);
}

std::string IceCandidate::GetTypeName() const {
  return "location.nearby.mediums.IceCandidate";
}

// ===================================================================

class IceCandidates::_Internal {
 public:
};

IceCandidates::IceCandidates(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.IceCandidates)
}
IceCandidates::IceCandidates(const IceCandidates& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IceCandidates* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ice_candidates_){from._impl_.ice_candidates_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.IceCandidates)
}

inline void IceCandidates::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.ice_candidates_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IceCandidates::~IceCandidates() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.IceCandidates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IceCandidates::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_ice_candidates()->~RepeatedPtrField();
}

void IceCandidates::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IceCandidates::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.IceCandidates)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_ice_candidates()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IceCandidates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .location.nearby.mediums.IceCandidate ice_candidates = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ice_candidates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IceCandidates::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.IceCandidates)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .location.nearby.mediums.IceCandidate ice_candidates = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ice_candidates_size()); i < n; i++) {
    const auto& repfield = this->_internal_ice_candidates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.IceCandidates)
  return target;
}

::size_t IceCandidates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.IceCandidates)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .location.nearby.mediums.IceCandidate ice_candidates = 1;
  total_size += 1UL * this->_internal_ice_candidates_size();
  for (const auto& msg : this->_internal_ice_candidates()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IceCandidates::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IceCandidates*>(
      &from));
}

void IceCandidates::MergeFrom(const IceCandidates& from) {
  IceCandidates* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.IceCandidates)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_ice_candidates()->MergeFrom(from._internal_ice_candidates());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IceCandidates::CopyFrom(const IceCandidates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.IceCandidates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IceCandidates::IsInitialized() const {
  return true;
}

void IceCandidates::InternalSwap(IceCandidates* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_ice_candidates()->InternalSwap(other->_internal_mutable_ice_candidates());
}

std::string IceCandidates::GetTypeName() const {
  return "location.nearby.mediums.IceCandidates";
}

// ===================================================================

class Offer::_Internal {
 public:
  using HasBits = decltype(std::declval<Offer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Offer, _impl_._has_bits_);
  static const ::location::nearby::mediums::SessionDescription& session_description(const Offer* msg);
  static void set_has_session_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::location::nearby::mediums::SessionDescription&
Offer::_Internal::session_description(const Offer* msg) {
  return *msg->_impl_.session_description_;
}
Offer::Offer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.Offer)
}
Offer::Offer(const Offer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Offer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_description_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.session_description_ = new ::location::nearby::mediums::SessionDescription(*from._impl_.session_description_);
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.Offer)
}

inline void Offer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_description_){nullptr}
  };
}

Offer::~Offer() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.Offer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Offer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.session_description_;
}

void Offer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Offer::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.Offer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.session_description_ != nullptr);
    _impl_.session_description_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Offer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.mediums.SessionDescription session_description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_description(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Offer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.Offer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.mediums.SessionDescription session_description = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::session_description(this),
        _Internal::session_description(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.Offer)
  return target;
}

::size_t Offer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.Offer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .location.nearby.mediums.SessionDescription session_description = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.session_description_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Offer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Offer*>(
      &from));
}

void Offer::MergeFrom(const Offer& from) {
  Offer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.Offer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_session_description()->::location::nearby::mediums::SessionDescription::MergeFrom(
        from._internal_session_description());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Offer::CopyFrom(const Offer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.Offer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer::IsInitialized() const {
  return true;
}

void Offer::InternalSwap(Offer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.session_description_, other->_impl_.session_description_);
}

std::string Offer::GetTypeName() const {
  return "location.nearby.mediums.Offer";
}

// ===================================================================

class Answer::_Internal {
 public:
  using HasBits = decltype(std::declval<Answer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Answer, _impl_._has_bits_);
  static const ::location::nearby::mediums::SessionDescription& session_description(const Answer* msg);
  static void set_has_session_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::location::nearby::mediums::SessionDescription&
Answer::_Internal::session_description(const Answer* msg) {
  return *msg->_impl_.session_description_;
}
Answer::Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.Answer)
}
Answer::Answer(const Answer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Answer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_description_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.session_description_ = new ::location::nearby::mediums::SessionDescription(*from._impl_.session_description_);
  }
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.Answer)
}

inline void Answer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_description_){nullptr}
  };
}

Answer::~Answer() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.Answer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Answer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.session_description_;
}

void Answer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Answer::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.Answer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.session_description_ != nullptr);
    _impl_.session_description_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Answer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .location.nearby.mediums.SessionDescription session_description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_description(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Answer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.Answer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .location.nearby.mediums.SessionDescription session_description = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::session_description(this),
        _Internal::session_description(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.Answer)
  return target;
}

::size_t Answer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.Answer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .location.nearby.mediums.SessionDescription session_description = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.session_description_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Answer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Answer*>(
      &from));
}

void Answer::MergeFrom(const Answer& from) {
  Answer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.Answer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_session_description()->::location::nearby::mediums::SessionDescription::MergeFrom(
        from._internal_session_description());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Answer::CopyFrom(const Answer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.Answer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Answer::IsInitialized() const {
  return true;
}

void Answer::InternalSwap(Answer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.session_description_, other->_impl_.session_description_);
}

std::string Answer::GetTypeName() const {
  return "location.nearby.mediums.Answer";
}

// ===================================================================

class ReadyForSignalingPoke::_Internal {
 public:
};

ReadyForSignalingPoke::ReadyForSignalingPoke(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:location.nearby.mediums.ReadyForSignalingPoke)
}
ReadyForSignalingPoke::ReadyForSignalingPoke(const ReadyForSignalingPoke& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:location.nearby.mediums.ReadyForSignalingPoke)
}

inline void ReadyForSignalingPoke::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._cached_size_)*/{}
  };
}

ReadyForSignalingPoke::~ReadyForSignalingPoke() {
  // @@protoc_insertion_point(destructor:location.nearby.mediums.ReadyForSignalingPoke)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadyForSignalingPoke::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReadyForSignalingPoke::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadyForSignalingPoke::Clear() {
// @@protoc_insertion_point(message_clear_start:location.nearby.mediums.ReadyForSignalingPoke)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ReadyForSignalingPoke::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReadyForSignalingPoke::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:location.nearby.mediums.ReadyForSignalingPoke)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:location.nearby.mediums.ReadyForSignalingPoke)
  return target;
}

::size_t ReadyForSignalingPoke::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:location.nearby.mediums.ReadyForSignalingPoke)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReadyForSignalingPoke::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReadyForSignalingPoke*>(
      &from));
}

void ReadyForSignalingPoke::MergeFrom(const ReadyForSignalingPoke& from) {
  ReadyForSignalingPoke* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:location.nearby.mediums.ReadyForSignalingPoke)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReadyForSignalingPoke::CopyFrom(const ReadyForSignalingPoke& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:location.nearby.mediums.ReadyForSignalingPoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadyForSignalingPoke::IsInitialized() const {
  return true;
}

void ReadyForSignalingPoke::InternalSwap(ReadyForSignalingPoke* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ReadyForSignalingPoke::GetTypeName() const {
  return "location.nearby.mediums.ReadyForSignalingPoke";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace mediums
}  // namespace nearby
}  // namespace location
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::WebRtcSignalingFrame*
Arena::CreateMaybeMessage< ::location::nearby::mediums::WebRtcSignalingFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::WebRtcSignalingFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::PeerId*
Arena::CreateMaybeMessage< ::location::nearby::mediums::PeerId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::PeerId >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::SessionDescription*
Arena::CreateMaybeMessage< ::location::nearby::mediums::SessionDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::SessionDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::IceCandidate*
Arena::CreateMaybeMessage< ::location::nearby::mediums::IceCandidate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::IceCandidate >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::IceCandidates*
Arena::CreateMaybeMessage< ::location::nearby::mediums::IceCandidates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::IceCandidates >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::Offer*
Arena::CreateMaybeMessage< ::location::nearby::mediums::Offer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::Offer >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::Answer*
Arena::CreateMaybeMessage< ::location::nearby::mediums::Answer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::Answer >(arena);
}
template<> PROTOBUF_NOINLINE ::location::nearby::mediums::ReadyForSignalingPoke*
Arena::CreateMaybeMessage< ::location::nearby::mediums::ReadyForSignalingPoke >(Arena* arena) {
  return Arena::CreateMessageInternal< ::location::nearby::mediums::ReadyForSignalingPoke >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
