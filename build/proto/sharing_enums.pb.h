// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/sharing_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fsharing_5fenums_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fsharing_5fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fsharing_5fenums_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fsharing_5fenums_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

namespace location {
namespace nearby {
namespace proto {
namespace sharing {
enum EventType : int {
  UNKNOWN_EVENT_TYPE = 0,
  ACCEPT_AGREEMENTS = 1,
  ENABLE_NEARBY_SHARING = 2,
  SET_VISIBILITY = 3,
  DESCRIBE_ATTACHMENTS = 4,
  SCAN_FOR_SHARE_TARGETS_START = 5,
  SCAN_FOR_SHARE_TARGETS_END = 6,
  ADVERTISE_DEVICE_PRESENCE_START = 7,
  ADVERTISE_DEVICE_PRESENCE_END = 8,
  SEND_FAST_INITIALIZATION = 9,
  RECEIVE_FAST_INITIALIZATION = 10,
  DISCOVER_SHARE_TARGET = 11,
  SEND_INTRODUCTION = 12,
  RECEIVE_INTRODUCTION = 13,
  RESPOND_TO_INTRODUCTION = 14,
  SEND_ATTACHMENTS_START = 15,
  SEND_ATTACHMENTS_END = 16,
  RECEIVE_ATTACHMENTS_START = 17,
  RECEIVE_ATTACHMENTS_END = 18,
  CANCEL_SENDING_ATTACHMENTS = 19,
  CANCEL_RECEIVING_ATTACHMENTS = 20,
  OPEN_RECEIVED_ATTACHMENTS = 21,
  LAUNCH_SETUP_ACTIVITY [[deprecated]] = 22,
  ADD_CONTACT = 23,
  REMOVE_CONTACT = 24,
  FAST_SHARE_SERVER_RESPONSE = 25,
  SEND_START = 26,
  ACCEPT_FAST_INITIALIZATION = 27,
  SET_DATA_USAGE = 28,
  DISMISS_FAST_INITIALIZATION = 29,
  CANCEL_CONNECTION = 30,
  LAUNCH_ACTIVITY = 31,
  DISMISS_PRIVACY_NOTIFICATION = 32,
  TAP_PRIVACY_NOTIFICATION = 33,
  TAP_HELP = 34,
  TAP_FEEDBACK = 35,
  ADD_QUICK_SETTINGS_TILE = 36,
  REMOVE_QUICK_SETTINGS_TILE = 37,
  LAUNCH_PHONE_CONSENT = 38,
  DISPLAY_PHONE_CONSENT = 54,
  TAP_QUICK_SETTINGS_TILE = 39,
  INSTALL_APK = 40,
  VERIFY_APK = 41,
  LAUNCH_CONSENT = 42,
  PROCESS_RECEIVED_ATTACHMENTS_END = 43,
  TOGGLE_SHOW_NOTIFICATION = 44,
  SET_DEVICE_NAME = 45,
  DECLINE_AGREEMENTS = 46,
  REQUEST_SETTING_PERMISSIONS = 47,
  ESTABLISH_CONNECTION = 48,
  DEVICE_SETTINGS = 49,
  AUTO_DISMISS_FAST_INITIALIZATION = 50,
  APP_CRASH = 51,
  TAP_QUICK_SETTINGS_FILE_SHARE = 52,
  DISPLAY_PRIVACY_NOTIFICATION = 53,
  PREFERENCES_USAGE = 55,
  DEFAULT_OPT_IN = 56,
  SETUP_WIZARD = 57,
  TAP_QR_CODE = 58,
  QR_CODE_LINK_SHOWN = 59,
  PARSING_FAILED_ENDPOINT_ID = 60,
  FAST_INIT_DISCOVER_DEVICE = 61,
  SEND_DESKTOP_NOTIFICATION = 62,
  SET_ACCOUNT = 63,
  DECRYPT_CERTIFICATE_FAILURE = 64,
};

bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = static_cast<EventType>(0);
constexpr EventType EventType_MAX = static_cast<EventType>(64);
constexpr int EventType_ARRAYSIZE = 64 + 1;
const std::string& EventType_Name(EventType value);
template <typename T>
const std::string& EventType_Name(T value) {
  static_assert(std::is_same<T, EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
const std::string& EventType_Name(EventType value);
bool EventType_Parse(absl::string_view name, EventType* value);
enum EventCategory : int {
  UNKNOWN_EVENT_CATEGORY = 0,
  SENDING_EVENT = 1,
  RECEIVING_EVENT = 2,
  SETTINGS_EVENT = 3,
};

bool EventCategory_IsValid(int value);
constexpr EventCategory EventCategory_MIN = static_cast<EventCategory>(0);
constexpr EventCategory EventCategory_MAX = static_cast<EventCategory>(3);
constexpr int EventCategory_ARRAYSIZE = 3 + 1;
const std::string& EventCategory_Name(EventCategory value);
template <typename T>
const std::string& EventCategory_Name(T value) {
  static_assert(std::is_same<T, EventCategory>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventCategory_Name().");
  return EventCategory_Name(static_cast<EventCategory>(value));
}
const std::string& EventCategory_Name(EventCategory value);
bool EventCategory_Parse(absl::string_view name, EventCategory* value);
enum NearbySharingStatus : int {
  UNKNOWN_NEARBY_SHARING_STATUS = 0,
  ON = 1,
  OFF = 2,
};

bool NearbySharingStatus_IsValid(int value);
constexpr NearbySharingStatus NearbySharingStatus_MIN = static_cast<NearbySharingStatus>(0);
constexpr NearbySharingStatus NearbySharingStatus_MAX = static_cast<NearbySharingStatus>(2);
constexpr int NearbySharingStatus_ARRAYSIZE = 2 + 1;
const std::string& NearbySharingStatus_Name(NearbySharingStatus value);
template <typename T>
const std::string& NearbySharingStatus_Name(T value) {
  static_assert(std::is_same<T, NearbySharingStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NearbySharingStatus_Name().");
  return NearbySharingStatus_Name(static_cast<NearbySharingStatus>(value));
}
const std::string& NearbySharingStatus_Name(NearbySharingStatus value);
bool NearbySharingStatus_Parse(absl::string_view name, NearbySharingStatus* value);
enum Visibility : int {
  UNKNOWN_VISIBILITY = 0,
  CONTACTS_ONLY = 1,
  EVERYONE = 2,
  SELECTED_CONTACTS_ONLY = 3,
  HIDDEN = 4,
  SELF_SHARE = 5,
};

bool Visibility_IsValid(int value);
constexpr Visibility Visibility_MIN = static_cast<Visibility>(0);
constexpr Visibility Visibility_MAX = static_cast<Visibility>(5);
constexpr int Visibility_ARRAYSIZE = 5 + 1;
const std::string& Visibility_Name(Visibility value);
template <typename T>
const std::string& Visibility_Name(T value) {
  static_assert(std::is_same<T, Visibility>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Visibility_Name().");
  return Visibility_Name(static_cast<Visibility>(value));
}
const std::string& Visibility_Name(Visibility value);
bool Visibility_Parse(absl::string_view name, Visibility* value);
enum DataUsage : int {
  UNKNOWN_DATA_USAGE = 0,
  ONLINE = 1,
  WIFI_ONLY = 2,
  OFFLINE = 3,
};

bool DataUsage_IsValid(int value);
constexpr DataUsage DataUsage_MIN = static_cast<DataUsage>(0);
constexpr DataUsage DataUsage_MAX = static_cast<DataUsage>(3);
constexpr int DataUsage_ARRAYSIZE = 3 + 1;
const std::string& DataUsage_Name(DataUsage value);
template <typename T>
const std::string& DataUsage_Name(T value) {
  static_assert(std::is_same<T, DataUsage>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataUsage_Name().");
  return DataUsage_Name(static_cast<DataUsage>(value));
}
const std::string& DataUsage_Name(DataUsage value);
bool DataUsage_Parse(absl::string_view name, DataUsage* value);
enum EstablishConnectionStatus : int {
  CONNECTION_STATUS_UNKNOWN = 0,
  CONNECTION_STATUS_SUCCESS = 1,
  CONNECTION_STATUS_FAILURE = 2,
  CONNECTION_STATUS_CANCELLATION = 3,
  CONNECTION_STATUS_MEDIA_UNAVAILABLE_ATTACHMENT = 4,
  CONNECTION_STATUS_FAILED_PAIRED_KEYHANDSHAKE = 5,
  CONNECTION_STATUS_FAILED_WRITE_INTRODUCTION = 6,
  CONNECTION_STATUS_FAILED_NULL_CONNECTION = 7,
  CONNECTION_STATUS_FAILED_NO_TRANSFER_UPDATE_CALLBACK = 8,
  CONNECTION_STATUS_LOST_CONNECTIVITY = 9,
  CONNECTION_STATUS_INVALID_ADVERTISEMENT = 10,
};

bool EstablishConnectionStatus_IsValid(int value);
constexpr EstablishConnectionStatus EstablishConnectionStatus_MIN = static_cast<EstablishConnectionStatus>(0);
constexpr EstablishConnectionStatus EstablishConnectionStatus_MAX = static_cast<EstablishConnectionStatus>(10);
constexpr int EstablishConnectionStatus_ARRAYSIZE = 10 + 1;
const std::string& EstablishConnectionStatus_Name(EstablishConnectionStatus value);
template <typename T>
const std::string& EstablishConnectionStatus_Name(T value) {
  static_assert(std::is_same<T, EstablishConnectionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EstablishConnectionStatus_Name().");
  return EstablishConnectionStatus_Name(static_cast<EstablishConnectionStatus>(value));
}
const std::string& EstablishConnectionStatus_Name(EstablishConnectionStatus value);
bool EstablishConnectionStatus_Parse(absl::string_view name, EstablishConnectionStatus* value);
enum AttachmentTransmissionStatus : int {
  UNKNOWN_ATTACHMENT_TRANSMISSION_STATUS = 0,
  COMPLETE_ATTACHMENT_TRANSMISSION_STATUS = 1,
  CANCELED_ATTACHMENT_TRANSMISSION_STATUS = 2,
  FAILED_ATTACHMENT_TRANSMISSION_STATUS = 3,
  REJECTED_ATTACHMENT [[deprecated]] = 4,
  TIMED_OUT_ATTACHMENT [[deprecated]] = 5,
  AWAITING_REMOTE_ACCEPTANCE_FAILED_ATTACHMENT [[deprecated]] = 6,
  NOT_ENOUGH_SPACE_ATTACHMENT [[deprecated]] = 7,
  FAILED_NO_TRANSFER_UPDATE_CALLBACK [[deprecated]] = 8,
  MEDIA_UNAVAILABLE_ATTACHMENT [[deprecated]] = 9,
  UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT [[deprecated]] = 10,
  NO_ATTACHMENT_FOUND [[deprecated]] = 11,
  FAILED_NO_SHARE_TARGET_ENDPOINT [[deprecated]] = 12,
  FAILED_PAIRED_KEYHANDSHAKE [[deprecated]] = 13,
  FAILED_NULL_CONNECTION [[deprecated]] = 14,
  FAILED_NO_PAYLOAD [[deprecated]] = 15,
  FAILED_WRITE_INTRODUCTION [[deprecated]] = 16,
  FAILED_UNKNOWN_REMOTE_RESPONSE [[deprecated]] = 17,
  FAILED_NULL_CONNECTION_INIT_OUTGOING = 18,
  FAILED_NULL_CONNECTION_DISCONNECTED = 19,
  FAILED_NULL_CONNECTION_LOST_CONNECTIVITY [[deprecated]] = 20,
  FAILED_NULL_CONNECTION_FAILURE [[deprecated]] = 21,
  REJECTED_ATTACHMENT_TRANSMISSION_STATUS = 22,
  TIMED_OUT_ATTACHMENT_TRANSMISSION_STATUS = 23,
  NOT_ENOUGH_SPACE_ATTACHMENT_TRANSMISSION_STATUS = 24,
  UNSUPPORTED_ATTACHMENT_TYPE_ATTACHMENT_TRANSMISSION_STATUS = 25,
  FAILED_UNKNOWN_REMOTE_RESPONSE_TRANSMISSION_STATUS = 26,
  NO_RESPONSE_FRAME_CONNECTION_CLOSED_LOST_CONNECTIVITY_TRANSMISSION_STATUS [[deprecated]] = 27,
  NO_RESPONSE_FRAME_CONNECTION_CLOSED_TRANSMISSION_STATUS = 28,
  LOST_CONNECTIVITY_TRANSMISSION_STATUS = 29,
};

bool AttachmentTransmissionStatus_IsValid(int value);
constexpr AttachmentTransmissionStatus AttachmentTransmissionStatus_MIN = static_cast<AttachmentTransmissionStatus>(0);
constexpr AttachmentTransmissionStatus AttachmentTransmissionStatus_MAX = static_cast<AttachmentTransmissionStatus>(29);
constexpr int AttachmentTransmissionStatus_ARRAYSIZE = 29 + 1;
const std::string& AttachmentTransmissionStatus_Name(AttachmentTransmissionStatus value);
template <typename T>
const std::string& AttachmentTransmissionStatus_Name(T value) {
  static_assert(std::is_same<T, AttachmentTransmissionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AttachmentTransmissionStatus_Name().");
  return AttachmentTransmissionStatus_Name(static_cast<AttachmentTransmissionStatus>(value));
}
const std::string& AttachmentTransmissionStatus_Name(AttachmentTransmissionStatus value);
bool AttachmentTransmissionStatus_Parse(absl::string_view name, AttachmentTransmissionStatus* value);
enum ConnectionLayerStatus : int {
  CONNECTION_LAYER_STATUS_UNKNOWN = 0,
  CONNECTION_LAYER_STATUS_SUCCESS = 1,
  CONNECTION_LAYER_STATUS_ERROR = 2,
  CONNECTION_LAYER_STATUS_OUT_OF_ORDER_API_CALL = 3,
  CONNECTION_LAYER_STATUS_ALREADY_HAVE_ACTIVE_STRATEGY = 4,
  CONNECTION_LAYER_STATUS_ALREADY_ADVERTISING = 5,
  CONNECTION_LAYER_STATUS_ALREADY_DISCOVERING = 6,
  CONNECTION_LAYER_STATUS_ALREADY_LISTENING = 7,
  CONNECTION_LAYER_STATUS_END_POINT_IO_ERROR = 8,
  CONNECTION_LAYER_STATUS_END_POINT_UNKNOWN = 9,
  CONNECTION_LAYER_STATUS_CONNECTION_REJECTED = 10,
  CONNECTION_LAYER_STATUS_ALREADY_CONNECTED_TO_END_POINT = 11,
  CONNECTION_LAYER_STATUS_NOT_CONNECTED_TO_END_POINT = 12,
  CONNECTION_LAYER_STATUS_BLUETOOTH_ERROR = 13,
  CONNECTION_LAYER_STATUS_BLE_ERROR = 14,
  CONNECTION_LAYER_STATUS_WIFI_LAN_ERROR = 15,
  CONNECTION_LAYER_STATUS_PAYLOAD_UNKNOWN = 16,
  CONNECTION_LAYER_STATUS_RESET = 17,
  CONNECTION_LAYER_STATUS_TIMEOUT = 18,
};

bool ConnectionLayerStatus_IsValid(int value);
constexpr ConnectionLayerStatus ConnectionLayerStatus_MIN = static_cast<ConnectionLayerStatus>(0);
constexpr ConnectionLayerStatus ConnectionLayerStatus_MAX = static_cast<ConnectionLayerStatus>(18);
constexpr int ConnectionLayerStatus_ARRAYSIZE = 18 + 1;
const std::string& ConnectionLayerStatus_Name(ConnectionLayerStatus value);
template <typename T>
const std::string& ConnectionLayerStatus_Name(T value) {
  static_assert(std::is_same<T, ConnectionLayerStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConnectionLayerStatus_Name().");
  return ConnectionLayerStatus_Name(static_cast<ConnectionLayerStatus>(value));
}
const std::string& ConnectionLayerStatus_Name(ConnectionLayerStatus value);
bool ConnectionLayerStatus_Parse(absl::string_view name, ConnectionLayerStatus* value);
enum ProcessReceivedAttachmentsStatus : int {
  PROCESSING_STATUS_UNKNOWN = 0,
  PROCESSING_STATUS_COMPLETE_PROCESSING_ATTACHMENTS = 1,
  PROCESSING_STATUS_FAILED_MOVING_FILES = 2,
  PROCESSING_STATUS_FAILED_RECEIVING_APK = 3,
  PROCESSING_STATUS_FAILED_RECEIVING_TEXT = 4,
  PROCESSING_STATUS_FAILED_RECEIVING_WIFI_CREDENTIALS = 5,
};

bool ProcessReceivedAttachmentsStatus_IsValid(int value);
constexpr ProcessReceivedAttachmentsStatus ProcessReceivedAttachmentsStatus_MIN = static_cast<ProcessReceivedAttachmentsStatus>(0);
constexpr ProcessReceivedAttachmentsStatus ProcessReceivedAttachmentsStatus_MAX = static_cast<ProcessReceivedAttachmentsStatus>(5);
constexpr int ProcessReceivedAttachmentsStatus_ARRAYSIZE = 5 + 1;
const std::string& ProcessReceivedAttachmentsStatus_Name(ProcessReceivedAttachmentsStatus value);
template <typename T>
const std::string& ProcessReceivedAttachmentsStatus_Name(T value) {
  static_assert(std::is_same<T, ProcessReceivedAttachmentsStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProcessReceivedAttachmentsStatus_Name().");
  return ProcessReceivedAttachmentsStatus_Name(static_cast<ProcessReceivedAttachmentsStatus>(value));
}
const std::string& ProcessReceivedAttachmentsStatus_Name(ProcessReceivedAttachmentsStatus value);
bool ProcessReceivedAttachmentsStatus_Parse(absl::string_view name, ProcessReceivedAttachmentsStatus* value);
enum SessionStatus : int {
  UNKNOWN_SESSION_STATUS = 0,
  SUCCEEDED_SESSION_STATUS = 1,
  FAILED_SESSION_STATUS = 2,
};

bool SessionStatus_IsValid(int value);
constexpr SessionStatus SessionStatus_MIN = static_cast<SessionStatus>(0);
constexpr SessionStatus SessionStatus_MAX = static_cast<SessionStatus>(2);
constexpr int SessionStatus_ARRAYSIZE = 2 + 1;
const std::string& SessionStatus_Name(SessionStatus value);
template <typename T>
const std::string& SessionStatus_Name(T value) {
  static_assert(std::is_same<T, SessionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SessionStatus_Name().");
  return SessionStatus_Name(static_cast<SessionStatus>(value));
}
const std::string& SessionStatus_Name(SessionStatus value);
bool SessionStatus_Parse(absl::string_view name, SessionStatus* value);
enum ResponseToIntroduction : int {
  UNKNOWN_RESPONSE_TO_INTRODUCTION = 0,
  ACCEPT_INTRODUCTION = 1,
  REJECT_INTRODUCTION = 2,
  FAIL_INTRODUCTION = 3,
};

bool ResponseToIntroduction_IsValid(int value);
constexpr ResponseToIntroduction ResponseToIntroduction_MIN = static_cast<ResponseToIntroduction>(0);
constexpr ResponseToIntroduction ResponseToIntroduction_MAX = static_cast<ResponseToIntroduction>(3);
constexpr int ResponseToIntroduction_ARRAYSIZE = 3 + 1;
const std::string& ResponseToIntroduction_Name(ResponseToIntroduction value);
template <typename T>
const std::string& ResponseToIntroduction_Name(T value) {
  static_assert(std::is_same<T, ResponseToIntroduction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseToIntroduction_Name().");
  return ResponseToIntroduction_Name(static_cast<ResponseToIntroduction>(value));
}
const std::string& ResponseToIntroduction_Name(ResponseToIntroduction value);
bool ResponseToIntroduction_Parse(absl::string_view name, ResponseToIntroduction* value);
enum DeviceType : int {
  UNKNOWN_DEVICE_TYPE = 0,
  PHONE = 1,
  TABLET = 2,
  LAPTOP = 3,
};

bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = static_cast<DeviceType>(0);
constexpr DeviceType DeviceType_MAX = static_cast<DeviceType>(3);
constexpr int DeviceType_ARRAYSIZE = 3 + 1;
const std::string& DeviceType_Name(DeviceType value);
template <typename T>
const std::string& DeviceType_Name(T value) {
  static_assert(std::is_same<T, DeviceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceType_Name().");
  return DeviceType_Name(static_cast<DeviceType>(value));
}
const std::string& DeviceType_Name(DeviceType value);
bool DeviceType_Parse(absl::string_view name, DeviceType* value);
enum OSType : int {
  UNKNOWN_OS_TYPE = 0,
  ANDROID = 1,
  CHROME_OS = 2,
  IOS = 3,
  WINDOWS = 4,
};

bool OSType_IsValid(int value);
constexpr OSType OSType_MIN = static_cast<OSType>(0);
constexpr OSType OSType_MAX = static_cast<OSType>(4);
constexpr int OSType_ARRAYSIZE = 4 + 1;
const std::string& OSType_Name(OSType value);
template <typename T>
const std::string& OSType_Name(T value) {
  static_assert(std::is_same<T, OSType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OSType_Name().");
  return OSType_Name(static_cast<OSType>(value));
}
const std::string& OSType_Name(OSType value);
bool OSType_Parse(absl::string_view name, OSType* value);
enum DeviceRelationship : int {
  UNKNOWN_DEVICE_RELATIONSHIP = 0,
  IS_SELF = 1,
  IS_CONTACT = 2,
  IS_STRANGER = 3,
};

bool DeviceRelationship_IsValid(int value);
constexpr DeviceRelationship DeviceRelationship_MIN = static_cast<DeviceRelationship>(0);
constexpr DeviceRelationship DeviceRelationship_MAX = static_cast<DeviceRelationship>(3);
constexpr int DeviceRelationship_ARRAYSIZE = 3 + 1;
const std::string& DeviceRelationship_Name(DeviceRelationship value);
template <typename T>
const std::string& DeviceRelationship_Name(T value) {
  static_assert(std::is_same<T, DeviceRelationship>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceRelationship_Name().");
  return DeviceRelationship_Name(static_cast<DeviceRelationship>(value));
}
const std::string& DeviceRelationship_Name(DeviceRelationship value);
bool DeviceRelationship_Parse(absl::string_view name, DeviceRelationship* value);
enum LogSource : int {
  UNSPECIFIED_SOURCE = 0,
  LAB_DEVICES = 1,
  INTERNAL_DEVICES = 2,
  BETA_TESTER_DEVICES = 3,
  OEM_DEVICES = 4,
  DEBUG_DEVICES = 5,
  NEARBY_MODULE_FOOD_DEVICES = 6,
};

bool LogSource_IsValid(int value);
constexpr LogSource LogSource_MIN = static_cast<LogSource>(0);
constexpr LogSource LogSource_MAX = static_cast<LogSource>(6);
constexpr int LogSource_ARRAYSIZE = 6 + 1;
const std::string& LogSource_Name(LogSource value);
template <typename T>
const std::string& LogSource_Name(T value) {
  static_assert(std::is_same<T, LogSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogSource_Name().");
  return LogSource_Name(static_cast<LogSource>(value));
}
const std::string& LogSource_Name(LogSource value);
bool LogSource_Parse(absl::string_view name, LogSource* value);
enum ServerActionName : int {
  UNKNOWN_SERVER_ACTION = 0,
  UPLOAD_CERTIFICATES = 1,
  DOWNLOAD_CERTIFICATES = 2,
  CHECK_REACHABILITY = 3,
  UPLOAD_CONTACTS = 4,
  UPDATE_DEVICE_NAME = 5,
  UPLOAD_SENDER_CERTIFICATES = 6,
  DOWNLOAD_SENDER_CERTIFICATES = 7,
  UPLOAD_CONTACTS_AND_CERTIFICATES = 8,
  LIST_REACHABLE_PHONE_NUMBERS = 9,
  LIST_MY_DEVICES = 10,
  LIST_CONTACT_PEOPLE = 11,
};

bool ServerActionName_IsValid(int value);
constexpr ServerActionName ServerActionName_MIN = static_cast<ServerActionName>(0);
constexpr ServerActionName ServerActionName_MAX = static_cast<ServerActionName>(11);
constexpr int ServerActionName_ARRAYSIZE = 11 + 1;
const std::string& ServerActionName_Name(ServerActionName value);
template <typename T>
const std::string& ServerActionName_Name(T value) {
  static_assert(std::is_same<T, ServerActionName>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ServerActionName_Name().");
  return ServerActionName_Name(static_cast<ServerActionName>(value));
}
const std::string& ServerActionName_Name(ServerActionName value);
bool ServerActionName_Parse(absl::string_view name, ServerActionName* value);
enum ServerResponseState : int {
  UNKNOWN_SERVER_RESPONSE_STATE = 0,
  SERVER_RESPONSE_SUCCESS = 1,
  SERVER_RESPONSE_UNKNOWN_FAILURE = 2,
  SERVER_RESPONSE_STATUS_OTHER_FAILURE = 3,
  SERVER_RESPONSE_STATUS_DEADLINE_EXCEEDED = 4,
  SERVER_RESPONSE_STATUS_PERMISSION_DENIED = 5,
  SERVER_RESPONSE_STATUS_UNAVAILABLE = 6,
  SERVER_RESPONSE_STATUS_UNAUTHENTICATED = 7,
  SERVER_RESPONSE_STATUS_INVALID_ARGUMENT = 9,
  SERVER_RESPONSE_GOOGLE_AUTH_FAILURE = 8,
  SERVER_RESPONSE_NOT_CONNECTED_TO_INTERNET = 10,
};

bool ServerResponseState_IsValid(int value);
constexpr ServerResponseState ServerResponseState_MIN = static_cast<ServerResponseState>(0);
constexpr ServerResponseState ServerResponseState_MAX = static_cast<ServerResponseState>(10);
constexpr int ServerResponseState_ARRAYSIZE = 10 + 1;
const std::string& ServerResponseState_Name(ServerResponseState value);
template <typename T>
const std::string& ServerResponseState_Name(T value) {
  static_assert(std::is_same<T, ServerResponseState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ServerResponseState_Name().");
  return ServerResponseState_Name(static_cast<ServerResponseState>(value));
}
const std::string& ServerResponseState_Name(ServerResponseState value);
bool ServerResponseState_Parse(absl::string_view name, ServerResponseState* value);
enum SyncPurpose : int {
  SYNC_PURPOSE_UNKNOWN = 0,
  SYNC_PURPOSE_ON_DEMAND_SYNC = 1,
  SYNC_PURPOSE_CHIME_NOTIFICATION = 2,
  SYNC_PURPOSE_DAILY_SYNC = 3,
  SYNC_PURPOSE_OPT_IN_FIRST_SYNC = 4,
  SYNC_PURPOSE_CHECK_DEFAULT_OPT_IN = 5,
  SYNC_PURPOSE_NEARBY_SHARE_ENABLED = 6,
  SYNC_PURPOSE_SYNC_AT_FAST_INIT = 7,
  SYNC_PURPOSE_SYNC_AT_DISCOVERY = 8,
  SYNC_PURPOSE_SYNC_AT_LOAD_PRIVATE_CERTIFICATE = 9,
  SYNC_PURPOSE_SYNC_AT_ADVERTISEMENT = 10,
  SYNC_PURPOSE_CONTACT_LIST_CHANGE = 11,
  SYNC_PURPOSE_SHOW_C11N_VIEW = 12,
  SYNC_PURPOSE_REGULAR_CHECK_CONTACT_REACHABILITY = 13,
  SYNC_PURPOSE_VISIBILITY_SELECTED_CONTACT_CHANGE = 14,
  SYNC_PURPOSE_ACCOUNT_CHANGE = 15,
};

bool SyncPurpose_IsValid(int value);
constexpr SyncPurpose SyncPurpose_MIN = static_cast<SyncPurpose>(0);
constexpr SyncPurpose SyncPurpose_MAX = static_cast<SyncPurpose>(15);
constexpr int SyncPurpose_ARRAYSIZE = 15 + 1;
const std::string& SyncPurpose_Name(SyncPurpose value);
template <typename T>
const std::string& SyncPurpose_Name(T value) {
  static_assert(std::is_same<T, SyncPurpose>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SyncPurpose_Name().");
  return SyncPurpose_Name(static_cast<SyncPurpose>(value));
}
const std::string& SyncPurpose_Name(SyncPurpose value);
bool SyncPurpose_Parse(absl::string_view name, SyncPurpose* value);
enum ClientRole : int {
  CLIENT_ROLE_UNKNOWN = 0,
  CLIENT_ROLE_SENDER = 1,
  CLIENT_ROLE_RECEIVER = 2,
};

bool ClientRole_IsValid(int value);
constexpr ClientRole ClientRole_MIN = static_cast<ClientRole>(0);
constexpr ClientRole ClientRole_MAX = static_cast<ClientRole>(2);
constexpr int ClientRole_ARRAYSIZE = 2 + 1;
const std::string& ClientRole_Name(ClientRole value);
template <typename T>
const std::string& ClientRole_Name(T value) {
  static_assert(std::is_same<T, ClientRole>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ClientRole_Name().");
  return ClientRole_Name(static_cast<ClientRole>(value));
}
const std::string& ClientRole_Name(ClientRole value);
bool ClientRole_Parse(absl::string_view name, ClientRole* value);
enum ScanType : int {
  UNKNOWN_SCAN_TYPE = 0,
  FOREGROUND_SCAN = 1,
  FOREGROUND_RETRY_SCAN = 2,
  DIRECT_SHARE_SCAN = 3,
  BACKGROUND_SCAN = 4,
};

bool ScanType_IsValid(int value);
constexpr ScanType ScanType_MIN = static_cast<ScanType>(0);
constexpr ScanType ScanType_MAX = static_cast<ScanType>(4);
constexpr int ScanType_ARRAYSIZE = 4 + 1;
const std::string& ScanType_Name(ScanType value);
template <typename T>
const std::string& ScanType_Name(T value) {
  static_assert(std::is_same<T, ScanType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScanType_Name().");
  return ScanType_Name(static_cast<ScanType>(value));
}
const std::string& ScanType_Name(ScanType value);
bool ScanType_Parse(absl::string_view name, ScanType* value);
enum ParsingFailedType : int {
  FAILED_UNKNOWN_TYPE = 0,
  FAILED_PARSE_ADVERTISEMENT = 1,
  FAILED_CONVERT_SHARE_TARGET = 2,
};

bool ParsingFailedType_IsValid(int value);
constexpr ParsingFailedType ParsingFailedType_MIN = static_cast<ParsingFailedType>(0);
constexpr ParsingFailedType ParsingFailedType_MAX = static_cast<ParsingFailedType>(2);
constexpr int ParsingFailedType_ARRAYSIZE = 2 + 1;
const std::string& ParsingFailedType_Name(ParsingFailedType value);
template <typename T>
const std::string& ParsingFailedType_Name(T value) {
  static_assert(std::is_same<T, ParsingFailedType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ParsingFailedType_Name().");
  return ParsingFailedType_Name(static_cast<ParsingFailedType>(value));
}
const std::string& ParsingFailedType_Name(ParsingFailedType value);
bool ParsingFailedType_Parse(absl::string_view name, ParsingFailedType* value);
enum AdvertisingMode : int {
  UNKNOWN_ADVERTISING_MODE = 0,
  SCREEN_OFF_ADVERTISING_MODE = 1,
  BACKGROUND_ADVERTISING_MODE = 2,
  MIDGROUND_ADVERTISING_MODE = 3,
  FOREGROUND_ADVERTISING_MODE = 4,
};

bool AdvertisingMode_IsValid(int value);
constexpr AdvertisingMode AdvertisingMode_MIN = static_cast<AdvertisingMode>(0);
constexpr AdvertisingMode AdvertisingMode_MAX = static_cast<AdvertisingMode>(4);
constexpr int AdvertisingMode_ARRAYSIZE = 4 + 1;
const std::string& AdvertisingMode_Name(AdvertisingMode value);
template <typename T>
const std::string& AdvertisingMode_Name(T value) {
  static_assert(std::is_same<T, AdvertisingMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AdvertisingMode_Name().");
  return AdvertisingMode_Name(static_cast<AdvertisingMode>(value));
}
const std::string& AdvertisingMode_Name(AdvertisingMode value);
bool AdvertisingMode_Parse(absl::string_view name, AdvertisingMode* value);
enum DiscoveryMode : int {
  UNKNOWN_DISCOVERY_MODE = 0,
  SCREEN_OFF_DISCOVERY_MODE = 1,
  BACKGROUND_DISCOVERY_MODE = 2,
  MIDGROUND_DISCOVERY_MODE = 3,
  FOREGROUND_DISCOVERY_MODE = 4,
};

bool DiscoveryMode_IsValid(int value);
constexpr DiscoveryMode DiscoveryMode_MIN = static_cast<DiscoveryMode>(0);
constexpr DiscoveryMode DiscoveryMode_MAX = static_cast<DiscoveryMode>(4);
constexpr int DiscoveryMode_ARRAYSIZE = 4 + 1;
const std::string& DiscoveryMode_Name(DiscoveryMode value);
template <typename T>
const std::string& DiscoveryMode_Name(T value) {
  static_assert(std::is_same<T, DiscoveryMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DiscoveryMode_Name().");
  return DiscoveryMode_Name(static_cast<DiscoveryMode>(value));
}
const std::string& DiscoveryMode_Name(DiscoveryMode value);
bool DiscoveryMode_Parse(absl::string_view name, DiscoveryMode* value);
enum ActivityName : int {
  UNKNOWN_ACTIVITY = 0,
  SHARE_SHEET_ACTIVITY = 1,
  SETTINGS_ACTIVITY = 2,
  RECEIVE_SURFACE_ACTIVITY = 3,
  SETUP_ACTIVITY = 4,
  DEVICE_VISIBILITY_ACTIVITY = 5,
  CONSENTS_ACTIVITY = 6,
  SET_DEVICE_NAME_DIALOG = 7,
  SET_DATA_USAGE_DIALOG = 8,
  QUICK_SETTINGS_ACTIVITY = 9,
  REMOTE_COPY_SHARE_SHEET_ACTIVITY = 10,
  SETUP_WIZARD_ACTIVITY = 11,
  SETTINGS_REVIEW_ACTIVITY = 12,
};

bool ActivityName_IsValid(int value);
constexpr ActivityName ActivityName_MIN = static_cast<ActivityName>(0);
constexpr ActivityName ActivityName_MAX = static_cast<ActivityName>(12);
constexpr int ActivityName_ARRAYSIZE = 12 + 1;
const std::string& ActivityName_Name(ActivityName value);
template <typename T>
const std::string& ActivityName_Name(T value) {
  static_assert(std::is_same<T, ActivityName>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ActivityName_Name().");
  return ActivityName_Name(static_cast<ActivityName>(value));
}
const std::string& ActivityName_Name(ActivityName value);
bool ActivityName_Parse(absl::string_view name, ActivityName* value);
enum ConsentType : int {
  CONSENT_TYPE_UNKNOWN = 0,
  CONSENT_TYPE_C11N = 1,
  CONSENT_TYPE_DEVICE_CONTACT = 2,
};

bool ConsentType_IsValid(int value);
constexpr ConsentType ConsentType_MIN = static_cast<ConsentType>(0);
constexpr ConsentType ConsentType_MAX = static_cast<ConsentType>(2);
constexpr int ConsentType_ARRAYSIZE = 2 + 1;
const std::string& ConsentType_Name(ConsentType value);
template <typename T>
const std::string& ConsentType_Name(T value) {
  static_assert(std::is_same<T, ConsentType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConsentType_Name().");
  return ConsentType_Name(static_cast<ConsentType>(value));
}
const std::string& ConsentType_Name(ConsentType value);
bool ConsentType_Parse(absl::string_view name, ConsentType* value);
enum ConsentAcceptanceStatus : int {
  CONSENT_UNKNOWN_ACCEPT_STATUS = 0,
  CONSENT_ACCEPTED = 1,
  CONSENT_DECLINED = 2,
  CONSENT_UNABLE_TO_ENABLE = 3,
};

bool ConsentAcceptanceStatus_IsValid(int value);
constexpr ConsentAcceptanceStatus ConsentAcceptanceStatus_MIN = static_cast<ConsentAcceptanceStatus>(0);
constexpr ConsentAcceptanceStatus ConsentAcceptanceStatus_MAX = static_cast<ConsentAcceptanceStatus>(3);
constexpr int ConsentAcceptanceStatus_ARRAYSIZE = 3 + 1;
const std::string& ConsentAcceptanceStatus_Name(ConsentAcceptanceStatus value);
template <typename T>
const std::string& ConsentAcceptanceStatus_Name(T value) {
  static_assert(std::is_same<T, ConsentAcceptanceStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ConsentAcceptanceStatus_Name().");
  return ConsentAcceptanceStatus_Name(static_cast<ConsentAcceptanceStatus>(value));
}
const std::string& ConsentAcceptanceStatus_Name(ConsentAcceptanceStatus value);
bool ConsentAcceptanceStatus_Parse(absl::string_view name, ConsentAcceptanceStatus* value);
enum ApkSource : int {
  UNKNOWN_APK_SOURCE = 0,
  APK_FROM_SD_CARD = 1,
  INSTALLED_APP = 2,
};

bool ApkSource_IsValid(int value);
constexpr ApkSource ApkSource_MIN = static_cast<ApkSource>(0);
constexpr ApkSource ApkSource_MAX = static_cast<ApkSource>(2);
constexpr int ApkSource_ARRAYSIZE = 2 + 1;
const std::string& ApkSource_Name(ApkSource value);
template <typename T>
const std::string& ApkSource_Name(T value) {
  static_assert(std::is_same<T, ApkSource>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ApkSource_Name().");
  return ApkSource_Name(static_cast<ApkSource>(value));
}
const std::string& ApkSource_Name(ApkSource value);
bool ApkSource_Parse(absl::string_view name, ApkSource* value);
enum InstallAPKStatus : int {
  UNKNOWN_INSTALL_APK_STATUS = 0,
  FAIL_INSTALLATION = 1,
  SUCCESS_INSTALLATION = 2,
};

bool InstallAPKStatus_IsValid(int value);
constexpr InstallAPKStatus InstallAPKStatus_MIN = static_cast<InstallAPKStatus>(0);
constexpr InstallAPKStatus InstallAPKStatus_MAX = static_cast<InstallAPKStatus>(2);
constexpr int InstallAPKStatus_ARRAYSIZE = 2 + 1;
const std::string& InstallAPKStatus_Name(InstallAPKStatus value);
template <typename T>
const std::string& InstallAPKStatus_Name(T value) {
  static_assert(std::is_same<T, InstallAPKStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InstallAPKStatus_Name().");
  return InstallAPKStatus_Name(static_cast<InstallAPKStatus>(value));
}
const std::string& InstallAPKStatus_Name(InstallAPKStatus value);
bool InstallAPKStatus_Parse(absl::string_view name, InstallAPKStatus* value);
enum VerifyAPKStatus : int {
  UNKNOWN_VERIFY_APK_STATUS = 0,
  NOT_INSTALLABLE = 1,
  INSTALLABLE = 2,
  ALREADY_INSTALLED = 3,
};

bool VerifyAPKStatus_IsValid(int value);
constexpr VerifyAPKStatus VerifyAPKStatus_MIN = static_cast<VerifyAPKStatus>(0);
constexpr VerifyAPKStatus VerifyAPKStatus_MAX = static_cast<VerifyAPKStatus>(3);
constexpr int VerifyAPKStatus_ARRAYSIZE = 3 + 1;
const std::string& VerifyAPKStatus_Name(VerifyAPKStatus value);
template <typename T>
const std::string& VerifyAPKStatus_Name(T value) {
  static_assert(std::is_same<T, VerifyAPKStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VerifyAPKStatus_Name().");
  return VerifyAPKStatus_Name(static_cast<VerifyAPKStatus>(value));
}
const std::string& VerifyAPKStatus_Name(VerifyAPKStatus value);
bool VerifyAPKStatus_Parse(absl::string_view name, VerifyAPKStatus* value);
enum ShowNotificationStatus : int {
  UNKNOWN_SHOW_NOTIFICATION_STATUS = 0,
  SHOW = 1,
  NOT_SHOW = 2,
};

bool ShowNotificationStatus_IsValid(int value);
constexpr ShowNotificationStatus ShowNotificationStatus_MIN = static_cast<ShowNotificationStatus>(0);
constexpr ShowNotificationStatus ShowNotificationStatus_MAX = static_cast<ShowNotificationStatus>(2);
constexpr int ShowNotificationStatus_ARRAYSIZE = 2 + 1;
const std::string& ShowNotificationStatus_Name(ShowNotificationStatus value);
template <typename T>
const std::string& ShowNotificationStatus_Name(T value) {
  static_assert(std::is_same<T, ShowNotificationStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShowNotificationStatus_Name().");
  return ShowNotificationStatus_Name(static_cast<ShowNotificationStatus>(value));
}
const std::string& ShowNotificationStatus_Name(ShowNotificationStatus value);
bool ShowNotificationStatus_Parse(absl::string_view name, ShowNotificationStatus* value);
enum PermissionRequestResult : int {
  PERMISSION_UNKNOWN_REQUEST_RESULT = 0,
  PERMISSION_GRANTED = 1,
  PERMISSION_REJECTED = 2,
  PERMISSION_UNABLE_TO_GRANT = 3,
};

bool PermissionRequestResult_IsValid(int value);
constexpr PermissionRequestResult PermissionRequestResult_MIN = static_cast<PermissionRequestResult>(0);
constexpr PermissionRequestResult PermissionRequestResult_MAX = static_cast<PermissionRequestResult>(3);
constexpr int PermissionRequestResult_ARRAYSIZE = 3 + 1;
const std::string& PermissionRequestResult_Name(PermissionRequestResult value);
template <typename T>
const std::string& PermissionRequestResult_Name(T value) {
  static_assert(std::is_same<T, PermissionRequestResult>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PermissionRequestResult_Name().");
  return PermissionRequestResult_Name(static_cast<PermissionRequestResult>(value));
}
const std::string& PermissionRequestResult_Name(PermissionRequestResult value);
bool PermissionRequestResult_Parse(absl::string_view name, PermissionRequestResult* value);
enum PermissionRequestType : int {
  PERMISSION_UNKNOWN_TYPE = 0,
  PERMISSION_AIRPLANE_MODE_OFF = 1,
  PERMISSION_WIFI = 2,
  PERMISSION_BLUETOOTH = 3,
  PERMISSION_LOCATION = 4,
  PERMISSION_WIFI_HOTSPOT = 5,
};

bool PermissionRequestType_IsValid(int value);
constexpr PermissionRequestType PermissionRequestType_MIN = static_cast<PermissionRequestType>(0);
constexpr PermissionRequestType PermissionRequestType_MAX = static_cast<PermissionRequestType>(5);
constexpr int PermissionRequestType_ARRAYSIZE = 5 + 1;
const std::string& PermissionRequestType_Name(PermissionRequestType value);
template <typename T>
const std::string& PermissionRequestType_Name(T value) {
  static_assert(std::is_same<T, PermissionRequestType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PermissionRequestType_Name().");
  return PermissionRequestType_Name(static_cast<PermissionRequestType>(value));
}
const std::string& PermissionRequestType_Name(PermissionRequestType value);
bool PermissionRequestType_Parse(absl::string_view name, PermissionRequestType* value);
enum SharingUseCase : int {
  USE_CASE_UNKNOWN = 0,
  USE_CASE_NEARBY_SHARE = 1,
  USE_CASE_REMOTE_COPY_PASTE = 2,
  USE_CASE_WIFI_CREDENTIAL = 3,
  USE_CASE_APP_SHARE = 4,
  USE_CASE_QUICK_SETTING_FILE_SHARE = 5,
  USE_CASE_SETUP_WIZARD = 6,
  USE_CASE_NEARBY_SHARE_WITH_QR_CODE = 7,
};

bool SharingUseCase_IsValid(int value);
constexpr SharingUseCase SharingUseCase_MIN = static_cast<SharingUseCase>(0);
constexpr SharingUseCase SharingUseCase_MAX = static_cast<SharingUseCase>(7);
constexpr int SharingUseCase_ARRAYSIZE = 7 + 1;
const std::string& SharingUseCase_Name(SharingUseCase value);
template <typename T>
const std::string& SharingUseCase_Name(T value) {
  static_assert(std::is_same<T, SharingUseCase>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SharingUseCase_Name().");
  return SharingUseCase_Name(static_cast<SharingUseCase>(value));
}
const std::string& SharingUseCase_Name(SharingUseCase value);
bool SharingUseCase_Parse(absl::string_view name, SharingUseCase* value);
enum AppCrashReason : int {
  APP_CRASH_REASON_UNKNOWN = 0,
};

bool AppCrashReason_IsValid(int value);
constexpr AppCrashReason AppCrashReason_MIN = static_cast<AppCrashReason>(0);
constexpr AppCrashReason AppCrashReason_MAX = static_cast<AppCrashReason>(0);
constexpr int AppCrashReason_ARRAYSIZE = 0 + 1;
const std::string& AppCrashReason_Name(AppCrashReason value);
template <typename T>
const std::string& AppCrashReason_Name(T value) {
  static_assert(std::is_same<T, AppCrashReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AppCrashReason_Name().");
  return AppCrashReason_Name(static_cast<AppCrashReason>(value));
}
const std::string& AppCrashReason_Name(AppCrashReason value);
bool AppCrashReason_Parse(absl::string_view name, AppCrashReason* value);
enum AttachmentSourceType : int {
  ATTACHMENT_SOURCE_UNKNOWN = 0,
  ATTACHMENT_SOURCE_CONTEXT_MENU = 1,
  ATTACHMENT_SOURCE_DRAG_AND_DROP = 2,
  ATTACHMENT_SOURCE_SELECT_FILES_BUTTON = 3,
  ATTACHMENT_SOURCE_PASTE = 4,
  ATTACHMENT_SOURCE_SELECT_FOLDERS_BUTTON = 5,
};

bool AttachmentSourceType_IsValid(int value);
constexpr AttachmentSourceType AttachmentSourceType_MIN = static_cast<AttachmentSourceType>(0);
constexpr AttachmentSourceType AttachmentSourceType_MAX = static_cast<AttachmentSourceType>(5);
constexpr int AttachmentSourceType_ARRAYSIZE = 5 + 1;
const std::string& AttachmentSourceType_Name(AttachmentSourceType value);
template <typename T>
const std::string& AttachmentSourceType_Name(T value) {
  static_assert(std::is_same<T, AttachmentSourceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AttachmentSourceType_Name().");
  return AttachmentSourceType_Name(static_cast<AttachmentSourceType>(value));
}
const std::string& AttachmentSourceType_Name(AttachmentSourceType value);
bool AttachmentSourceType_Parse(absl::string_view name, AttachmentSourceType* value);
enum PreferencesAction : int {
  PREFERENCES_ACTION_UNKNOWN = 0,
  PREFERENCES_ACTION_NO_ACTION = 1,
  PREFERENCES_ACTION_LOAD_PREFERENCES = 2,
  PREFERENCES_ACTION_SAVE_PREFERENCESS = 3,
  PREFERENCES_ACTION_ATTEMPT_LOAD = 4,
  PREFERENCES_ACTION_RESTORE_FROM_BACKUP = 5,
  PREFERENCES_ACTION_CREATE_PREFERENCES_PATH = 6,
  PREFERENCES_ACTION_MAKE_PREFERENCES_BACKUP_FILE = 7,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_PATH_EXISTS = 8,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_INPUT_STREAM_STATUS = 9,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_FILE_IS_CORRUPTED = 10,
  PREFERENCES_ACTION_CHECK_IF_PREFERENCES_BACKUP_FILE_EXISTS = 11,
};

bool PreferencesAction_IsValid(int value);
constexpr PreferencesAction PreferencesAction_MIN = static_cast<PreferencesAction>(0);
constexpr PreferencesAction PreferencesAction_MAX = static_cast<PreferencesAction>(11);
constexpr int PreferencesAction_ARRAYSIZE = 11 + 1;
const std::string& PreferencesAction_Name(PreferencesAction value);
template <typename T>
const std::string& PreferencesAction_Name(T value) {
  static_assert(std::is_same<T, PreferencesAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PreferencesAction_Name().");
  return PreferencesAction_Name(static_cast<PreferencesAction>(value));
}
const std::string& PreferencesAction_Name(PreferencesAction value);
bool PreferencesAction_Parse(absl::string_view name, PreferencesAction* value);
enum PreferencesActionStatus : int {
  PREFERENCES_ACTION_STATUS_UNKNOWN = 0,
  PREFERENCES_ACTION_STATUS_SUCCESS = 1,
  PREFERENCES_ACTION_STATUS_FAIL = 2,
};

bool PreferencesActionStatus_IsValid(int value);
constexpr PreferencesActionStatus PreferencesActionStatus_MIN = static_cast<PreferencesActionStatus>(0);
constexpr PreferencesActionStatus PreferencesActionStatus_MAX = static_cast<PreferencesActionStatus>(2);
constexpr int PreferencesActionStatus_ARRAYSIZE = 2 + 1;
const std::string& PreferencesActionStatus_Name(PreferencesActionStatus value);
template <typename T>
const std::string& PreferencesActionStatus_Name(T value) {
  static_assert(std::is_same<T, PreferencesActionStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PreferencesActionStatus_Name().");
  return PreferencesActionStatus_Name(static_cast<PreferencesActionStatus>(value));
}
const std::string& PreferencesActionStatus_Name(PreferencesActionStatus value);
bool PreferencesActionStatus_Parse(absl::string_view name, PreferencesActionStatus* value);
enum FastInitState : int {
  FAST_INIT_UNKNOWN_STATE = 0,
  FAST_INIT_CLOSE_STATE = 1,
  FAST_INIT_FAR_STATE = 2,
  FAST_INIT_LOST_STATE = 3,
};

bool FastInitState_IsValid(int value);
constexpr FastInitState FastInitState_MIN = static_cast<FastInitState>(0);
constexpr FastInitState FastInitState_MAX = static_cast<FastInitState>(3);
constexpr int FastInitState_ARRAYSIZE = 3 + 1;
const std::string& FastInitState_Name(FastInitState value);
template <typename T>
const std::string& FastInitState_Name(T value) {
  static_assert(std::is_same<T, FastInitState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FastInitState_Name().");
  return FastInitState_Name(static_cast<FastInitState>(value));
}
const std::string& FastInitState_Name(FastInitState value);
bool FastInitState_Parse(absl::string_view name, FastInitState* value);
enum FastInitType : int {
  FAST_INIT_UNKNOWN_TYPE = 0,
  FAST_INIT_NOTIFY_TYPE = 1,
  FAST_INIT_SILENT_TYPE = 2,
};

bool FastInitType_IsValid(int value);
constexpr FastInitType FastInitType_MIN = static_cast<FastInitType>(0);
constexpr FastInitType FastInitType_MAX = static_cast<FastInitType>(2);
constexpr int FastInitType_ARRAYSIZE = 2 + 1;
const std::string& FastInitType_Name(FastInitType value);
template <typename T>
const std::string& FastInitType_Name(T value) {
  static_assert(std::is_same<T, FastInitType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FastInitType_Name().");
  return FastInitType_Name(static_cast<FastInitType>(value));
}
const std::string& FastInitType_Name(FastInitType value);
bool FastInitType_Parse(absl::string_view name, FastInitType* value);
enum DesktopNotification : int {
  DESKTOP_NOTIFICATION_UNKNOWN = 0,
  DESKTOP_NOTIFICATION_CONNECTING = 1,
  DESKTOP_NOTIFICATION_PROGRESS = 2,
  DESKTOP_NOTIFICATION_ACCEPT = 3,
  DESKTOP_NOTIFICATION_RECEIVED = 4,
  DESKTOP_NOTIFICATION_ERROR = 5,
};

bool DesktopNotification_IsValid(int value);
constexpr DesktopNotification DesktopNotification_MIN = static_cast<DesktopNotification>(0);
constexpr DesktopNotification DesktopNotification_MAX = static_cast<DesktopNotification>(5);
constexpr int DesktopNotification_ARRAYSIZE = 5 + 1;
const std::string& DesktopNotification_Name(DesktopNotification value);
template <typename T>
const std::string& DesktopNotification_Name(T value) {
  static_assert(std::is_same<T, DesktopNotification>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DesktopNotification_Name().");
  return DesktopNotification_Name(static_cast<DesktopNotification>(value));
}
const std::string& DesktopNotification_Name(DesktopNotification value);
bool DesktopNotification_Parse(absl::string_view name, DesktopNotification* value);
enum DesktopTransferEventType : int {
  DESKTOP_TRANSFER_EVENT_TYPE_UNKNOWN = 0,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_ACCEPT = 1,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_PROGRESS = 2,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_RECEIVED = 3,
  DESKTOP_TRANSFER_EVENT_RECEIVE_TYPE_ERROR = 4,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_START = 5,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_SELECT_A_DEVICE = 6,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_PROGRESS = 7,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_SENT = 8,
  DESKTOP_TRANSFER_EVENT_SEND_TYPE_ERROR = 9,
};

bool DesktopTransferEventType_IsValid(int value);
constexpr DesktopTransferEventType DesktopTransferEventType_MIN = static_cast<DesktopTransferEventType>(0);
constexpr DesktopTransferEventType DesktopTransferEventType_MAX = static_cast<DesktopTransferEventType>(9);
constexpr int DesktopTransferEventType_ARRAYSIZE = 9 + 1;
const std::string& DesktopTransferEventType_Name(DesktopTransferEventType value);
template <typename T>
const std::string& DesktopTransferEventType_Name(T value) {
  static_assert(std::is_same<T, DesktopTransferEventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DesktopTransferEventType_Name().");
  return DesktopTransferEventType_Name(static_cast<DesktopTransferEventType>(value));
}
const std::string& DesktopTransferEventType_Name(DesktopTransferEventType value);
bool DesktopTransferEventType_Parse(absl::string_view name, DesktopTransferEventType* value);
enum DecryptCertificateFailureStatus : int {
  DECRYPT_CERT_UNKNOWN_FAILURE = 0,
  DECRYPT_CERT_NO_SUCH_ALGORITHM_FAILURE = 1,
  DECRYPT_CERT_NO_SUCH_PADDING_FAILURE = 2,
  DECRYPT_CERT_INVALID_KEY_FAILURE = 3,
  DECRYPT_CERT_INVALID_ALGORITHM_PARAMETER_FAILURE = 4,
  DECRYPT_CERT_ILLEGAL_BLOCK_SIZE_FAILURE = 5,
  DECRYPT_CERT_BAD_PADDING_FAILURE = 6,
};

bool DecryptCertificateFailureStatus_IsValid(int value);
constexpr DecryptCertificateFailureStatus DecryptCertificateFailureStatus_MIN = static_cast<DecryptCertificateFailureStatus>(0);
constexpr DecryptCertificateFailureStatus DecryptCertificateFailureStatus_MAX = static_cast<DecryptCertificateFailureStatus>(6);
constexpr int DecryptCertificateFailureStatus_ARRAYSIZE = 6 + 1;
const std::string& DecryptCertificateFailureStatus_Name(DecryptCertificateFailureStatus value);
template <typename T>
const std::string& DecryptCertificateFailureStatus_Name(T value) {
  static_assert(std::is_same<T, DecryptCertificateFailureStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DecryptCertificateFailureStatus_Name().");
  return DecryptCertificateFailureStatus_Name(static_cast<DecryptCertificateFailureStatus>(value));
}
const std::string& DecryptCertificateFailureStatus_Name(DecryptCertificateFailureStatus value);
bool DecryptCertificateFailureStatus_Parse(absl::string_view name, DecryptCertificateFailureStatus* value);

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sharing
}  // namespace proto
}  // namespace nearby
}  // namespace location


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::location::nearby::proto::sharing::EventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::EventCategory> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::NearbySharingStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::Visibility> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DataUsage> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::EstablishConnectionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AttachmentTransmissionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ConnectionLayerStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ProcessReceivedAttachmentsStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::SessionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ResponseToIntroduction> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DeviceType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::OSType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DeviceRelationship> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::LogSource> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ServerActionName> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ServerResponseState> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::SyncPurpose> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ClientRole> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ScanType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ParsingFailedType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AdvertisingMode> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DiscoveryMode> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ActivityName> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ConsentType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ConsentAcceptanceStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ApkSource> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::InstallAPKStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::VerifyAPKStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::ShowNotificationStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PermissionRequestResult> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PermissionRequestType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::SharingUseCase> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AppCrashReason> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::AttachmentSourceType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PreferencesAction> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::PreferencesActionStatus> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::FastInitState> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::FastInitType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DesktopNotification> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DesktopTransferEventType> : std::true_type {};
template <>
struct is_proto_enum<::location::nearby::proto::sharing::DecryptCertificateFailureStatus> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2fsharing_5fenums_2eproto_2epb_2eh
