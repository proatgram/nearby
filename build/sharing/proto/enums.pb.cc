// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing/proto/enums.proto

#include "sharing/proto/enums.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace nearby {
namespace sharing {
namespace proto {
}  // namespace proto
}  // namespace sharing
}  // namespace nearby
namespace nearby {
namespace sharing {
namespace proto {
bool FastInitiationNotificationState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    FastInitiationNotificationState_strings[4] = {};

static const char FastInitiationNotificationState_names[] = {
    "DISABLED_BY_FEATURE_FAST_INIT"
    "DISABLED_BY_USER_FAST_INIT"
    "ENABLED_FAST_INIT"
    "UNKNOWN_FAST_INIT"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FastInitiationNotificationState_entries[] =
    {
        {{&FastInitiationNotificationState_names[0], 29}, 3},
        {{&FastInitiationNotificationState_names[29], 26}, 2},
        {{&FastInitiationNotificationState_names[55], 17}, 1},
        {{&FastInitiationNotificationState_names[72], 17}, 0},
};

static const int FastInitiationNotificationState_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_FAST_INIT
    2,  // 1 -> ENABLED_FAST_INIT
    1,  // 2 -> DISABLED_BY_USER_FAST_INIT
    0,  // 3 -> DISABLED_BY_FEATURE_FAST_INIT
};

const std::string& FastInitiationNotificationState_Name(FastInitiationNotificationState value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FastInitiationNotificationState_entries, FastInitiationNotificationState_entries_by_number,
          4, FastInitiationNotificationState_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FastInitiationNotificationState_entries, FastInitiationNotificationState_entries_by_number, 4,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : FastInitiationNotificationState_strings[idx].get();
}

bool FastInitiationNotificationState_Parse(absl::string_view name, FastInitiationNotificationState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FastInitiationNotificationState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<FastInitiationNotificationState>(int_value);
  }
  return success;
}
bool DataUsage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    DataUsage_strings[4] = {};

static const char DataUsage_names[] = {
    "OFFLINE_DATA_USAGE"
    "ONLINE_DATA_USAGE"
    "UNKNOWN_DATA_USAGE"
    "WIFI_ONLY_DATA_USAGE"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataUsage_entries[] =
    {
        {{&DataUsage_names[0], 18}, 1},
        {{&DataUsage_names[18], 17}, 2},
        {{&DataUsage_names[35], 18}, 0},
        {{&DataUsage_names[53], 20}, 3},
};

static const int DataUsage_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_DATA_USAGE
    0,  // 1 -> OFFLINE_DATA_USAGE
    1,  // 2 -> ONLINE_DATA_USAGE
    3,  // 3 -> WIFI_ONLY_DATA_USAGE
};

const std::string& DataUsage_Name(DataUsage value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataUsage_entries, DataUsage_entries_by_number,
          4, DataUsage_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataUsage_entries, DataUsage_entries_by_number, 4,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : DataUsage_strings[idx].get();
}

bool DataUsage_Parse(absl::string_view name, DataUsage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataUsage_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DataUsage>(int_value);
  }
  return success;
}
bool DeviceVisibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    DeviceVisibility_strings[6] = {};

static const char DeviceVisibility_names[] = {
    "DEVICE_VISIBILITY_ALL_CONTACTS"
    "DEVICE_VISIBILITY_EVERYONE"
    "DEVICE_VISIBILITY_HIDDEN"
    "DEVICE_VISIBILITY_SELECTED_CONTACTS"
    "DEVICE_VISIBILITY_SELF_SHARE"
    "DEVICE_VISIBILITY_UNSPECIFIED"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DeviceVisibility_entries[] =
    {
        {{&DeviceVisibility_names[0], 30}, 3},
        {{&DeviceVisibility_names[30], 26}, 4},
        {{&DeviceVisibility_names[56], 24}, 1},
        {{&DeviceVisibility_names[80], 35}, 5},
        {{&DeviceVisibility_names[115], 28}, 2},
        {{&DeviceVisibility_names[143], 29}, 0},
};

static const int DeviceVisibility_entries_by_number[] = {
    5,  // 0 -> DEVICE_VISIBILITY_UNSPECIFIED
    2,  // 1 -> DEVICE_VISIBILITY_HIDDEN
    4,  // 2 -> DEVICE_VISIBILITY_SELF_SHARE
    0,  // 3 -> DEVICE_VISIBILITY_ALL_CONTACTS
    1,  // 4 -> DEVICE_VISIBILITY_EVERYONE
    3,  // 5 -> DEVICE_VISIBILITY_SELECTED_CONTACTS
};

const std::string& DeviceVisibility_Name(DeviceVisibility value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DeviceVisibility_entries, DeviceVisibility_entries_by_number,
          6, DeviceVisibility_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DeviceVisibility_entries, DeviceVisibility_entries_by_number, 6,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : DeviceVisibility_strings[idx].get();
}

bool DeviceVisibility_Parse(absl::string_view name, DeviceVisibility* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DeviceVisibility_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DeviceVisibility>(int_value);
  }
  return success;
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace sharing
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
