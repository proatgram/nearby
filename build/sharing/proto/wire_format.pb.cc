// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing/proto/wire_format.proto

#include "sharing/proto/wire_format.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace nearby {
namespace sharing {
namespace service {
namespace proto {
PROTOBUF_CONSTEXPR FileMetadata::FileMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.mime_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.parent_folder_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payload_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.size_)*/ ::int64_t{0}

  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.attachment_hash_)*/ ::int64_t{0}

  , /*decltype(_impl_.type_)*/ 0
} {}
struct FileMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileMetadataDefaultTypeInternal() {}
  union {
    FileMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileMetadataDefaultTypeInternal _FileMetadata_default_instance_;
PROTOBUF_CONSTEXPR TextMetadata::TextMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_title_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payload_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.size_)*/ ::int64_t{0}

  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.type_)*/ 0
} {}
struct TextMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextMetadataDefaultTypeInternal() {}
  union {
    TextMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextMetadataDefaultTypeInternal _TextMetadata_default_instance_;
PROTOBUF_CONSTEXPR WifiCredentialsMetadata::WifiCredentialsMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ssid_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.payload_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.security_type_)*/ 0
} {}
struct WifiCredentialsMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WifiCredentialsMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WifiCredentialsMetadataDefaultTypeInternal() {}
  union {
    WifiCredentialsMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WifiCredentialsMetadataDefaultTypeInternal _WifiCredentialsMetadata_default_instance_;
PROTOBUF_CONSTEXPR AppMetadata::AppMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_id_)*/ {}
  ,/* _impl_._payload_id_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.file_name_)*/{}
  , /*decltype(_impl_.file_size_)*/ {}
  ,/* _impl_._file_size_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.app_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.package_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.size_)*/ ::int64_t{0}

  , /*decltype(_impl_.id_)*/ ::int64_t{0}
} {}
struct AppMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AppMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AppMetadataDefaultTypeInternal() {}
  union {
    AppMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppMetadataDefaultTypeInternal _AppMetadata_default_instance_;
PROTOBUF_CONSTEXPR Frame::Frame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.v1_)*/nullptr
  , /*decltype(_impl_.version_)*/ 0
} {}
struct FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDefaultTypeInternal() {}
  union {
    Frame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDefaultTypeInternal _Frame_default_instance_;
PROTOBUF_CONSTEXPR V1Frame::V1Frame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.introduction_)*/nullptr
  , /*decltype(_impl_.connection_response_)*/nullptr
  , /*decltype(_impl_.paired_key_encryption_)*/nullptr
  , /*decltype(_impl_.paired_key_result_)*/nullptr
  , /*decltype(_impl_.certificate_info_)*/nullptr
  , /*decltype(_impl_.progress_update_)*/nullptr
  , /*decltype(_impl_.type_)*/ 0
} {}
struct V1FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V1FrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~V1FrameDefaultTypeInternal() {}
  union {
    V1Frame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V1FrameDefaultTypeInternal _V1Frame_default_instance_;
PROTOBUF_CONSTEXPR IntroductionFrame::IntroductionFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.file_metadata_)*/{}
  , /*decltype(_impl_.text_metadata_)*/{}
  , /*decltype(_impl_.wifi_credentials_metadata_)*/{}
  , /*decltype(_impl_.app_metadata_)*/{}
  , /*decltype(_impl_.required_package_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_transfer_)*/ false
} {}
struct IntroductionFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntroductionFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntroductionFrameDefaultTypeInternal() {}
  union {
    IntroductionFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntroductionFrameDefaultTypeInternal _IntroductionFrame_default_instance_;
PROTOBUF_CONSTEXPR ProgressUpdateFrame::ProgressUpdateFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.progress_)*/ 0

  , /*decltype(_impl_.start_transfer_)*/ false
} {}
struct ProgressUpdateFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProgressUpdateFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProgressUpdateFrameDefaultTypeInternal() {}
  union {
    ProgressUpdateFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProgressUpdateFrameDefaultTypeInternal _ProgressUpdateFrame_default_instance_;
PROTOBUF_CONSTEXPR ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUseDefaultTypeInternal _ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ConnectionResponseFrame::ConnectionResponseFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachment_details_)*/{}
  , /*decltype(_impl_.status_)*/ 0
} {}
struct ConnectionResponseFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionResponseFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionResponseFrameDefaultTypeInternal() {}
  union {
    ConnectionResponseFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
PROTOBUF_CONSTEXPR AttachmentDetails::AttachmentDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.file_attachment_details_)*/nullptr
  , /*decltype(_impl_.type_)*/ 0
} {}
struct AttachmentDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttachmentDetailsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttachmentDetailsDefaultTypeInternal() {}
  union {
    AttachmentDetails _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttachmentDetailsDefaultTypeInternal _AttachmentDetails_default_instance_;
PROTOBUF_CONSTEXPR FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUseDefaultTypeInternal _FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FileAttachmentDetails::FileAttachmentDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachment_hash_payloads_)*/{}
  , /*decltype(_impl_.receiver_existing_file_size_)*/ ::int64_t{0}
} {}
struct FileAttachmentDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileAttachmentDetailsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileAttachmentDetailsDefaultTypeInternal() {}
  union {
    FileAttachmentDetails _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileAttachmentDetailsDefaultTypeInternal _FileAttachmentDetails_default_instance_;
PROTOBUF_CONSTEXPR PayloadsDetails::PayloadsDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_details_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PayloadsDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayloadsDetailsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayloadsDetailsDefaultTypeInternal() {}
  union {
    PayloadsDetails _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayloadsDetailsDefaultTypeInternal _PayloadsDetails_default_instance_;
PROTOBUF_CONSTEXPR PayloadDetails::PayloadDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ ::int64_t{0}

  , /*decltype(_impl_.creation_timestamp_millis_)*/ ::int64_t{0}

  , /*decltype(_impl_.size_)*/ ::int64_t{0}
} {}
struct PayloadDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PayloadDetailsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PayloadDetailsDefaultTypeInternal() {}
  union {
    PayloadDetails _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PayloadDetailsDefaultTypeInternal _PayloadDetails_default_instance_;
PROTOBUF_CONSTEXPR PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signed_data_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.secret_id_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.optional_signed_data_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.qr_code_handshake_data_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct PairedKeyEncryptionFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PairedKeyEncryptionFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PairedKeyEncryptionFrameDefaultTypeInternal() {}
  union {
    PairedKeyEncryptionFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
PROTOBUF_CONSTEXPR PairedKeyResultFrame::PairedKeyResultFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.status_)*/ 0

  , /*decltype(_impl_.os_type_)*/ 0
} {}
struct PairedKeyResultFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PairedKeyResultFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PairedKeyResultFrameDefaultTypeInternal() {}
  union {
    PairedKeyResultFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PairedKeyResultFrameDefaultTypeInternal _PairedKeyResultFrame_default_instance_;
PROTOBUF_CONSTEXPR CertificateInfoFrame::CertificateInfoFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.public_certificate_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CertificateInfoFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertificateInfoFrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertificateInfoFrameDefaultTypeInternal() {}
  union {
    CertificateInfoFrame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertificateInfoFrameDefaultTypeInternal _CertificateInfoFrame_default_instance_;
PROTOBUF_CONSTEXPR PublicCertificate::PublicCertificate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.secret_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.authenticity_key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.public_key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.encrypted_metadata_bytes_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.metadata_encryption_key_tag_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}
} {}
struct PublicCertificateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PublicCertificateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PublicCertificateDefaultTypeInternal() {}
  union {
    PublicCertificate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicCertificateDefaultTypeInternal _PublicCertificate_default_instance_;
PROTOBUF_CONSTEXPR WifiCredentials::WifiCredentials(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.password_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.hidden_ssid_)*/ false
} {}
struct WifiCredentialsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WifiCredentialsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WifiCredentialsDefaultTypeInternal() {}
  union {
    WifiCredentials _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WifiCredentialsDefaultTypeInternal _WifiCredentials_default_instance_;
}  // namespace proto
}  // namespace service
}  // namespace sharing
}  // namespace nearby
namespace nearby {
namespace sharing {
namespace service {
namespace proto {
bool FileMetadata_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    FileMetadata_Type_strings[6] = {};

static const char FileMetadata_Type_names[] = {
    "ANDROID_APP"
    "AUDIO"
    "DOCUMENT"
    "IMAGE"
    "UNKNOWN"
    "VIDEO"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FileMetadata_Type_entries[] =
    {
        {{&FileMetadata_Type_names[0], 11}, 3},
        {{&FileMetadata_Type_names[11], 5}, 4},
        {{&FileMetadata_Type_names[16], 8}, 5},
        {{&FileMetadata_Type_names[24], 5}, 1},
        {{&FileMetadata_Type_names[29], 7}, 0},
        {{&FileMetadata_Type_names[36], 5}, 2},
};

static const int FileMetadata_Type_entries_by_number[] = {
    4,  // 0 -> UNKNOWN
    3,  // 1 -> IMAGE
    5,  // 2 -> VIDEO
    0,  // 3 -> ANDROID_APP
    1,  // 4 -> AUDIO
    2,  // 5 -> DOCUMENT
};

const std::string& FileMetadata_Type_Name(FileMetadata_Type value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FileMetadata_Type_entries, FileMetadata_Type_entries_by_number,
          6, FileMetadata_Type_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FileMetadata_Type_entries, FileMetadata_Type_entries_by_number, 6,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : FileMetadata_Type_strings[idx].get();
}

bool FileMetadata_Type_Parse(absl::string_view name, FileMetadata_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FileMetadata_Type_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<FileMetadata_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr FileMetadata_Type FileMetadata::UNKNOWN;
constexpr FileMetadata_Type FileMetadata::IMAGE;
constexpr FileMetadata_Type FileMetadata::VIDEO;
constexpr FileMetadata_Type FileMetadata::ANDROID_APP;
constexpr FileMetadata_Type FileMetadata::AUDIO;
constexpr FileMetadata_Type FileMetadata::DOCUMENT;
constexpr FileMetadata_Type FileMetadata::Type_MIN;
constexpr FileMetadata_Type FileMetadata::Type_MAX;
constexpr int FileMetadata::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TextMetadata_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    TextMetadata_Type_strings[5] = {};

static const char TextMetadata_Type_names[] = {
    "ADDRESS"
    "PHONE_NUMBER"
    "TEXT"
    "UNKNOWN"
    "URL"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TextMetadata_Type_entries[] =
    {
        {{&TextMetadata_Type_names[0], 7}, 3},
        {{&TextMetadata_Type_names[7], 12}, 4},
        {{&TextMetadata_Type_names[19], 4}, 1},
        {{&TextMetadata_Type_names[23], 7}, 0},
        {{&TextMetadata_Type_names[30], 3}, 2},
};

static const int TextMetadata_Type_entries_by_number[] = {
    3,  // 0 -> UNKNOWN
    2,  // 1 -> TEXT
    4,  // 2 -> URL
    0,  // 3 -> ADDRESS
    1,  // 4 -> PHONE_NUMBER
};

const std::string& TextMetadata_Type_Name(TextMetadata_Type value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TextMetadata_Type_entries, TextMetadata_Type_entries_by_number,
          5, TextMetadata_Type_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TextMetadata_Type_entries, TextMetadata_Type_entries_by_number, 5,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : TextMetadata_Type_strings[idx].get();
}

bool TextMetadata_Type_Parse(absl::string_view name, TextMetadata_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TextMetadata_Type_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TextMetadata_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TextMetadata_Type TextMetadata::UNKNOWN;
constexpr TextMetadata_Type TextMetadata::TEXT;
constexpr TextMetadata_Type TextMetadata::URL;
constexpr TextMetadata_Type TextMetadata::ADDRESS;
constexpr TextMetadata_Type TextMetadata::PHONE_NUMBER;
constexpr TextMetadata_Type TextMetadata::Type_MIN;
constexpr TextMetadata_Type TextMetadata::Type_MAX;
constexpr int TextMetadata::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WifiCredentialsMetadata_SecurityType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    WifiCredentialsMetadata_SecurityType_strings[5] = {};

static const char WifiCredentialsMetadata_SecurityType_names[] = {
    "OPEN"
    "SAE"
    "UNKNOWN_SECURITY_TYPE"
    "WEP"
    "WPA_PSK"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WifiCredentialsMetadata_SecurityType_entries[] =
    {
        {{&WifiCredentialsMetadata_SecurityType_names[0], 4}, 1},
        {{&WifiCredentialsMetadata_SecurityType_names[4], 3}, 4},
        {{&WifiCredentialsMetadata_SecurityType_names[7], 21}, 0},
        {{&WifiCredentialsMetadata_SecurityType_names[28], 3}, 3},
        {{&WifiCredentialsMetadata_SecurityType_names[31], 7}, 2},
};

static const int WifiCredentialsMetadata_SecurityType_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_SECURITY_TYPE
    0,  // 1 -> OPEN
    4,  // 2 -> WPA_PSK
    3,  // 3 -> WEP
    1,  // 4 -> SAE
};

const std::string& WifiCredentialsMetadata_SecurityType_Name(WifiCredentialsMetadata_SecurityType value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WifiCredentialsMetadata_SecurityType_entries, WifiCredentialsMetadata_SecurityType_entries_by_number,
          5, WifiCredentialsMetadata_SecurityType_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WifiCredentialsMetadata_SecurityType_entries, WifiCredentialsMetadata_SecurityType_entries_by_number, 5,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : WifiCredentialsMetadata_SecurityType_strings[idx].get();
}

bool WifiCredentialsMetadata_SecurityType_Parse(absl::string_view name, WifiCredentialsMetadata_SecurityType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WifiCredentialsMetadata_SecurityType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<WifiCredentialsMetadata_SecurityType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::UNKNOWN_SECURITY_TYPE;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::OPEN;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::WPA_PSK;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::WEP;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::SAE;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::SecurityType_MIN;
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::SecurityType_MAX;
constexpr int WifiCredentialsMetadata::SecurityType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Frame_Version_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    Frame_Version_strings[2] = {};

static const char Frame_Version_names[] = {
    "UNKNOWN_VERSION"
    "V1"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Frame_Version_entries[] =
    {
        {{&Frame_Version_names[0], 15}, 0},
        {{&Frame_Version_names[15], 2}, 1},
};

static const int Frame_Version_entries_by_number[] = {
    0,  // 0 -> UNKNOWN_VERSION
    1,  // 1 -> V1
};

const std::string& Frame_Version_Name(Frame_Version value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Frame_Version_entries, Frame_Version_entries_by_number,
          2, Frame_Version_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Frame_Version_entries, Frame_Version_entries_by_number, 2,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : Frame_Version_strings[idx].get();
}

bool Frame_Version_Parse(absl::string_view name, Frame_Version* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Frame_Version_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Frame_Version>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Frame_Version Frame::UNKNOWN_VERSION;
constexpr Frame_Version Frame::V1;
constexpr Frame_Version Frame::Version_MIN;
constexpr Frame_Version Frame::Version_MAX;
constexpr int Frame::Version_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool V1Frame_FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    V1Frame_FrameType_strings[8] = {};

static const char V1Frame_FrameType_names[] = {
    "CANCEL"
    "CERTIFICATE_INFO"
    "INTRODUCTION"
    "PAIRED_KEY_ENCRYPTION"
    "PAIRED_KEY_RESULT"
    "PROGRESS_UPDATE"
    "RESPONSE"
    "UNKNOWN_FRAME_TYPE"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V1Frame_FrameType_entries[] =
    {
        {{&V1Frame_FrameType_names[0], 6}, 6},
        {{&V1Frame_FrameType_names[6], 16}, 5},
        {{&V1Frame_FrameType_names[22], 12}, 1},
        {{&V1Frame_FrameType_names[34], 21}, 3},
        {{&V1Frame_FrameType_names[55], 17}, 4},
        {{&V1Frame_FrameType_names[72], 15}, 7},
        {{&V1Frame_FrameType_names[87], 8}, 2},
        {{&V1Frame_FrameType_names[95], 18}, 0},
};

static const int V1Frame_FrameType_entries_by_number[] = {
    7,  // 0 -> UNKNOWN_FRAME_TYPE
    2,  // 1 -> INTRODUCTION
    6,  // 2 -> RESPONSE
    3,  // 3 -> PAIRED_KEY_ENCRYPTION
    4,  // 4 -> PAIRED_KEY_RESULT
    1,  // 5 -> CERTIFICATE_INFO
    0,  // 6 -> CANCEL
    5,  // 7 -> PROGRESS_UPDATE
};

const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V1Frame_FrameType_entries, V1Frame_FrameType_entries_by_number,
          8, V1Frame_FrameType_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V1Frame_FrameType_entries, V1Frame_FrameType_entries_by_number, 8,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : V1Frame_FrameType_strings[idx].get();
}

bool V1Frame_FrameType_Parse(absl::string_view name, V1Frame_FrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V1Frame_FrameType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<V1Frame_FrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr V1Frame_FrameType V1Frame::UNKNOWN_FRAME_TYPE;
constexpr V1Frame_FrameType V1Frame::INTRODUCTION;
constexpr V1Frame_FrameType V1Frame::RESPONSE;
constexpr V1Frame_FrameType V1Frame::PAIRED_KEY_ENCRYPTION;
constexpr V1Frame_FrameType V1Frame::PAIRED_KEY_RESULT;
constexpr V1Frame_FrameType V1Frame::CERTIFICATE_INFO;
constexpr V1Frame_FrameType V1Frame::CANCEL;
constexpr V1Frame_FrameType V1Frame::PROGRESS_UPDATE;
constexpr V1Frame_FrameType V1Frame::FrameType_MIN;
constexpr V1Frame_FrameType V1Frame::FrameType_MAX;
constexpr int V1Frame::FrameType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConnectionResponseFrame_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ConnectionResponseFrame_Status_strings[6] = {};

static const char ConnectionResponseFrame_Status_names[] = {
    "ACCEPT"
    "NOT_ENOUGH_SPACE"
    "REJECT"
    "TIMED_OUT"
    "UNKNOWN"
    "UNSUPPORTED_ATTACHMENT_TYPE"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConnectionResponseFrame_Status_entries[] =
    {
        {{&ConnectionResponseFrame_Status_names[0], 6}, 1},
        {{&ConnectionResponseFrame_Status_names[6], 16}, 3},
        {{&ConnectionResponseFrame_Status_names[22], 6}, 2},
        {{&ConnectionResponseFrame_Status_names[28], 9}, 5},
        {{&ConnectionResponseFrame_Status_names[37], 7}, 0},
        {{&ConnectionResponseFrame_Status_names[44], 27}, 4},
};

static const int ConnectionResponseFrame_Status_entries_by_number[] = {
    4,  // 0 -> UNKNOWN
    0,  // 1 -> ACCEPT
    2,  // 2 -> REJECT
    1,  // 3 -> NOT_ENOUGH_SPACE
    5,  // 4 -> UNSUPPORTED_ATTACHMENT_TYPE
    3,  // 5 -> TIMED_OUT
};

const std::string& ConnectionResponseFrame_Status_Name(ConnectionResponseFrame_Status value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConnectionResponseFrame_Status_entries, ConnectionResponseFrame_Status_entries_by_number,
          6, ConnectionResponseFrame_Status_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConnectionResponseFrame_Status_entries, ConnectionResponseFrame_Status_entries_by_number, 6,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : ConnectionResponseFrame_Status_strings[idx].get();
}

bool ConnectionResponseFrame_Status_Parse(absl::string_view name, ConnectionResponseFrame_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConnectionResponseFrame_Status_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ConnectionResponseFrame_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::UNKNOWN;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::ACCEPT;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::REJECT;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::NOT_ENOUGH_SPACE;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::UNSUPPORTED_ATTACHMENT_TYPE;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::TIMED_OUT;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::Status_MIN;
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame::Status_MAX;
constexpr int ConnectionResponseFrame::Status_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AttachmentDetails_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    AttachmentDetails_Type_strings[5] = {};

static const char AttachmentDetails_Type_names[] = {
    "APP"
    "FILE"
    "TEXT"
    "UNKNOWN"
    "WIFI_CREDENTIALS"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AttachmentDetails_Type_entries[] =
    {
        {{&AttachmentDetails_Type_names[0], 3}, 4},
        {{&AttachmentDetails_Type_names[3], 4}, 1},
        {{&AttachmentDetails_Type_names[7], 4}, 2},
        {{&AttachmentDetails_Type_names[11], 7}, 0},
        {{&AttachmentDetails_Type_names[18], 16}, 3},
};

static const int AttachmentDetails_Type_entries_by_number[] = {
    3,  // 0 -> UNKNOWN
    1,  // 1 -> FILE
    2,  // 2 -> TEXT
    4,  // 3 -> WIFI_CREDENTIALS
    0,  // 4 -> APP
};

const std::string& AttachmentDetails_Type_Name(AttachmentDetails_Type value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AttachmentDetails_Type_entries, AttachmentDetails_Type_entries_by_number,
          5, AttachmentDetails_Type_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AttachmentDetails_Type_entries, AttachmentDetails_Type_entries_by_number, 5,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : AttachmentDetails_Type_strings[idx].get();
}

bool AttachmentDetails_Type_Parse(absl::string_view name, AttachmentDetails_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AttachmentDetails_Type_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<AttachmentDetails_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr AttachmentDetails_Type AttachmentDetails::UNKNOWN;
constexpr AttachmentDetails_Type AttachmentDetails::FILE;
constexpr AttachmentDetails_Type AttachmentDetails::TEXT;
constexpr AttachmentDetails_Type AttachmentDetails::WIFI_CREDENTIALS;
constexpr AttachmentDetails_Type AttachmentDetails::APP;
constexpr AttachmentDetails_Type AttachmentDetails::Type_MIN;
constexpr AttachmentDetails_Type AttachmentDetails::Type_MAX;
constexpr int AttachmentDetails::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PairedKeyResultFrame_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    PairedKeyResultFrame_Status_strings[4] = {};

static const char PairedKeyResultFrame_Status_names[] = {
    "FAIL"
    "SUCCESS"
    "UNABLE"
    "UNKNOWN"
};

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PairedKeyResultFrame_Status_entries[] =
    {
        {{&PairedKeyResultFrame_Status_names[0], 4}, 2},
        {{&PairedKeyResultFrame_Status_names[4], 7}, 1},
        {{&PairedKeyResultFrame_Status_names[11], 6}, 3},
        {{&PairedKeyResultFrame_Status_names[17], 7}, 0},
};

static const int PairedKeyResultFrame_Status_entries_by_number[] = {
    3,  // 0 -> UNKNOWN
    1,  // 1 -> SUCCESS
    0,  // 2 -> FAIL
    2,  // 3 -> UNABLE
};

const std::string& PairedKeyResultFrame_Status_Name(PairedKeyResultFrame_Status value) {
  static const bool kDummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PairedKeyResultFrame_Status_entries, PairedKeyResultFrame_Status_entries_by_number,
          4, PairedKeyResultFrame_Status_strings);
  (void)kDummy;

  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PairedKeyResultFrame_Status_entries, PairedKeyResultFrame_Status_entries_by_number, 4,
      value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                   : PairedKeyResultFrame_Status_strings[idx].get();
}

bool PairedKeyResultFrame_Status_Parse(absl::string_view name, PairedKeyResultFrame_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PairedKeyResultFrame_Status_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<PairedKeyResultFrame_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::UNKNOWN;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::SUCCESS;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::FAIL;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::UNABLE;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::Status_MIN;
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame::Status_MAX;
constexpr int PairedKeyResultFrame::Status_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class FileMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<FileMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FileMetadata, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mime_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_parent_folder(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attachment_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

/*static*/ const ::_pbi::LazyString FileMetadata::Impl_::_i_give_permission_to_break_this_code_default_mime_type_{
    {{"application/octet-stream", 24}},
    {nullptr},
};
FileMetadata::FileMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.FileMetadata)
}
FileMetadata::FileMetadata(const FileMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.mime_type_) {}

    , decltype(_impl_.parent_folder_) {}

    , decltype(_impl_.payload_id_) {}

    , decltype(_impl_.size_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.attachment_hash_) {}

    , decltype(_impl_.type_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  _impl_.mime_type_.InitDefault();
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.mime_type_.Set(from._internal_mime_type(), _this->GetArenaForAllocation());
  }
  _impl_.parent_folder_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_folder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.parent_folder_.Set(from._internal_parent_folder(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.payload_id_, &from._impl_.payload_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.FileMetadata)
}

inline void FileMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.mime_type_) {}

    , decltype(_impl_.parent_folder_) {}

    , decltype(_impl_.payload_id_) { ::int64_t{0} }

    , decltype(_impl_.size_) { ::int64_t{0} }

    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.attachment_hash_) { ::int64_t{0} }

    , decltype(_impl_.type_) { 0 }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mime_type_.InitDefault();
  _impl_.parent_folder_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_folder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileMetadata::~FileMetadata() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.FileMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.mime_type_.Destroy();
  _impl_.parent_folder_.Destroy();
}

void FileMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.FileMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.mime_type_.ClearToDefault(::nearby::sharing::service::proto::FileMetadata::Impl_::_i_give_permission_to_break_this_code_default_mime_type_, GetArenaForAllocation());
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.parent_folder_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.payload_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FileMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.FileMetadata.Type type = 2 [default = UNKNOWN];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::FileMetadata_Type_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::nearby::sharing::service::proto::FileMetadata_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 payload_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_payload_id(&has_bits);
          _impl_.payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string mime_type = 5 [default = "application/octet-stream"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mime_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string parent_folder = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_parent_folder();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 attachment_hash = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _Internal::set_has_attachment_hash(&has_bits);
          _impl_.attachment_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FileMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.FileMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .nearby.sharing.service.proto.FileMetadata.Type type = 2 [default = UNKNOWN];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_type(), target);
  }

  // optional int64 payload_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_payload_id(), target);
  }

  // optional int64 size = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_size(), target);
  }

  // optional string mime_type = 5 [default = "application/octet-stream"];
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_mime_type();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional int64 id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_id(), target);
  }

  // optional string parent_folder = 7;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_parent_folder();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional int64 attachment_hash = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        8, this->_internal_attachment_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.FileMetadata)
  return target;
}

::size_t FileMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.FileMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // optional string mime_type = 5 [default = "application/octet-stream"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_mime_type());
    }

    // optional string parent_folder = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_parent_folder());
    }

    // optional int64 payload_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_payload_id());
    }

    // optional int64 size = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_size());
    }

    // optional int64 id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_id());
    }

    // optional int64 attachment_hash = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_attachment_hash());
    }

    // optional .nearby.sharing.service.proto.FileMetadata.Type type = 2 [default = UNKNOWN];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileMetadata*>(
      &from));
}

void FileMetadata::MergeFrom(const FileMetadata& from) {
  FileMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.FileMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_mime_type(from._internal_mime_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_parent_folder(from._internal_parent_folder());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.payload_id_ = from._impl_.payload_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.attachment_hash_ = from._impl_.attachment_hash_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileMetadata::CopyFrom(const FileMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.FileMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileMetadata::IsInitialized() const {
  return true;
}

void FileMetadata::InternalSwap(FileMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mime_type_, lhs_arena,
                                       &other->_impl_.mime_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.parent_folder_, lhs_arena,
                                       &other->_impl_.parent_folder_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileMetadata, _impl_.type_)
      + sizeof(FileMetadata::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(FileMetadata, _impl_.payload_id_)>(
          reinterpret_cast<char*>(&_impl_.payload_id_),
          reinterpret_cast<char*>(&other->_impl_.payload_id_));
}

std::string FileMetadata::GetTypeName() const {
  return "nearby.sharing.service.proto.FileMetadata";
}

// ===================================================================

class TextMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<TextMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TextMetadata, _impl_._has_bits_);
  static void set_has_text_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TextMetadata::TextMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.TextMetadata)
}
TextMetadata::TextMetadata(const TextMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TextMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_title_) {}

    , decltype(_impl_.payload_id_) {}

    , decltype(_impl_.size_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.type_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.text_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.text_title_.Set(from._internal_text_title(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.payload_id_, &from._impl_.payload_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.TextMetadata)
}

inline void TextMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_title_) {}

    , decltype(_impl_.payload_id_) { ::int64_t{0} }

    , decltype(_impl_.size_) { ::int64_t{0} }

    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.type_) { 0 }

  };
  _impl_.text_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TextMetadata::~TextMetadata() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.TextMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_title_.Destroy();
}

void TextMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.TextMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.text_title_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.payload_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TextMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text_title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.TextMetadata.Type type = 3 [default = UNKNOWN];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::TextMetadata_Type_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::nearby::sharing::service::proto::TextMetadata_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 payload_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_payload_id(&has_bits);
          _impl_.payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TextMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.TextMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string text_title = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_text_title();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .nearby.sharing.service.proto.TextMetadata.Type type = 3 [default = UNKNOWN];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_type(), target);
  }

  // optional int64 payload_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_payload_id(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_size(), target);
  }

  // optional int64 id = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        6, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.TextMetadata)
  return target;
}

::size_t TextMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.TextMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string text_title = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_text_title());
    }

    // optional int64 payload_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_payload_id());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_size());
    }

    // optional int64 id = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_id());
    }

    // optional .nearby.sharing.service.proto.TextMetadata.Type type = 3 [default = UNKNOWN];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextMetadata*>(
      &from));
}

void TextMetadata::MergeFrom(const TextMetadata& from) {
  TextMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.TextMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text_title(from._internal_text_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.payload_id_ = from._impl_.payload_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextMetadata::CopyFrom(const TextMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.TextMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextMetadata::IsInitialized() const {
  return true;
}

void TextMetadata::InternalSwap(TextMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.text_title_, lhs_arena,
                                       &other->_impl_.text_title_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextMetadata, _impl_.type_)
      + sizeof(TextMetadata::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(TextMetadata, _impl_.payload_id_)>(
          reinterpret_cast<char*>(&_impl_.payload_id_),
          reinterpret_cast<char*>(&other->_impl_.payload_id_));
}

std::string TextMetadata::GetTypeName() const {
  return "nearby.sharing.service.proto.TextMetadata";
}

// ===================================================================

class WifiCredentialsMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<WifiCredentialsMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WifiCredentialsMetadata, _impl_._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_security_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_payload_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

WifiCredentialsMetadata::WifiCredentialsMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.WifiCredentialsMetadata)
}
WifiCredentialsMetadata::WifiCredentialsMetadata(const WifiCredentialsMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WifiCredentialsMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ssid_) {}

    , decltype(_impl_.payload_id_) {}

    , decltype(_impl_.id_) {}

    , decltype(_impl_.security_type_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.ssid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.ssid_.Set(from._internal_ssid(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.payload_id_, &from._impl_.payload_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.security_type_) -
    reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.security_type_));
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.WifiCredentialsMetadata)
}

inline void WifiCredentialsMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ssid_) {}

    , decltype(_impl_.payload_id_) { ::int64_t{0} }

    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.security_type_) { 0 }

  };
  _impl_.ssid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WifiCredentialsMetadata::~WifiCredentialsMetadata() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.WifiCredentialsMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WifiCredentialsMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ssid_.Destroy();
}

void WifiCredentialsMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WifiCredentialsMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.WifiCredentialsMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ssid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.payload_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.security_type_) -
        reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.security_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiCredentialsMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ssid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ssid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType_IsValid(static_cast<int>(val)))) {
            _internal_set_security_type(static_cast<::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 payload_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_payload_id(&has_bits);
          _impl_.payload_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WifiCredentialsMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.WifiCredentialsMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string ssid = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_ssid();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .nearby.sharing.service.proto.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_security_type(), target);
  }

  // optional int64 payload_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_payload_id(), target);
  }

  // optional int64 id = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.WifiCredentialsMetadata)
  return target;
}

::size_t WifiCredentialsMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.WifiCredentialsMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string ssid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_ssid());
    }

    // optional int64 payload_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_payload_id());
    }

    // optional int64 id = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_id());
    }

    // optional .nearby.sharing.service.proto.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_security_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiCredentialsMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WifiCredentialsMetadata*>(
      &from));
}

void WifiCredentialsMetadata::MergeFrom(const WifiCredentialsMetadata& from) {
  WifiCredentialsMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.WifiCredentialsMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.payload_id_ = from._impl_.payload_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.security_type_ = from._impl_.security_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiCredentialsMetadata::CopyFrom(const WifiCredentialsMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.WifiCredentialsMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiCredentialsMetadata::IsInitialized() const {
  return true;
}

void WifiCredentialsMetadata::InternalSwap(WifiCredentialsMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ssid_, lhs_arena,
                                       &other->_impl_.ssid_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WifiCredentialsMetadata, _impl_.security_type_)
      + sizeof(WifiCredentialsMetadata::_impl_.security_type_)
      - PROTOBUF_FIELD_OFFSET(WifiCredentialsMetadata, _impl_.payload_id_)>(
          reinterpret_cast<char*>(&_impl_.payload_id_),
          reinterpret_cast<char*>(&other->_impl_.payload_id_));
}

std::string WifiCredentialsMetadata::GetTypeName() const {
  return "nearby.sharing.service.proto.WifiCredentialsMetadata";
}

// ===================================================================

class AppMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<AppMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AppMetadata, _impl_._has_bits_);
  static void set_has_app_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AppMetadata::AppMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.AppMetadata)
}
AppMetadata::AppMetadata(const AppMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AppMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_id_) { from._impl_.payload_id_ }
    ,/* _impl_._payload_id_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.file_name_){from._impl_.file_name_}
    , decltype(_impl_.file_size_) { from._impl_.file_size_ }
    ,/* _impl_._file_size_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.app_name_) {}

    , decltype(_impl_.package_name_) {}

    , decltype(_impl_.size_) {}

    , decltype(_impl_.id_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.app_name_.Set(from._internal_app_name(), _this->GetArenaForAllocation());
  }
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.package_name_.Set(from._internal_package_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.AppMetadata)
}

inline void AppMetadata::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_id_) { arena }
    ,/* _impl_._payload_id_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.file_name_){arena}
    , decltype(_impl_.file_size_) { arena }
    ,/* _impl_._file_size_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.app_name_) {}

    , decltype(_impl_.package_name_) {}

    , decltype(_impl_.size_) { ::int64_t{0} }

    , decltype(_impl_.id_) { ::int64_t{0} }

  };
  _impl_.app_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppMetadata::~AppMetadata() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.AppMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AppMetadata::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_id_.~RepeatedField();
  _internal_mutable_file_name()->~RepeatedPtrField();
  _impl_.file_size_.~RepeatedField();
  _impl_.app_name_.Destroy();
  _impl_.package_name_.Destroy();
}

void AppMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AppMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.AppMetadata)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_payload_id()->Clear();
  _internal_mutable_file_name()->Clear();
  _internal_mutable_file_size()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.package_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.id_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AppMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int64 payload_id = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_payload_id(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 24) {
          _internal_add_payload_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string file_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_file_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int64 file_size = 6 [packed = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_file_size(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 48) {
          _internal_add_file_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string package_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AppMetadata::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.AppMetadata)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_app_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int64 size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_size(), target);
  }

  // repeated int64 payload_id = 3 [packed = true];
  {
    int byte_size = _impl_._payload_id_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(3, _internal_payload_id(),
                                                 byte_size, target);
    }
  }

  // optional int64 id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_id(), target);
  }

  // repeated string file_name = 5;
  for (int i = 0, n = this->_internal_file_name_size(); i < n; ++i) {
    const auto& s = this->_internal_file_name(i);
    target = stream->WriteString(5, s, target);
  }

  // repeated int64 file_size = 6 [packed = true];
  {
    int byte_size = _impl_._file_size_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(6, _internal_file_size(),
                                                 byte_size, target);
    }
  }

  // optional string package_name = 7;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_package_name();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.AppMetadata)
  return target;
}

::size_t AppMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.AppMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 payload_id = 3 [packed = true];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_payload_id())
    ;
    _impl_._payload_id_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated string file_name = 5;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_file_name().size());
  for (int i = 0, n = _internal_file_name().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_file_name().Get(i));
  }

  // repeated int64 file_size = 6 [packed = true];
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_file_size())
    ;
    _impl_._file_size_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string app_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_app_name());
    }

    // optional string package_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_package_name());
    }

    // optional int64 size = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_size());
    }

    // optional int64 id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AppMetadata*>(
      &from));
}

void AppMetadata::MergeFrom(const AppMetadata& from) {
  AppMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.AppMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.payload_id_.MergeFrom(from._impl_.payload_id_);
  _this->_internal_mutable_file_name()->MergeFrom(from._internal_file_name());
  _this->_impl_.file_size_.MergeFrom(from._impl_.file_size_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_app_name(from._internal_app_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_package_name(from._internal_package_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppMetadata::CopyFrom(const AppMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.AppMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppMetadata::IsInitialized() const {
  return true;
}

void AppMetadata::InternalSwap(AppMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.payload_id_.InternalSwap(&other->_impl_.payload_id_);
  _internal_mutable_file_name()->InternalSwap(
      other->_internal_mutable_file_name());
  _impl_.file_size_.InternalSwap(&other->_impl_.file_size_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.app_name_, lhs_arena,
                                       &other->_impl_.app_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.package_name_, lhs_arena,
                                       &other->_impl_.package_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AppMetadata, _impl_.id_)
      + sizeof(AppMetadata::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(AppMetadata, _impl_.size_)>(
          reinterpret_cast<char*>(&_impl_.size_),
          reinterpret_cast<char*>(&other->_impl_.size_));
}

std::string AppMetadata::GetTypeName() const {
  return "nearby.sharing.service.proto.AppMetadata";
}

// ===================================================================

class Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<Frame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Frame, _impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::nearby::sharing::service::proto::V1Frame& v1(const Frame* msg);
  static void set_has_v1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::nearby::sharing::service::proto::V1Frame&
Frame::_Internal::v1(const Frame* msg) {
  return *msg->_impl_.v1_;
}
Frame::Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Frame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.v1_){nullptr}
    , decltype(_impl_.version_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.v1_ = new ::nearby::sharing::service::proto::V1Frame(*from._impl_.v1_);
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.Frame)
}

inline void Frame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.v1_){nullptr}
    , decltype(_impl_.version_) { 0 }

  };
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Frame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.v1_;
}

void Frame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.Frame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.v1_ != nullptr);
    _impl_.v1_->Clear();
  }
  _impl_.version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.sharing.service.proto.Frame.Version version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::Frame_Version_IsValid(static_cast<int>(val)))) {
            _internal_set_version(static_cast<::nearby::sharing::service::proto::Frame_Version>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.V1Frame v1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_v1(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Frame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.Frame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .nearby.sharing.service.proto.Frame.Version version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_version(), target);
  }

  // optional .nearby.sharing.service.proto.V1Frame v1 = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::v1(this),
        _Internal::v1(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.Frame)
  return target;
}

::size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.Frame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .nearby.sharing.service.proto.V1Frame v1 = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.v1_);
    }

    // optional .nearby.sharing.service.proto.Frame.Version version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Frame*>(
      &from));
}

void Frame::MergeFrom(const Frame& from) {
  Frame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.Frame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_v1()->::nearby::sharing::service::proto::V1Frame::MergeFrom(
          from._internal_v1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Frame, _impl_.version_)
      + sizeof(Frame::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(Frame, _impl_.v1_)>(
          reinterpret_cast<char*>(&_impl_.v1_),
          reinterpret_cast<char*>(&other->_impl_.v1_));
}

std::string Frame::GetTypeName() const {
  return "nearby.sharing.service.proto.Frame";
}

// ===================================================================

class V1Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<V1Frame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(V1Frame, _impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::nearby::sharing::service::proto::IntroductionFrame& introduction(const V1Frame* msg);
  static void set_has_introduction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::nearby::sharing::service::proto::ConnectionResponseFrame& connection_response(const V1Frame* msg);
  static void set_has_connection_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame& paired_key_encryption(const V1Frame* msg);
  static void set_has_paired_key_encryption(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::nearby::sharing::service::proto::PairedKeyResultFrame& paired_key_result(const V1Frame* msg);
  static void set_has_paired_key_result(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::nearby::sharing::service::proto::CertificateInfoFrame& certificate_info(const V1Frame* msg);
  static void set_has_certificate_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::nearby::sharing::service::proto::ProgressUpdateFrame& progress_update(const V1Frame* msg);
  static void set_has_progress_update(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::nearby::sharing::service::proto::IntroductionFrame&
V1Frame::_Internal::introduction(const V1Frame* msg) {
  return *msg->_impl_.introduction_;
}
const ::nearby::sharing::service::proto::ConnectionResponseFrame&
V1Frame::_Internal::connection_response(const V1Frame* msg) {
  return *msg->_impl_.connection_response_;
}
const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame&
V1Frame::_Internal::paired_key_encryption(const V1Frame* msg) {
  return *msg->_impl_.paired_key_encryption_;
}
const ::nearby::sharing::service::proto::PairedKeyResultFrame&
V1Frame::_Internal::paired_key_result(const V1Frame* msg) {
  return *msg->_impl_.paired_key_result_;
}
const ::nearby::sharing::service::proto::CertificateInfoFrame&
V1Frame::_Internal::certificate_info(const V1Frame* msg) {
  return *msg->_impl_.certificate_info_;
}
const ::nearby::sharing::service::proto::ProgressUpdateFrame&
V1Frame::_Internal::progress_update(const V1Frame* msg) {
  return *msg->_impl_.progress_update_;
}
V1Frame::V1Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.V1Frame)
}
V1Frame::V1Frame(const V1Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V1Frame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.introduction_){nullptr}
    , decltype(_impl_.connection_response_){nullptr}
    , decltype(_impl_.paired_key_encryption_){nullptr}
    , decltype(_impl_.paired_key_result_){nullptr}
    , decltype(_impl_.certificate_info_){nullptr}
    , decltype(_impl_.progress_update_){nullptr}
    , decltype(_impl_.type_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.introduction_ = new ::nearby::sharing::service::proto::IntroductionFrame(*from._impl_.introduction_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.connection_response_ = new ::nearby::sharing::service::proto::ConnectionResponseFrame(*from._impl_.connection_response_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.paired_key_encryption_ = new ::nearby::sharing::service::proto::PairedKeyEncryptionFrame(*from._impl_.paired_key_encryption_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.paired_key_result_ = new ::nearby::sharing::service::proto::PairedKeyResultFrame(*from._impl_.paired_key_result_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.certificate_info_ = new ::nearby::sharing::service::proto::CertificateInfoFrame(*from._impl_.certificate_info_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.progress_update_ = new ::nearby::sharing::service::proto::ProgressUpdateFrame(*from._impl_.progress_update_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.V1Frame)
}

inline void V1Frame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.introduction_){nullptr}
    , decltype(_impl_.connection_response_){nullptr}
    , decltype(_impl_.paired_key_encryption_){nullptr}
    , decltype(_impl_.paired_key_result_){nullptr}
    , decltype(_impl_.certificate_info_){nullptr}
    , decltype(_impl_.progress_update_){nullptr}
    , decltype(_impl_.type_) { 0 }

  };
}

V1Frame::~V1Frame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.V1Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V1Frame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.introduction_;
  if (this != internal_default_instance()) delete _impl_.connection_response_;
  if (this != internal_default_instance()) delete _impl_.paired_key_encryption_;
  if (this != internal_default_instance()) delete _impl_.paired_key_result_;
  if (this != internal_default_instance()) delete _impl_.certificate_info_;
  if (this != internal_default_instance()) delete _impl_.progress_update_;
}

void V1Frame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V1Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.V1Frame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.introduction_ != nullptr);
      _impl_.introduction_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.connection_response_ != nullptr);
      _impl_.connection_response_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.paired_key_encryption_ != nullptr);
      _impl_.paired_key_encryption_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.paired_key_result_ != nullptr);
      _impl_.paired_key_result_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.certificate_info_ != nullptr);
      _impl_.certificate_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.progress_update_ != nullptr);
      _impl_.progress_update_->Clear();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V1Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.sharing.service.proto.V1Frame.FrameType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::V1Frame_FrameType_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::nearby::sharing::service::proto::V1Frame_FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.IntroductionFrame introduction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_introduction(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.ConnectionResponseFrame connection_response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_response(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.PairedKeyEncryptionFrame paired_key_encryption = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_paired_key_encryption(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.PairedKeyResultFrame paired_key_result = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_paired_key_result(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.CertificateInfoFrame certificate_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_certificate_info(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.ProgressUpdateFrame progress_update = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_progress_update(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* V1Frame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.V1Frame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .nearby.sharing.service.proto.V1Frame.FrameType type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  // optional .nearby.sharing.service.proto.IntroductionFrame introduction = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::introduction(this),
        _Internal::introduction(this).GetCachedSize(), target, stream);
  }

  // optional .nearby.sharing.service.proto.ConnectionResponseFrame connection_response = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::connection_response(this),
        _Internal::connection_response(this).GetCachedSize(), target, stream);
  }

  // optional .nearby.sharing.service.proto.PairedKeyEncryptionFrame paired_key_encryption = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::paired_key_encryption(this),
        _Internal::paired_key_encryption(this).GetCachedSize(), target, stream);
  }

  // optional .nearby.sharing.service.proto.PairedKeyResultFrame paired_key_result = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::paired_key_result(this),
        _Internal::paired_key_result(this).GetCachedSize(), target, stream);
  }

  // optional .nearby.sharing.service.proto.CertificateInfoFrame certificate_info = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::certificate_info(this),
        _Internal::certificate_info(this).GetCachedSize(), target, stream);
  }

  // optional .nearby.sharing.service.proto.ProgressUpdateFrame progress_update = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::progress_update(this),
        _Internal::progress_update(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.V1Frame)
  return target;
}

::size_t V1Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.V1Frame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .nearby.sharing.service.proto.IntroductionFrame introduction = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.introduction_);
    }

    // optional .nearby.sharing.service.proto.ConnectionResponseFrame connection_response = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connection_response_);
    }

    // optional .nearby.sharing.service.proto.PairedKeyEncryptionFrame paired_key_encryption = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.paired_key_encryption_);
    }

    // optional .nearby.sharing.service.proto.PairedKeyResultFrame paired_key_result = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.paired_key_result_);
    }

    // optional .nearby.sharing.service.proto.CertificateInfoFrame certificate_info = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.certificate_info_);
    }

    // optional .nearby.sharing.service.proto.ProgressUpdateFrame progress_update = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.progress_update_);
    }

    // optional .nearby.sharing.service.proto.V1Frame.FrameType type = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V1Frame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V1Frame*>(
      &from));
}

void V1Frame::MergeFrom(const V1Frame& from) {
  V1Frame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.V1Frame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_introduction()->::nearby::sharing::service::proto::IntroductionFrame::MergeFrom(
          from._internal_introduction());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connection_response()->::nearby::sharing::service::proto::ConnectionResponseFrame::MergeFrom(
          from._internal_connection_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_paired_key_encryption()->::nearby::sharing::service::proto::PairedKeyEncryptionFrame::MergeFrom(
          from._internal_paired_key_encryption());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_paired_key_result()->::nearby::sharing::service::proto::PairedKeyResultFrame::MergeFrom(
          from._internal_paired_key_result());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_certificate_info()->::nearby::sharing::service::proto::CertificateInfoFrame::MergeFrom(
          from._internal_certificate_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_progress_update()->::nearby::sharing::service::proto::ProgressUpdateFrame::MergeFrom(
          from._internal_progress_update());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V1Frame::CopyFrom(const V1Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.V1Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V1Frame::IsInitialized() const {
  return true;
}

void V1Frame::InternalSwap(V1Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.type_)
      + sizeof(V1Frame::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(V1Frame, _impl_.introduction_)>(
          reinterpret_cast<char*>(&_impl_.introduction_),
          reinterpret_cast<char*>(&other->_impl_.introduction_));
}

std::string V1Frame::GetTypeName() const {
  return "nearby.sharing.service.proto.V1Frame";
}

// ===================================================================

class IntroductionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<IntroductionFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IntroductionFrame, _impl_._has_bits_);
  static void set_has_required_package(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start_transfer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IntroductionFrame::IntroductionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.IntroductionFrame)
}
IntroductionFrame::IntroductionFrame(const IntroductionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IntroductionFrame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_metadata_){from._impl_.file_metadata_}
    , decltype(_impl_.text_metadata_){from._impl_.text_metadata_}
    , decltype(_impl_.wifi_credentials_metadata_){from._impl_.wifi_credentials_metadata_}
    , decltype(_impl_.app_metadata_){from._impl_.app_metadata_}
    , decltype(_impl_.required_package_) {}

    , decltype(_impl_.start_transfer_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.required_package_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.required_package_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.required_package_.Set(from._internal_required_package(), _this->GetArenaForAllocation());
  }
  _this->_impl_.start_transfer_ = from._impl_.start_transfer_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.IntroductionFrame)
}

inline void IntroductionFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_metadata_){arena}
    , decltype(_impl_.text_metadata_){arena}
    , decltype(_impl_.wifi_credentials_metadata_){arena}
    , decltype(_impl_.app_metadata_){arena}
    , decltype(_impl_.required_package_) {}

    , decltype(_impl_.start_transfer_) { false }

  };
  _impl_.required_package_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.required_package_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IntroductionFrame::~IntroductionFrame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.IntroductionFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntroductionFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_file_metadata()->~RepeatedPtrField();
  _internal_mutable_text_metadata()->~RepeatedPtrField();
  _internal_mutable_wifi_credentials_metadata()->~RepeatedPtrField();
  _internal_mutable_app_metadata()->~RepeatedPtrField();
  _impl_.required_package_.Destroy();
}

void IntroductionFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntroductionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.IntroductionFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_file_metadata()->Clear();
  _internal_mutable_text_metadata()->Clear();
  _internal_mutable_wifi_credentials_metadata()->Clear();
  _internal_mutable_app_metadata()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.required_package_.ClearNonDefaultToEmpty();
  }
  _impl_.start_transfer_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IntroductionFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .nearby.sharing.service.proto.FileMetadata file_metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_file_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .nearby.sharing.service.proto.TextMetadata text_metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_text_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string required_package = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_required_package();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .nearby.sharing.service.proto.WifiCredentialsMetadata wifi_credentials_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_wifi_credentials_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .nearby.sharing.service.proto.AppMetadata app_metadata = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_app_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool start_transfer = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_start_transfer(&has_bits);
          _impl_.start_transfer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* IntroductionFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.IntroductionFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .nearby.sharing.service.proto.FileMetadata file_metadata = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_file_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_file_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .nearby.sharing.service.proto.TextMetadata text_metadata = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_text_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_text_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string required_package = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_required_package();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // repeated .nearby.sharing.service.proto.WifiCredentialsMetadata wifi_credentials_metadata = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_wifi_credentials_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_wifi_credentials_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .nearby.sharing.service.proto.AppMetadata app_metadata = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_app_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_app_metadata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool start_transfer = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_start_transfer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.IntroductionFrame)
  return target;
}

::size_t IntroductionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.IntroductionFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .nearby.sharing.service.proto.FileMetadata file_metadata = 1;
  total_size += 1UL * this->_internal_file_metadata_size();
  for (const auto& msg : this->_internal_file_metadata()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .nearby.sharing.service.proto.TextMetadata text_metadata = 2;
  total_size += 1UL * this->_internal_text_metadata_size();
  for (const auto& msg : this->_internal_text_metadata()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .nearby.sharing.service.proto.WifiCredentialsMetadata wifi_credentials_metadata = 4;
  total_size += 1UL * this->_internal_wifi_credentials_metadata_size();
  for (const auto& msg : this->_internal_wifi_credentials_metadata()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .nearby.sharing.service.proto.AppMetadata app_metadata = 5;
  total_size += 1UL * this->_internal_app_metadata_size();
  for (const auto& msg : this->_internal_app_metadata()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string required_package = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_required_package());
    }

    // optional bool start_transfer = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IntroductionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IntroductionFrame*>(
      &from));
}

void IntroductionFrame::MergeFrom(const IntroductionFrame& from) {
  IntroductionFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.IntroductionFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_file_metadata()->MergeFrom(from._internal_file_metadata());
  _this->_internal_mutable_text_metadata()->MergeFrom(from._internal_text_metadata());
  _this->_internal_mutable_wifi_credentials_metadata()->MergeFrom(from._internal_wifi_credentials_metadata());
  _this->_internal_mutable_app_metadata()->MergeFrom(from._internal_app_metadata());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_required_package(from._internal_required_package());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_transfer_ = from._impl_.start_transfer_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IntroductionFrame::CopyFrom(const IntroductionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.IntroductionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntroductionFrame::IsInitialized() const {
  return true;
}

void IntroductionFrame::InternalSwap(IntroductionFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_file_metadata()->InternalSwap(other->_internal_mutable_file_metadata());
  _internal_mutable_text_metadata()->InternalSwap(other->_internal_mutable_text_metadata());
  _internal_mutable_wifi_credentials_metadata()->InternalSwap(other->_internal_mutable_wifi_credentials_metadata());
  _internal_mutable_app_metadata()->InternalSwap(other->_internal_mutable_app_metadata());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.required_package_, lhs_arena,
                                       &other->_impl_.required_package_, rhs_arena);

  swap(_impl_.start_transfer_, other->_impl_.start_transfer_);
}

std::string IntroductionFrame::GetTypeName() const {
  return "nearby.sharing.service.proto.IntroductionFrame";
}

// ===================================================================

class ProgressUpdateFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ProgressUpdateFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ProgressUpdateFrame, _impl_._has_bits_);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start_transfer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProgressUpdateFrame::ProgressUpdateFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.ProgressUpdateFrame)
}
ProgressUpdateFrame::ProgressUpdateFrame(const ProgressUpdateFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.ProgressUpdateFrame)
}

inline void ProgressUpdateFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_) { 0 }

    , decltype(_impl_.start_transfer_) { false }

  };
}

ProgressUpdateFrame::~ProgressUpdateFrame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.ProgressUpdateFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProgressUpdateFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProgressUpdateFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProgressUpdateFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.ProgressUpdateFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.progress_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.start_transfer_) -
        reinterpret_cast<char*>(&_impl_.progress_)) + sizeof(_impl_.start_transfer_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProgressUpdateFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float progress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool start_transfer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_start_transfer(&has_bits);
          _impl_.start_transfer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ProgressUpdateFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.ProgressUpdateFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float progress = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_progress(), target);
  }

  // optional bool start_transfer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_start_transfer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.ProgressUpdateFrame)
  return target;
}

::size_t ProgressUpdateFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.ProgressUpdateFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float progress = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 5;
    }

    // optional bool start_transfer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProgressUpdateFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProgressUpdateFrame*>(
      &from));
}

void ProgressUpdateFrame::MergeFrom(const ProgressUpdateFrame& from) {
  ProgressUpdateFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.ProgressUpdateFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_transfer_ = from._impl_.start_transfer_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProgressUpdateFrame::CopyFrom(const ProgressUpdateFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.ProgressUpdateFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProgressUpdateFrame::IsInitialized() const {
  return true;
}

void ProgressUpdateFrame::InternalSwap(ProgressUpdateFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProgressUpdateFrame, _impl_.start_transfer_)
      + sizeof(ProgressUpdateFrame::_impl_.start_transfer_)
      - PROTOBUF_FIELD_OFFSET(ProgressUpdateFrame, _impl_.progress_)>(
          reinterpret_cast<char*>(&_impl_.progress_),
          reinterpret_cast<char*>(&other->_impl_.progress_));
}

std::string ProgressUpdateFrame::GetTypeName() const {
  return "nearby.sharing.service.proto.ProgressUpdateFrame";
}

// ===================================================================

ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse() {}
ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse::MergeFrom(const ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
// ===================================================================

class ConnectionResponseFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionResponseFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConnectionResponseFrame, _impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConnectionResponseFrame::ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.ConnectionResponseFrame)
}
ConnectionResponseFrame::ConnectionResponseFrame(const ConnectionResponseFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ConnectionResponseFrame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.attachment_details_)*/{}
    , decltype(_impl_.status_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.attachment_details_.MergeFrom(from._impl_.attachment_details_);
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.ConnectionResponseFrame)
}

inline void ConnectionResponseFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.attachment_details_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.status_) { 0 }

  };
}

ConnectionResponseFrame::~ConnectionResponseFrame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.ConnectionResponseFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionResponseFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachment_details_.~MapFieldLite();
}

void ConnectionResponseFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionResponseFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.ConnectionResponseFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachment_details_.Clear();
  _impl_.status_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConnectionResponseFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.sharing.service.proto.ConnectionResponseFrame.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::ConnectionResponseFrame_Status_IsValid(static_cast<int>(val)))) {
            _internal_set_status(static_cast<::nearby::sharing::service::proto::ConnectionResponseFrame_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int64, .nearby.sharing.service.proto.AttachmentDetails> attachment_details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.attachment_details_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConnectionResponseFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.ConnectionResponseFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .nearby.sharing.service.proto.ConnectionResponseFrame.Status status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_status(), target);
  }

  // map<int64, .nearby.sharing.service.proto.AttachmentDetails> attachment_details = 2;
  if (!this->_internal_attachment_details().empty()) {
    using MapType = ::_pb::Map<::int64_t, ::nearby::sharing::service::proto::AttachmentDetails>;
    using WireHelper = ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_attachment_details();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.ConnectionResponseFrame)
  return target;
}

::size_t ConnectionResponseFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.ConnectionResponseFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, .nearby.sharing.service.proto.AttachmentDetails> attachment_details = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attachment_details_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >::const_iterator
      it = this->_internal_attachment_details().begin();
      it != this->_internal_attachment_details().end(); ++it) {
    total_size += ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional .nearby.sharing.service.proto.ConnectionResponseFrame.Status status = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectionResponseFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConnectionResponseFrame*>(
      &from));
}

void ConnectionResponseFrame::MergeFrom(const ConnectionResponseFrame& from) {
  ConnectionResponseFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.ConnectionResponseFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attachment_details_.MergeFrom(from._impl_.attachment_details_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConnectionResponseFrame::CopyFrom(const ConnectionResponseFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.ConnectionResponseFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionResponseFrame::IsInitialized() const {
  return true;
}

void ConnectionResponseFrame::InternalSwap(ConnectionResponseFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attachment_details_.InternalSwap(&other->_impl_.attachment_details_);
  swap(_impl_.status_, other->_impl_.status_);
}

std::string ConnectionResponseFrame::GetTypeName() const {
  return "nearby.sharing.service.proto.ConnectionResponseFrame";
}

// ===================================================================

class AttachmentDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<AttachmentDetails>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AttachmentDetails, _impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::nearby::sharing::service::proto::FileAttachmentDetails& file_attachment_details(const AttachmentDetails* msg);
  static void set_has_file_attachment_details(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::nearby::sharing::service::proto::FileAttachmentDetails&
AttachmentDetails::_Internal::file_attachment_details(const AttachmentDetails* msg) {
  return *msg->_impl_.file_attachment_details_;
}
AttachmentDetails::AttachmentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.AttachmentDetails)
}
AttachmentDetails::AttachmentDetails(const AttachmentDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AttachmentDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_attachment_details_){nullptr}
    , decltype(_impl_.type_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.file_attachment_details_ = new ::nearby::sharing::service::proto::FileAttachmentDetails(*from._impl_.file_attachment_details_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.AttachmentDetails)
}

inline void AttachmentDetails::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.file_attachment_details_){nullptr}
    , decltype(_impl_.type_) { 0 }

  };
}

AttachmentDetails::~AttachmentDetails() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.AttachmentDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AttachmentDetails::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.file_attachment_details_;
}

void AttachmentDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AttachmentDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.AttachmentDetails)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.file_attachment_details_ != nullptr);
    _impl_.file_attachment_details_->Clear();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AttachmentDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.sharing.service.proto.AttachmentDetails.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::AttachmentDetails_Type_IsValid(static_cast<int>(val)))) {
            _internal_set_type(static_cast<::nearby::sharing::service::proto::AttachmentDetails_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .nearby.sharing.service.proto.FileAttachmentDetails file_attachment_details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_file_attachment_details(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AttachmentDetails::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.AttachmentDetails)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .nearby.sharing.service.proto.AttachmentDetails.Type type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  // optional .nearby.sharing.service.proto.FileAttachmentDetails file_attachment_details = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::file_attachment_details(this),
        _Internal::file_attachment_details(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.AttachmentDetails)
  return target;
}

::size_t AttachmentDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.AttachmentDetails)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .nearby.sharing.service.proto.FileAttachmentDetails file_attachment_details = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.file_attachment_details_);
    }

    // optional .nearby.sharing.service.proto.AttachmentDetails.Type type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AttachmentDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AttachmentDetails*>(
      &from));
}

void AttachmentDetails::MergeFrom(const AttachmentDetails& from) {
  AttachmentDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.AttachmentDetails)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_file_attachment_details()->::nearby::sharing::service::proto::FileAttachmentDetails::MergeFrom(
          from._internal_file_attachment_details());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AttachmentDetails::CopyFrom(const AttachmentDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.AttachmentDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachmentDetails::IsInitialized() const {
  return true;
}

void AttachmentDetails::InternalSwap(AttachmentDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AttachmentDetails, _impl_.type_)
      + sizeof(AttachmentDetails::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(AttachmentDetails, _impl_.file_attachment_details_)>(
          reinterpret_cast<char*>(&_impl_.file_attachment_details_),
          reinterpret_cast<char*>(&other->_impl_.file_attachment_details_));
}

std::string AttachmentDetails::GetTypeName() const {
  return "nearby.sharing.service.proto.AttachmentDetails";
}

// ===================================================================

FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse() {}
FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse::MergeFrom(const FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
// ===================================================================

class FileAttachmentDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<FileAttachmentDetails>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FileAttachmentDetails, _impl_._has_bits_);
  static void set_has_receiver_existing_file_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FileAttachmentDetails::FileAttachmentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.FileAttachmentDetails)
}
FileAttachmentDetails::FileAttachmentDetails(const FileAttachmentDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FileAttachmentDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.attachment_hash_payloads_)*/{}
    , decltype(_impl_.receiver_existing_file_size_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.attachment_hash_payloads_.MergeFrom(from._impl_.attachment_hash_payloads_);
  _this->_impl_.receiver_existing_file_size_ = from._impl_.receiver_existing_file_size_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.FileAttachmentDetails)
}

inline void FileAttachmentDetails::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.attachment_hash_payloads_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.receiver_existing_file_size_) { ::int64_t{0} }

  };
}

FileAttachmentDetails::~FileAttachmentDetails() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.FileAttachmentDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileAttachmentDetails::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachment_hash_payloads_.~MapFieldLite();
}

void FileAttachmentDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileAttachmentDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.FileAttachmentDetails)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachment_hash_payloads_.Clear();
  _impl_.receiver_existing_file_size_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FileAttachmentDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 receiver_existing_file_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_receiver_existing_file_size(&has_bits);
          _impl_.receiver_existing_file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int64, .nearby.sharing.service.proto.PayloadsDetails> attachment_hash_payloads = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.attachment_hash_payloads_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FileAttachmentDetails::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.FileAttachmentDetails)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 receiver_existing_file_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_receiver_existing_file_size(), target);
  }

  // map<int64, .nearby.sharing.service.proto.PayloadsDetails> attachment_hash_payloads = 2;
  if (!this->_internal_attachment_hash_payloads().empty()) {
    using MapType = ::_pb::Map<::int64_t, ::nearby::sharing::service::proto::PayloadsDetails>;
    using WireHelper = FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_attachment_hash_payloads();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.FileAttachmentDetails)
  return target;
}

::size_t FileAttachmentDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.FileAttachmentDetails)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, .nearby.sharing.service.proto.PayloadsDetails> attachment_hash_payloads = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attachment_hash_payloads_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >::const_iterator
      it = this->_internal_attachment_hash_payloads().begin();
      it != this->_internal_attachment_hash_payloads().end(); ++it) {
    total_size += FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 receiver_existing_file_size = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_receiver_existing_file_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileAttachmentDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FileAttachmentDetails*>(
      &from));
}

void FileAttachmentDetails::MergeFrom(const FileAttachmentDetails& from) {
  FileAttachmentDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.FileAttachmentDetails)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attachment_hash_payloads_.MergeFrom(from._impl_.attachment_hash_payloads_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_receiver_existing_file_size(from._internal_receiver_existing_file_size());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileAttachmentDetails::CopyFrom(const FileAttachmentDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.FileAttachmentDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileAttachmentDetails::IsInitialized() const {
  return true;
}

void FileAttachmentDetails::InternalSwap(FileAttachmentDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attachment_hash_payloads_.InternalSwap(&other->_impl_.attachment_hash_payloads_);

  swap(_impl_.receiver_existing_file_size_, other->_impl_.receiver_existing_file_size_);
}

std::string FileAttachmentDetails::GetTypeName() const {
  return "nearby.sharing.service.proto.FileAttachmentDetails";
}

// ===================================================================

class PayloadsDetails::_Internal {
 public:
};

PayloadsDetails::PayloadsDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.PayloadsDetails)
}
PayloadsDetails::PayloadsDetails(const PayloadsDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PayloadsDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_details_){from._impl_.payload_details_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.PayloadsDetails)
}

inline void PayloadsDetails::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_details_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PayloadsDetails::~PayloadsDetails() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.PayloadsDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PayloadsDetails::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_payload_details()->~RepeatedPtrField();
}

void PayloadsDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PayloadsDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.PayloadsDetails)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_payload_details()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadsDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .nearby.sharing.service.proto.PayloadDetails payload_details = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_payload_details(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PayloadsDetails::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.PayloadsDetails)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .nearby.sharing.service.proto.PayloadDetails payload_details = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_payload_details_size()); i < n; i++) {
    const auto& repfield = this->_internal_payload_details(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.PayloadsDetails)
  return target;
}

::size_t PayloadsDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.PayloadsDetails)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .nearby.sharing.service.proto.PayloadDetails payload_details = 1;
  total_size += 1UL * this->_internal_payload_details_size();
  for (const auto& msg : this->_internal_payload_details()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadsDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PayloadsDetails*>(
      &from));
}

void PayloadsDetails::MergeFrom(const PayloadsDetails& from) {
  PayloadsDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.PayloadsDetails)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_payload_details()->MergeFrom(from._internal_payload_details());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadsDetails::CopyFrom(const PayloadsDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.PayloadsDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadsDetails::IsInitialized() const {
  return true;
}

void PayloadsDetails::InternalSwap(PayloadsDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_payload_details()->InternalSwap(other->_internal_mutable_payload_details());
}

std::string PayloadsDetails::GetTypeName() const {
  return "nearby.sharing.service.proto.PayloadsDetails";
}

// ===================================================================

class PayloadDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<PayloadDetails>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PayloadDetails, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_creation_timestamp_millis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PayloadDetails::PayloadDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.PayloadDetails)
}
PayloadDetails::PayloadDetails(const PayloadDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.PayloadDetails)
}

inline void PayloadDetails::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) { ::int64_t{0} }

    , decltype(_impl_.creation_timestamp_millis_) { ::int64_t{0} }

    , decltype(_impl_.size_) { ::int64_t{0} }

  };
}

PayloadDetails::~PayloadDetails() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.PayloadDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PayloadDetails::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PayloadDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PayloadDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.PayloadDetails)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PayloadDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 creation_timestamp_millis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_creation_timestamp_millis(&has_bits);
          _impl_.creation_timestamp_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PayloadDetails::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.PayloadDetails)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_id(), target);
  }

  // optional int64 creation_timestamp_millis = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_creation_timestamp_millis(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.PayloadDetails)
  return target;
}

::size_t PayloadDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.PayloadDetails)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_id());
    }

    // optional int64 creation_timestamp_millis = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_creation_timestamp_millis());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PayloadDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PayloadDetails*>(
      &from));
}

void PayloadDetails::MergeFrom(const PayloadDetails& from) {
  PayloadDetails* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.PayloadDetails)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.creation_timestamp_millis_ = from._impl_.creation_timestamp_millis_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PayloadDetails::CopyFrom(const PayloadDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.PayloadDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadDetails::IsInitialized() const {
  return true;
}

void PayloadDetails::InternalSwap(PayloadDetails* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PayloadDetails, _impl_.size_)
      + sizeof(PayloadDetails::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(PayloadDetails, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string PayloadDetails::GetTypeName() const {
  return "nearby.sharing.service.proto.PayloadDetails";
}

// ===================================================================

class PairedKeyEncryptionFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PairedKeyEncryptionFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PairedKeyEncryptionFrame, _impl_._has_bits_);
  static void set_has_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_secret_id_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_optional_signed_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_qr_code_handshake_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
}
PairedKeyEncryptionFrame::PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PairedKeyEncryptionFrame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_data_) {}

    , decltype(_impl_.secret_id_hash_) {}

    , decltype(_impl_.optional_signed_data_) {}

    , decltype(_impl_.qr_code_handshake_data_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.signed_data_.Set(from._internal_signed_data(), _this->GetArenaForAllocation());
  }
  _impl_.secret_id_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.secret_id_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.secret_id_hash_.Set(from._internal_secret_id_hash(), _this->GetArenaForAllocation());
  }
  _impl_.optional_signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.optional_signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.optional_signed_data_.Set(from._internal_optional_signed_data(), _this->GetArenaForAllocation());
  }
  _impl_.qr_code_handshake_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.qr_code_handshake_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.qr_code_handshake_data_.Set(from._internal_qr_code_handshake_data(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
}

inline void PairedKeyEncryptionFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signed_data_) {}

    , decltype(_impl_.secret_id_hash_) {}

    , decltype(_impl_.optional_signed_data_) {}

    , decltype(_impl_.qr_code_handshake_data_) {}

  };
  _impl_.signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secret_id_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.secret_id_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.optional_signed_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.optional_signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.qr_code_handshake_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.qr_code_handshake_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PairedKeyEncryptionFrame::~PairedKeyEncryptionFrame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PairedKeyEncryptionFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signed_data_.Destroy();
  _impl_.secret_id_hash_.Destroy();
  _impl_.optional_signed_data_.Destroy();
  _impl_.qr_code_handshake_data_.Destroy();
}

void PairedKeyEncryptionFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PairedKeyEncryptionFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.signed_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.secret_id_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.optional_signed_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.qr_code_handshake_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PairedKeyEncryptionFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes signed_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signed_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes secret_id_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_secret_id_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes optional_signed_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_optional_signed_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes qr_code_handshake_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_qr_code_handshake_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PairedKeyEncryptionFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes signed_data = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_signed_data();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional bytes secret_id_hash = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_secret_id_hash();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional bytes optional_signed_data = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_optional_signed_data();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional bytes qr_code_handshake_data = 4;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_qr_code_handshake_data();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  return target;
}

::size_t PairedKeyEncryptionFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes signed_data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_signed_data());
    }

    // optional bytes secret_id_hash = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_secret_id_hash());
    }

    // optional bytes optional_signed_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_optional_signed_data());
    }

    // optional bytes qr_code_handshake_data = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_qr_code_handshake_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairedKeyEncryptionFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PairedKeyEncryptionFrame*>(
      &from));
}

void PairedKeyEncryptionFrame::MergeFrom(const PairedKeyEncryptionFrame& from) {
  PairedKeyEncryptionFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_signed_data(from._internal_signed_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_secret_id_hash(from._internal_secret_id_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_optional_signed_data(from._internal_optional_signed_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_qr_code_handshake_data(from._internal_qr_code_handshake_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PairedKeyEncryptionFrame::CopyFrom(const PairedKeyEncryptionFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairedKeyEncryptionFrame::IsInitialized() const {
  return true;
}

void PairedKeyEncryptionFrame::InternalSwap(PairedKeyEncryptionFrame* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.signed_data_, lhs_arena,
                                       &other->_impl_.signed_data_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.secret_id_hash_, lhs_arena,
                                       &other->_impl_.secret_id_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.optional_signed_data_, lhs_arena,
                                       &other->_impl_.optional_signed_data_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.qr_code_handshake_data_, lhs_arena,
                                       &other->_impl_.qr_code_handshake_data_, rhs_arena);
}

std::string PairedKeyEncryptionFrame::GetTypeName() const {
  return "nearby.sharing.service.proto.PairedKeyEncryptionFrame";
}

// ===================================================================

class PairedKeyResultFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<PairedKeyResultFrame>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PairedKeyResultFrame, _impl_._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PairedKeyResultFrame::PairedKeyResultFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.PairedKeyResultFrame)
}
PairedKeyResultFrame::PairedKeyResultFrame(const PairedKeyResultFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.PairedKeyResultFrame)
}

inline void PairedKeyResultFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.status_) { 0 }

    , decltype(_impl_.os_type_) { 0 }

  };
}

PairedKeyResultFrame::~PairedKeyResultFrame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.PairedKeyResultFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PairedKeyResultFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PairedKeyResultFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PairedKeyResultFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.PairedKeyResultFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.status_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.os_type_) -
        reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.os_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PairedKeyResultFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .nearby.sharing.service.proto.PairedKeyResultFrame.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::nearby::sharing::service::proto::PairedKeyResultFrame_Status_IsValid(static_cast<int>(val)))) {
            _internal_set_status(static_cast<::nearby::sharing::service::proto::PairedKeyResultFrame_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .location.nearby.proto.sharing.OSType os_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::location::nearby::proto::sharing::OSType_IsValid(static_cast<int>(val)))) {
            _internal_set_os_type(static_cast<::location::nearby::proto::sharing::OSType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PairedKeyResultFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.PairedKeyResultFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .nearby.sharing.service.proto.PairedKeyResultFrame.Status status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_status(), target);
  }

  // optional .location.nearby.proto.sharing.OSType os_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_os_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.PairedKeyResultFrame)
  return target;
}

::size_t PairedKeyResultFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.PairedKeyResultFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .nearby.sharing.service.proto.PairedKeyResultFrame.Status status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional .location.nearby.proto.sharing.OSType os_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_os_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PairedKeyResultFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PairedKeyResultFrame*>(
      &from));
}

void PairedKeyResultFrame::MergeFrom(const PairedKeyResultFrame& from) {
  PairedKeyResultFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.PairedKeyResultFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.os_type_ = from._impl_.os_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PairedKeyResultFrame::CopyFrom(const PairedKeyResultFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.PairedKeyResultFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PairedKeyResultFrame::IsInitialized() const {
  return true;
}

void PairedKeyResultFrame::InternalSwap(PairedKeyResultFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PairedKeyResultFrame, _impl_.os_type_)
      + sizeof(PairedKeyResultFrame::_impl_.os_type_)
      - PROTOBUF_FIELD_OFFSET(PairedKeyResultFrame, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string PairedKeyResultFrame::GetTypeName() const {
  return "nearby.sharing.service.proto.PairedKeyResultFrame";
}

// ===================================================================

class CertificateInfoFrame::_Internal {
 public:
};

CertificateInfoFrame::CertificateInfoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.CertificateInfoFrame)
}
CertificateInfoFrame::CertificateInfoFrame(const CertificateInfoFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CertificateInfoFrame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.public_certificate_){from._impl_.public_certificate_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.CertificateInfoFrame)
}

inline void CertificateInfoFrame::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.public_certificate_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CertificateInfoFrame::~CertificateInfoFrame() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.CertificateInfoFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertificateInfoFrame::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_public_certificate()->~RepeatedPtrField();
}

void CertificateInfoFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertificateInfoFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.CertificateInfoFrame)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_public_certificate()->Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertificateInfoFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .nearby.sharing.service.proto.PublicCertificate public_certificate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_public_certificate(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CertificateInfoFrame::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.CertificateInfoFrame)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .nearby.sharing.service.proto.PublicCertificate public_certificate = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_public_certificate_size()); i < n; i++) {
    const auto& repfield = this->_internal_public_certificate(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.CertificateInfoFrame)
  return target;
}

::size_t CertificateInfoFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.CertificateInfoFrame)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .nearby.sharing.service.proto.PublicCertificate public_certificate = 1;
  total_size += 1UL * this->_internal_public_certificate_size();
  for (const auto& msg : this->_internal_public_certificate()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertificateInfoFrame::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertificateInfoFrame*>(
      &from));
}

void CertificateInfoFrame::MergeFrom(const CertificateInfoFrame& from) {
  CertificateInfoFrame* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.CertificateInfoFrame)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_public_certificate()->MergeFrom(from._internal_public_certificate());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertificateInfoFrame::CopyFrom(const CertificateInfoFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.CertificateInfoFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateInfoFrame::IsInitialized() const {
  return true;
}

void CertificateInfoFrame::InternalSwap(CertificateInfoFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_public_certificate()->InternalSwap(other->_internal_mutable_public_certificate());
}

std::string CertificateInfoFrame::GetTypeName() const {
  return "nearby.sharing.service.proto.CertificateInfoFrame";
}

// ===================================================================

class PublicCertificate::_Internal {
 public:
  using HasBits = decltype(std::declval<PublicCertificate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PublicCertificate, _impl_._has_bits_);
  static void set_has_secret_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_authenticity_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_encrypted_metadata_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_metadata_encryption_key_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

PublicCertificate::PublicCertificate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.PublicCertificate)
}
PublicCertificate::PublicCertificate(const PublicCertificate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  PublicCertificate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secret_id_) {}

    , decltype(_impl_.authenticity_key_) {}

    , decltype(_impl_.public_key_) {}

    , decltype(_impl_.encrypted_metadata_bytes_) {}

    , decltype(_impl_.metadata_encryption_key_tag_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.end_time_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.secret_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.secret_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.secret_id_.Set(from._internal_secret_id(), _this->GetArenaForAllocation());
  }
  _impl_.authenticity_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.authenticity_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.authenticity_key_.Set(from._internal_authenticity_key(), _this->GetArenaForAllocation());
  }
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.public_key_.Set(from._internal_public_key(), _this->GetArenaForAllocation());
  }
  _impl_.encrypted_metadata_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.encrypted_metadata_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.encrypted_metadata_bytes_.Set(from._internal_encrypted_metadata_bytes(), _this->GetArenaForAllocation());
  }
  _impl_.metadata_encryption_key_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.metadata_encryption_key_tag_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.metadata_encryption_key_tag_.Set(from._internal_metadata_encryption_key_tag(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_time_, &from._impl_.start_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.end_time_) -
    reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.end_time_));
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.PublicCertificate)
}

inline void PublicCertificate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.secret_id_) {}

    , decltype(_impl_.authenticity_key_) {}

    , decltype(_impl_.public_key_) {}

    , decltype(_impl_.encrypted_metadata_bytes_) {}

    , decltype(_impl_.metadata_encryption_key_tag_) {}

    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

  };
  _impl_.secret_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.secret_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authenticity_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.authenticity_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encrypted_metadata_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.encrypted_metadata_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_encryption_key_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.metadata_encryption_key_tag_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicCertificate::~PublicCertificate() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.PublicCertificate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PublicCertificate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.secret_id_.Destroy();
  _impl_.authenticity_key_.Destroy();
  _impl_.public_key_.Destroy();
  _impl_.encrypted_metadata_bytes_.Destroy();
  _impl_.metadata_encryption_key_tag_.Destroy();
}

void PublicCertificate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PublicCertificate::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.PublicCertificate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.secret_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.authenticity_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.encrypted_metadata_bytes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.metadata_encryption_key_tag_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.start_time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_time_) -
        reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.end_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PublicCertificate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes secret_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_secret_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes authenticity_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authenticity_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes public_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 start_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 end_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_end_time(&has_bits);
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes encrypted_metadata_bytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_encrypted_metadata_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bytes metadata_encryption_key_tag = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_metadata_encryption_key_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PublicCertificate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.PublicCertificate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes secret_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_secret_id();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional bytes authenticity_key = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_authenticity_key();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional bytes public_key = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_public_key();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional int64 start_time = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_start_time(), target);
  }

  // optional int64 end_time = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_end_time(), target);
  }

  // optional bytes encrypted_metadata_bytes = 6;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_encrypted_metadata_bytes();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional bytes metadata_encryption_key_tag = 7;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_metadata_encryption_key_tag();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.PublicCertificate)
  return target;
}

::size_t PublicCertificate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.PublicCertificate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes secret_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_secret_id());
    }

    // optional bytes authenticity_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_authenticity_key());
    }

    // optional bytes public_key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_public_key());
    }

    // optional bytes encrypted_metadata_bytes = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_encrypted_metadata_bytes());
    }

    // optional bytes metadata_encryption_key_tag = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                      this->_internal_metadata_encryption_key_tag());
    }

    // optional int64 start_time = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_start_time());
    }

    // optional int64 end_time = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_end_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PublicCertificate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PublicCertificate*>(
      &from));
}

void PublicCertificate::MergeFrom(const PublicCertificate& from) {
  PublicCertificate* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.PublicCertificate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_secret_id(from._internal_secret_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_authenticity_key(from._internal_authenticity_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_public_key(from._internal_public_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_encrypted_metadata_bytes(from._internal_encrypted_metadata_bytes());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_metadata_encryption_key_tag(from._internal_metadata_encryption_key_tag());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.end_time_ = from._impl_.end_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicCertificate::CopyFrom(const PublicCertificate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.PublicCertificate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicCertificate::IsInitialized() const {
  return true;
}

void PublicCertificate::InternalSwap(PublicCertificate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.secret_id_, lhs_arena,
                                       &other->_impl_.secret_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.authenticity_key_, lhs_arena,
                                       &other->_impl_.authenticity_key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.public_key_, lhs_arena,
                                       &other->_impl_.public_key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encrypted_metadata_bytes_, lhs_arena,
                                       &other->_impl_.encrypted_metadata_bytes_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.metadata_encryption_key_tag_, lhs_arena,
                                       &other->_impl_.metadata_encryption_key_tag_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PublicCertificate, _impl_.end_time_)
      + sizeof(PublicCertificate::_impl_.end_time_)
      - PROTOBUF_FIELD_OFFSET(PublicCertificate, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

std::string PublicCertificate::GetTypeName() const {
  return "nearby.sharing.service.proto.PublicCertificate";
}

// ===================================================================

class WifiCredentials::_Internal {
 public:
  using HasBits = decltype(std::declval<WifiCredentials>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(WifiCredentials, _impl_._has_bits_);
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hidden_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

WifiCredentials::WifiCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:nearby.sharing.service.proto.WifiCredentials)
}
WifiCredentials::WifiCredentials(const WifiCredentials& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  WifiCredentials* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.password_) {}

    , decltype(_impl_.hidden_ssid_) {}
  };

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.password_.Set(from._internal_password(), _this->GetArenaForAllocation());
  }
  _this->_impl_.hidden_ssid_ = from._impl_.hidden_ssid_;
  // @@protoc_insertion_point(copy_constructor:nearby.sharing.service.proto.WifiCredentials)
}

inline void WifiCredentials::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.password_) {}

    , decltype(_impl_.hidden_ssid_) { false }

  };
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WifiCredentials::~WifiCredentials() {
  // @@protoc_insertion_point(destructor:nearby.sharing.service.proto.WifiCredentials)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WifiCredentials::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.password_.Destroy();
}

void WifiCredentials::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WifiCredentials::Clear() {
// @@protoc_insertion_point(message_clear_start:nearby.sharing.service.proto.WifiCredentials)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.password_.ClearNonDefaultToEmpty();
  }
  _impl_.hidden_ssid_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WifiCredentials::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string password = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool hidden_ssid = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_hidden_ssid(&has_bits);
          _impl_.hidden_ssid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* WifiCredentials::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:nearby.sharing.service.proto.WifiCredentials)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string password = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_password();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bool hidden_ssid = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_hidden_ssid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nearby.sharing.service.proto.WifiCredentials)
  return target;
}

::size_t WifiCredentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:nearby.sharing.service.proto.WifiCredentials)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string password = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_password());
    }

    // optional bool hidden_ssid = 2 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WifiCredentials::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WifiCredentials*>(
      &from));
}

void WifiCredentials::MergeFrom(const WifiCredentials& from) {
  WifiCredentials* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:nearby.sharing.service.proto.WifiCredentials)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hidden_ssid_ = from._impl_.hidden_ssid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WifiCredentials::CopyFrom(const WifiCredentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:nearby.sharing.service.proto.WifiCredentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WifiCredentials::IsInitialized() const {
  return true;
}

void WifiCredentials::InternalSwap(WifiCredentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, lhs_arena,
                                       &other->_impl_.password_, rhs_arena);

  swap(_impl_.hidden_ssid_, other->_impl_.hidden_ssid_);
}

std::string WifiCredentials::GetTypeName() const {
  return "nearby.sharing.service.proto.WifiCredentials";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace service
}  // namespace sharing
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::FileMetadata*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::FileMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::FileMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::TextMetadata*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::TextMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::TextMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::WifiCredentialsMetadata*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::WifiCredentialsMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::WifiCredentialsMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::AppMetadata*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::AppMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::AppMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::Frame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::V1Frame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::V1Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::V1Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::IntroductionFrame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::IntroductionFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::IntroductionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::ProgressUpdateFrame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::ProgressUpdateFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::ProgressUpdateFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::ConnectionResponseFrame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::ConnectionResponseFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::ConnectionResponseFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::AttachmentDetails*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::AttachmentDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::AttachmentDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::FileAttachmentDetails*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::FileAttachmentDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::FileAttachmentDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::PayloadsDetails*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::PayloadsDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::PayloadsDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::PayloadDetails*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::PayloadDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::PayloadDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::PairedKeyEncryptionFrame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::PairedKeyEncryptionFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::PairedKeyEncryptionFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::PairedKeyResultFrame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::PairedKeyResultFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::PairedKeyResultFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::CertificateInfoFrame*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::CertificateInfoFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::CertificateInfoFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::PublicCertificate*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::PublicCertificate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::PublicCertificate >(arena);
}
template<> PROTOBUF_NOINLINE ::nearby::sharing::service::proto::WifiCredentials*
Arena::CreateMaybeMessage< ::nearby::sharing::service::proto::WifiCredentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::nearby::sharing::service::proto::WifiCredentials >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
