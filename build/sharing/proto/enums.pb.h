// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing/proto/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2fenums_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2fenums_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sharing_2fproto_2fenums_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sharing_2fproto_2fenums_2eproto {
  static const ::uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

namespace nearby {
namespace sharing {
namespace proto {
enum FastInitiationNotificationState : int {
  UNKNOWN_FAST_INIT = 0,
  ENABLED_FAST_INIT = 1,
  DISABLED_BY_USER_FAST_INIT = 2,
  DISABLED_BY_FEATURE_FAST_INIT = 3,
  FastInitiationNotificationState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FastInitiationNotificationState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FastInitiationNotificationState_IsValid(int value);
constexpr FastInitiationNotificationState FastInitiationNotificationState_MIN = static_cast<FastInitiationNotificationState>(0);
constexpr FastInitiationNotificationState FastInitiationNotificationState_MAX = static_cast<FastInitiationNotificationState>(3);
constexpr int FastInitiationNotificationState_ARRAYSIZE = 3 + 1;
const std::string& FastInitiationNotificationState_Name(FastInitiationNotificationState value);
template <typename T>
const std::string& FastInitiationNotificationState_Name(T value) {
  static_assert(std::is_same<T, FastInitiationNotificationState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FastInitiationNotificationState_Name().");
  return FastInitiationNotificationState_Name(static_cast<FastInitiationNotificationState>(value));
}
const std::string& FastInitiationNotificationState_Name(FastInitiationNotificationState value);
bool FastInitiationNotificationState_Parse(absl::string_view name, FastInitiationNotificationState* value);
enum DataUsage : int {
  UNKNOWN_DATA_USAGE = 0,
  OFFLINE_DATA_USAGE = 1,
  ONLINE_DATA_USAGE = 2,
  WIFI_ONLY_DATA_USAGE = 3,
  DataUsage_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataUsage_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataUsage_IsValid(int value);
constexpr DataUsage DataUsage_MIN = static_cast<DataUsage>(0);
constexpr DataUsage DataUsage_MAX = static_cast<DataUsage>(3);
constexpr int DataUsage_ARRAYSIZE = 3 + 1;
const std::string& DataUsage_Name(DataUsage value);
template <typename T>
const std::string& DataUsage_Name(T value) {
  static_assert(std::is_same<T, DataUsage>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataUsage_Name().");
  return DataUsage_Name(static_cast<DataUsage>(value));
}
const std::string& DataUsage_Name(DataUsage value);
bool DataUsage_Parse(absl::string_view name, DataUsage* value);
enum DeviceVisibility : int {
  DEVICE_VISIBILITY_UNSPECIFIED = 0,
  DEVICE_VISIBILITY_HIDDEN = 1,
  DEVICE_VISIBILITY_SELF_SHARE = 2,
  DEVICE_VISIBILITY_ALL_CONTACTS = 3,
  DEVICE_VISIBILITY_EVERYONE = 4,
  DEVICE_VISIBILITY_SELECTED_CONTACTS = 5,
  DeviceVisibility_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeviceVisibility_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeviceVisibility_IsValid(int value);
constexpr DeviceVisibility DeviceVisibility_MIN = static_cast<DeviceVisibility>(0);
constexpr DeviceVisibility DeviceVisibility_MAX = static_cast<DeviceVisibility>(5);
constexpr int DeviceVisibility_ARRAYSIZE = 5 + 1;
const std::string& DeviceVisibility_Name(DeviceVisibility value);
template <typename T>
const std::string& DeviceVisibility_Name(T value) {
  static_assert(std::is_same<T, DeviceVisibility>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DeviceVisibility_Name().");
  return DeviceVisibility_Name(static_cast<DeviceVisibility>(value));
}
const std::string& DeviceVisibility_Name(DeviceVisibility value);
bool DeviceVisibility_Parse(absl::string_view name, DeviceVisibility* value);

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace sharing
}  // namespace nearby


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::nearby::sharing::proto::FastInitiationNotificationState> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::proto::DataUsage> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::proto::DeviceVisibility> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2fenums_2eproto_2epb_2eh
