// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing/proto/rpc_resources.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2frpc_5fresources_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2frpc_5fresources_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
#include "sharing/proto/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sharing_2fproto_2frpc_5fresources_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sharing_2fproto_2frpc_5fresources_2eproto {
  static const ::uint32_t offsets[];
};
namespace nearby {
namespace sharing {
namespace proto {
class Contact;
struct ContactDefaultTypeInternal;
extern ContactDefaultTypeInternal _Contact_default_instance_;
class ContactRecord;
struct ContactRecordDefaultTypeInternal;
extern ContactRecordDefaultTypeInternal _ContactRecord_default_instance_;
class Contact_Identifier;
struct Contact_IdentifierDefaultTypeInternal;
extern Contact_IdentifierDefaultTypeInternal _Contact_Identifier_default_instance_;
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class PublicCertificate;
struct PublicCertificateDefaultTypeInternal;
extern PublicCertificateDefaultTypeInternal _PublicCertificate_default_instance_;
class ShareTarget;
struct ShareTargetDefaultTypeInternal;
extern ShareTargetDefaultTypeInternal _ShareTarget_default_instance_;
}  // namespace proto
}  // namespace sharing
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
template <>
::nearby::sharing::proto::Contact* Arena::CreateMaybeMessage<::nearby::sharing::proto::Contact>(Arena*);
template <>
::nearby::sharing::proto::ContactRecord* Arena::CreateMaybeMessage<::nearby::sharing::proto::ContactRecord>(Arena*);
template <>
::nearby::sharing::proto::Contact_Identifier* Arena::CreateMaybeMessage<::nearby::sharing::proto::Contact_Identifier>(Arena*);
template <>
::nearby::sharing::proto::Device* Arena::CreateMaybeMessage<::nearby::sharing::proto::Device>(Arena*);
template <>
::nearby::sharing::proto::PublicCertificate* Arena::CreateMaybeMessage<::nearby::sharing::proto::PublicCertificate>(Arena*);
template <>
::nearby::sharing::proto::ShareTarget* Arena::CreateMaybeMessage<::nearby::sharing::proto::ShareTarget>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace nearby {
namespace sharing {
namespace proto {
enum ContactRecord_Type : int {
  ContactRecord_Type_UNKNOWN = 0,
  ContactRecord_Type_GOOGLE_CONTACT = 1,
  ContactRecord_Type_DEVICE_CONTACT = 2,
  ContactRecord_Type_ContactRecord_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContactRecord_Type_ContactRecord_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContactRecord_Type_IsValid(int value);
constexpr ContactRecord_Type ContactRecord_Type_Type_MIN = static_cast<ContactRecord_Type>(0);
constexpr ContactRecord_Type ContactRecord_Type_Type_MAX = static_cast<ContactRecord_Type>(2);
constexpr int ContactRecord_Type_Type_ARRAYSIZE = 2 + 1;
const std::string& ContactRecord_Type_Name(ContactRecord_Type value);
template <typename T>
const std::string& ContactRecord_Type_Name(T value) {
  static_assert(std::is_same<T, ContactRecord_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return ContactRecord_Type_Name(static_cast<ContactRecord_Type>(value));
}
const std::string& ContactRecord_Type_Name(ContactRecord_Type value);
bool ContactRecord_Type_Parse(absl::string_view name, ContactRecord_Type* value);

// ===================================================================


// -------------------------------------------------------------------

class PublicCertificate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.proto.PublicCertificate) */ {
 public:
  inline PublicCertificate() : PublicCertificate(nullptr) {}
  ~PublicCertificate() override;
  explicit PROTOBUF_CONSTEXPR PublicCertificate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicCertificate(const PublicCertificate& from);
  PublicCertificate(PublicCertificate&& from) noexcept
    : PublicCertificate() {
    *this = ::std::move(from);
  }

  inline PublicCertificate& operator=(const PublicCertificate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicCertificate& operator=(PublicCertificate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PublicCertificate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicCertificate* internal_default_instance() {
    return reinterpret_cast<const PublicCertificate*>(
               &_PublicCertificate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublicCertificate& a, PublicCertificate& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicCertificate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicCertificate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicCertificate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicCertificate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PublicCertificate& from);
  void MergeFrom(const PublicCertificate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicCertificate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.proto.PublicCertificate";
  }
  protected:
  explicit PublicCertificate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretIdFieldNumber = 1,
    kSecretKeyFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
    kMetadataEncryptionKeyFieldNumber = 7,
    kEncryptedMetadataBytesFieldNumber = 8,
    kMetadataEncryptionKeyTagFieldNumber = 9,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
    kForSelectedContactsFieldNumber = 6,
    kForSelfShareFieldNumber = 10,
  };
  // bytes secret_id = 1;
  void clear_secret_id() ;
  const std::string& secret_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret_id(Arg_&& arg, Args_... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* ptr);

  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(
      const std::string& value);
  std::string* _internal_mutable_secret_id();

  public:
  // bytes secret_key = 2;
  void clear_secret_key() ;
  const std::string& secret_key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret_key(Arg_&& arg, Args_... args);
  std::string* mutable_secret_key();
  PROTOBUF_NODISCARD std::string* release_secret_key();
  void set_allocated_secret_key(std::string* ptr);

  private:
  const std::string& _internal_secret_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_key(
      const std::string& value);
  std::string* _internal_mutable_secret_key();

  public:
  // bytes public_key = 3;
  void clear_public_key() ;
  const std::string& public_key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* ptr);

  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(
      const std::string& value);
  std::string* _internal_mutable_public_key();

  public:
  // bytes metadata_encryption_key = 7;
  void clear_metadata_encryption_key() ;
  const std::string& metadata_encryption_key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata_encryption_key(Arg_&& arg, Args_... args);
  std::string* mutable_metadata_encryption_key();
  PROTOBUF_NODISCARD std::string* release_metadata_encryption_key();
  void set_allocated_metadata_encryption_key(std::string* ptr);

  private:
  const std::string& _internal_metadata_encryption_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata_encryption_key(
      const std::string& value);
  std::string* _internal_mutable_metadata_encryption_key();

  public:
  // bytes encrypted_metadata_bytes = 8;
  void clear_encrypted_metadata_bytes() ;
  const std::string& encrypted_metadata_bytes() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encrypted_metadata_bytes(Arg_&& arg, Args_... args);
  std::string* mutable_encrypted_metadata_bytes();
  PROTOBUF_NODISCARD std::string* release_encrypted_metadata_bytes();
  void set_allocated_encrypted_metadata_bytes(std::string* ptr);

  private:
  const std::string& _internal_encrypted_metadata_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_metadata_bytes(
      const std::string& value);
  std::string* _internal_mutable_encrypted_metadata_bytes();

  public:
  // bytes metadata_encryption_key_tag = 9;
  void clear_metadata_encryption_key_tag() ;
  const std::string& metadata_encryption_key_tag() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata_encryption_key_tag(Arg_&& arg, Args_... args);
  std::string* mutable_metadata_encryption_key_tag();
  PROTOBUF_NODISCARD std::string* release_metadata_encryption_key_tag();
  void set_allocated_metadata_encryption_key_tag(std::string* ptr);

  private:
  const std::string& _internal_metadata_encryption_key_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata_encryption_key_tag(
      const std::string& value);
  std::string* _internal_mutable_metadata_encryption_key_tag();

  public:
  // .nearby.sharing.proto.Timestamp start_time = 4;
  bool has_start_time() const;
  void clear_start_time() ;
  const ::nearby::sharing::proto::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::nearby::sharing::proto::Timestamp* release_start_time();
  ::nearby::sharing::proto::Timestamp* mutable_start_time();
  void set_allocated_start_time(::nearby::sharing::proto::Timestamp* start_time);
  private:
  const ::nearby::sharing::proto::Timestamp& _internal_start_time() const;
  ::nearby::sharing::proto::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::nearby::sharing::proto::Timestamp* start_time);
  ::nearby::sharing::proto::Timestamp* unsafe_arena_release_start_time();
  // .nearby.sharing.proto.Timestamp end_time = 5;
  bool has_end_time() const;
  void clear_end_time() ;
  const ::nearby::sharing::proto::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::nearby::sharing::proto::Timestamp* release_end_time();
  ::nearby::sharing::proto::Timestamp* mutable_end_time();
  void set_allocated_end_time(::nearby::sharing::proto::Timestamp* end_time);
  private:
  const ::nearby::sharing::proto::Timestamp& _internal_end_time() const;
  ::nearby::sharing::proto::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::nearby::sharing::proto::Timestamp* end_time);
  ::nearby::sharing::proto::Timestamp* unsafe_arena_release_end_time();
  // bool for_selected_contacts = 6;
  void clear_for_selected_contacts() ;
  bool for_selected_contacts() const;
  void set_for_selected_contacts(bool value);

  private:
  bool _internal_for_selected_contacts() const;
  void _internal_set_for_selected_contacts(bool value);

  public:
  // bool for_self_share = 10;
  void clear_for_self_share() ;
  bool for_self_share() const;
  void set_for_self_share(bool value);

  private:
  bool _internal_for_self_share() const;
  void _internal_set_for_self_share(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.proto.PublicCertificate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_encryption_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_metadata_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_encryption_key_tag_;
    ::nearby::sharing::proto::Timestamp* start_time_;
    ::nearby::sharing::proto::Timestamp* end_time_;
    bool for_selected_contacts_;
    bool for_self_share_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2frpc_5fresources_2eproto;
};// -------------------------------------------------------------------

class Contact_Identifier final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.proto.Contact.Identifier) */ {
 public:
  inline Contact_Identifier() : Contact_Identifier(nullptr) {}
  ~Contact_Identifier() override;
  explicit PROTOBUF_CONSTEXPR Contact_Identifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contact_Identifier(const Contact_Identifier& from);
  Contact_Identifier(Contact_Identifier&& from) noexcept
    : Contact_Identifier() {
    *this = ::std::move(from);
  }

  inline Contact_Identifier& operator=(const Contact_Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact_Identifier& operator=(Contact_Identifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Contact_Identifier& default_instance() {
    return *internal_default_instance();
  }
  enum IdentifierCase {
    kObfuscatedGaia = 1,
    kPhoneNumber = 2,
    kAccountName = 3,
    IDENTIFIER_NOT_SET = 0,
  };

  static inline const Contact_Identifier* internal_default_instance() {
    return reinterpret_cast<const Contact_Identifier*>(
               &_Contact_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Contact_Identifier& a, Contact_Identifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact_Identifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact_Identifier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact_Identifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact_Identifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Contact_Identifier& from);
  void MergeFrom(const Contact_Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contact_Identifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.proto.Contact.Identifier";
  }
  protected:
  explicit Contact_Identifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObfuscatedGaiaFieldNumber = 1,
    kPhoneNumberFieldNumber = 2,
    kAccountNameFieldNumber = 3,
  };
  // string obfuscated_gaia = 1;
  bool has_obfuscated_gaia() const;
  void clear_obfuscated_gaia() ;
  const std::string& obfuscated_gaia() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_obfuscated_gaia(Arg_&& arg, Args_... args);
  std::string* mutable_obfuscated_gaia();
  PROTOBUF_NODISCARD std::string* release_obfuscated_gaia();
  void set_allocated_obfuscated_gaia(std::string* ptr);

  private:
  const std::string& _internal_obfuscated_gaia() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obfuscated_gaia(
      const std::string& value);
  std::string* _internal_mutable_obfuscated_gaia();

  public:
  // string phone_number = 2;
  bool has_phone_number() const;
  void clear_phone_number() ;
  const std::string& phone_number() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* ptr);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // string account_name = 3;
  bool has_account_name() const;
  void clear_account_name() ;
  const std::string& account_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* ptr);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:nearby.sharing.proto.Contact.Identifier)
 private:
  class _Internal;
  void set_has_obfuscated_gaia();
  void set_has_phone_number();
  void set_has_account_name();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union IdentifierUnion {
      constexpr IdentifierUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obfuscated_gaia_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_number_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    } identifier_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2frpc_5fresources_2eproto;
};// -------------------------------------------------------------------

class Contact final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.proto.Contact) */ {
 public:
  inline Contact() : Contact(nullptr) {}
  ~Contact() override;
  explicit PROTOBUF_CONSTEXPR Contact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contact(const Contact& from);
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.proto.Contact";
  }
  protected:
  explicit Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Contact_Identifier Identifier;

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kIsSelectedFieldNumber = 2,
    kIsSelfFieldNumber = 3,
  };
  // .nearby.sharing.proto.Contact.Identifier identifier = 1;
  bool has_identifier() const;
  void clear_identifier() ;
  const ::nearby::sharing::proto::Contact_Identifier& identifier() const;
  PROTOBUF_NODISCARD ::nearby::sharing::proto::Contact_Identifier* release_identifier();
  ::nearby::sharing::proto::Contact_Identifier* mutable_identifier();
  void set_allocated_identifier(::nearby::sharing::proto::Contact_Identifier* identifier);
  private:
  const ::nearby::sharing::proto::Contact_Identifier& _internal_identifier() const;
  ::nearby::sharing::proto::Contact_Identifier* _internal_mutable_identifier();
  public:
  void unsafe_arena_set_allocated_identifier(
      ::nearby::sharing::proto::Contact_Identifier* identifier);
  ::nearby::sharing::proto::Contact_Identifier* unsafe_arena_release_identifier();
  // bool is_selected = 2;
  void clear_is_selected() ;
  bool is_selected() const;
  void set_is_selected(bool value);

  private:
  bool _internal_is_selected() const;
  void _internal_set_is_selected(bool value);

  public:
  // bool is_self = 3;
  void clear_is_self() ;
  bool is_self() const;
  void set_is_self(bool value);

  private:
  bool _internal_is_self() const;
  void _internal_set_is_self(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.proto.Contact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::nearby::sharing::proto::Contact_Identifier* identifier_;
    bool is_selected_;
    bool is_self_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2frpc_5fresources_2eproto;
};// -------------------------------------------------------------------

class ContactRecord final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.proto.ContactRecord) */ {
 public:
  inline ContactRecord() : ContactRecord(nullptr) {}
  ~ContactRecord() override;
  explicit PROTOBUF_CONSTEXPR ContactRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactRecord(const ContactRecord& from);
  ContactRecord(ContactRecord&& from) noexcept
    : ContactRecord() {
    *this = ::std::move(from);
  }

  inline ContactRecord& operator=(const ContactRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactRecord& operator=(ContactRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContactRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactRecord* internal_default_instance() {
    return reinterpret_cast<const ContactRecord*>(
               &_ContactRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ContactRecord& a, ContactRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContactRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContactRecord>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContactRecord& from);
  void MergeFrom(const ContactRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContactRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.proto.ContactRecord";
  }
  protected:
  explicit ContactRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = ContactRecord_Type;
  static constexpr Type UNKNOWN = ContactRecord_Type_UNKNOWN;
  static constexpr Type GOOGLE_CONTACT = ContactRecord_Type_GOOGLE_CONTACT;
  static constexpr Type DEVICE_CONTACT = ContactRecord_Type_DEVICE_CONTACT;
  static inline bool Type_IsValid(int value) {
    return ContactRecord_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = ContactRecord_Type_Type_MIN;
  static constexpr Type Type_MAX = ContactRecord_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = ContactRecord_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return ContactRecord_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return ContactRecord_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiersFieldNumber = 4,
    kIdFieldNumber = 1,
    kPersonNameFieldNumber = 2,
    kImageUrlFieldNumber = 3,
    kTypeFieldNumber = 5,
    kIsReachableFieldNumber = 6,
  };
  // repeated .nearby.sharing.proto.Contact.Identifier identifiers = 4;
  int identifiers_size() const;
  private:
  int _internal_identifiers_size() const;

  public:
  void clear_identifiers() ;
  ::nearby::sharing::proto::Contact_Identifier* mutable_identifiers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact_Identifier >*
      mutable_identifiers();
  private:
  const ::nearby::sharing::proto::Contact_Identifier& _internal_identifiers(int index) const;
  ::nearby::sharing::proto::Contact_Identifier* _internal_add_identifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact_Identifier>& _internal_identifiers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact_Identifier>* _internal_mutable_identifiers();
  public:
  const ::nearby::sharing::proto::Contact_Identifier& identifiers(int index) const;
  ::nearby::sharing::proto::Contact_Identifier* add_identifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact_Identifier >&
      identifiers() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string person_name = 2;
  void clear_person_name() ;
  const std::string& person_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_person_name(Arg_&& arg, Args_... args);
  std::string* mutable_person_name();
  PROTOBUF_NODISCARD std::string* release_person_name();
  void set_allocated_person_name(std::string* ptr);

  private:
  const std::string& _internal_person_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_person_name(
      const std::string& value);
  std::string* _internal_mutable_person_name();

  public:
  // string image_url = 3;
  void clear_image_url() ;
  const std::string& image_url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_image_url(Arg_&& arg, Args_... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* ptr);

  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(
      const std::string& value);
  std::string* _internal_mutable_image_url();

  public:
  // .nearby.sharing.proto.ContactRecord.Type type = 5;
  void clear_type() ;
  ::nearby::sharing::proto::ContactRecord_Type type() const;
  void set_type(::nearby::sharing::proto::ContactRecord_Type value);

  private:
  ::nearby::sharing::proto::ContactRecord_Type _internal_type() const;
  void _internal_set_type(::nearby::sharing::proto::ContactRecord_Type value);

  public:
  // bool is_reachable = 6;
  void clear_is_reachable() ;
  bool is_reachable() const;
  void set_is_reachable(bool value);

  private:
  bool _internal_is_reachable() const;
  void _internal_set_is_reachable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.proto.ContactRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact_Identifier > identifiers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr person_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
    int type_;
    bool is_reachable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2frpc_5fresources_2eproto;
};// -------------------------------------------------------------------

class ShareTarget final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.proto.ShareTarget) */ {
 public:
  inline ShareTarget() : ShareTarget(nullptr) {}
  ~ShareTarget() override;
  explicit PROTOBUF_CONSTEXPR ShareTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareTarget(const ShareTarget& from);
  ShareTarget(ShareTarget&& from) noexcept
    : ShareTarget() {
    *this = ::std::move(from);
  }

  inline ShareTarget& operator=(const ShareTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareTarget& operator=(ShareTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShareTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareTarget* internal_default_instance() {
    return reinterpret_cast<const ShareTarget*>(
               &_ShareTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ShareTarget& a, ShareTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareTarget>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShareTarget& from);
  void MergeFrom(const ShareTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShareTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.proto.ShareTarget";
  }
  protected:
  explicit ShareTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicCertificatesFieldNumber = 1,
  };
  // repeated .nearby.sharing.proto.PublicCertificate public_certificates = 1;
  int public_certificates_size() const;
  private:
  int _internal_public_certificates_size() const;

  public:
  void clear_public_certificates() ;
  ::nearby::sharing::proto::PublicCertificate* mutable_public_certificates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >*
      mutable_public_certificates();
  private:
  const ::nearby::sharing::proto::PublicCertificate& _internal_public_certificates(int index) const;
  ::nearby::sharing::proto::PublicCertificate* _internal_add_public_certificates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>& _internal_public_certificates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>* _internal_mutable_public_certificates();
  public:
  const ::nearby::sharing::proto::PublicCertificate& public_certificates(int index) const;
  ::nearby::sharing::proto::PublicCertificate* add_public_certificates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >&
      public_certificates() const;
  // @@protoc_insertion_point(class_scope:nearby.sharing.proto.ShareTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate > public_certificates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2frpc_5fresources_2eproto;
};// -------------------------------------------------------------------

class Device final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.proto.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() override;
  explicit PROTOBUF_CONSTEXPR Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Device(const Device& from);
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Device* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Device* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.proto.Device";
  }
  protected:
  explicit Device(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactsFieldNumber = 3,
    kPublicCertificatesFieldNumber = 4,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
  };
  // repeated .nearby.sharing.proto.Contact contacts = 3;
  int contacts_size() const;
  private:
  int _internal_contacts_size() const;

  public:
  void clear_contacts() ;
  ::nearby::sharing::proto::Contact* mutable_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact >*
      mutable_contacts();
  private:
  const ::nearby::sharing::proto::Contact& _internal_contacts(int index) const;
  ::nearby::sharing::proto::Contact* _internal_add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact>& _internal_contacts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact>* _internal_mutable_contacts();
  public:
  const ::nearby::sharing::proto::Contact& contacts(int index) const;
  ::nearby::sharing::proto::Contact* add_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact >&
      contacts() const;
  // repeated .nearby.sharing.proto.PublicCertificate public_certificates = 4;
  int public_certificates_size() const;
  private:
  int _internal_public_certificates_size() const;

  public:
  void clear_public_certificates() ;
  ::nearby::sharing::proto::PublicCertificate* mutable_public_certificates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >*
      mutable_public_certificates();
  private:
  const ::nearby::sharing::proto::PublicCertificate& _internal_public_certificates(int index) const;
  ::nearby::sharing::proto::PublicCertificate* _internal_add_public_certificates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>& _internal_public_certificates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>* _internal_mutable_public_certificates();
  public:
  const ::nearby::sharing::proto::PublicCertificate& public_certificates(int index) const;
  ::nearby::sharing::proto::PublicCertificate* add_public_certificates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >&
      public_certificates() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string display_name = 2;
  void clear_display_name() ;
  const std::string& display_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* ptr);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.proto.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact > contacts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate > public_certificates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2frpc_5fresources_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PublicCertificate

// bytes secret_id = 1;
inline void PublicCertificate::clear_secret_id() {
  _impl_.secret_id_.ClearToEmpty();
}
inline const std::string& PublicCertificate::secret_id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.secret_id)
  return _internal_secret_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_secret_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.secret_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.secret_id)
}
inline std::string* PublicCertificate::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.secret_id)
  return _s;
}
inline const std::string& PublicCertificate::_internal_secret_id() const {
  return _impl_.secret_id_.Get();
}
inline void PublicCertificate::_internal_set_secret_id(const std::string& value) {
  ;


  _impl_.secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_secret_id() {
  ;
  return _impl_.secret_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_secret_id() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.secret_id)
  return _impl_.secret_id_.Release();
}
inline void PublicCertificate::set_allocated_secret_id(std::string* value) {
  _impl_.secret_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_id_.IsDefault()) {
          _impl_.secret_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.secret_id)
}

// bytes secret_key = 2;
inline void PublicCertificate::clear_secret_key() {
  _impl_.secret_key_.ClearToEmpty();
}
inline const std::string& PublicCertificate::secret_key() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.secret_key)
  return _internal_secret_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_secret_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.secret_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.secret_key)
}
inline std::string* PublicCertificate::mutable_secret_key() {
  std::string* _s = _internal_mutable_secret_key();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.secret_key)
  return _s;
}
inline const std::string& PublicCertificate::_internal_secret_key() const {
  return _impl_.secret_key_.Get();
}
inline void PublicCertificate::_internal_set_secret_key(const std::string& value) {
  ;


  _impl_.secret_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_secret_key() {
  ;
  return _impl_.secret_key_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_secret_key() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.secret_key)
  return _impl_.secret_key_.Release();
}
inline void PublicCertificate::set_allocated_secret_key(std::string* value) {
  _impl_.secret_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_key_.IsDefault()) {
          _impl_.secret_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.secret_key)
}

// bytes public_key = 3;
inline void PublicCertificate::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
}
inline const std::string& PublicCertificate::public_key() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_public_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.public_key)
}
inline std::string* PublicCertificate::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.public_key)
  return _s;
}
inline const std::string& PublicCertificate::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void PublicCertificate::_internal_set_public_key(const std::string& value) {
  ;


  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_public_key() {
  ;
  return _impl_.public_key_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_public_key() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.public_key)
  return _impl_.public_key_.Release();
}
inline void PublicCertificate::set_allocated_public_key(std::string* value) {
  _impl_.public_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.public_key_.IsDefault()) {
          _impl_.public_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.public_key)
}

// .nearby.sharing.proto.Timestamp start_time = 4;
inline bool PublicCertificate::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_time_ != nullptr);
  return value;
}
inline const ::nearby::sharing::proto::Timestamp& PublicCertificate::_internal_start_time() const {
  const ::nearby::sharing::proto::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::proto::Timestamp&>(
      ::nearby::sharing::proto::_Timestamp_default_instance_);
}
inline const ::nearby::sharing::proto::Timestamp& PublicCertificate::start_time() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.start_time)
  return _internal_start_time();
}
inline void PublicCertificate::unsafe_arena_set_allocated_start_time(
    ::nearby::sharing::proto::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.proto.PublicCertificate.start_time)
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::release_start_time() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::proto::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.start_time)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::proto::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::_internal_mutable_start_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::proto::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::mutable_start_time() {
  ::nearby::sharing::proto::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.start_time)
  return _msg;
}
inline void PublicCertificate::set_allocated_start_time(::nearby::sharing::proto::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.start_time)
}

// .nearby.sharing.proto.Timestamp end_time = 5;
inline bool PublicCertificate::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_time_ != nullptr);
  return value;
}
inline const ::nearby::sharing::proto::Timestamp& PublicCertificate::_internal_end_time() const {
  const ::nearby::sharing::proto::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::proto::Timestamp&>(
      ::nearby::sharing::proto::_Timestamp_default_instance_);
}
inline const ::nearby::sharing::proto::Timestamp& PublicCertificate::end_time() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.end_time)
  return _internal_end_time();
}
inline void PublicCertificate::unsafe_arena_set_allocated_end_time(
    ::nearby::sharing::proto::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.proto.PublicCertificate.end_time)
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::release_end_time() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nearby::sharing::proto::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.end_time)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nearby::sharing::proto::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::_internal_mutable_end_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::proto::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::nearby::sharing::proto::Timestamp* PublicCertificate::mutable_end_time() {
  ::nearby::sharing::proto::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.end_time)
  return _msg;
}
inline void PublicCertificate::set_allocated_end_time(::nearby::sharing::proto::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.end_time)
}

// bool for_selected_contacts = 6;
inline void PublicCertificate::clear_for_selected_contacts() {
  _impl_.for_selected_contacts_ = false;
}
inline bool PublicCertificate::for_selected_contacts() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.for_selected_contacts)
  return _internal_for_selected_contacts();
}
inline void PublicCertificate::set_for_selected_contacts(bool value) {
  _internal_set_for_selected_contacts(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.for_selected_contacts)
}
inline bool PublicCertificate::_internal_for_selected_contacts() const {
  return _impl_.for_selected_contacts_;
}
inline void PublicCertificate::_internal_set_for_selected_contacts(bool value) {
  ;
  _impl_.for_selected_contacts_ = value;
}

// bytes metadata_encryption_key = 7;
inline void PublicCertificate::clear_metadata_encryption_key() {
  _impl_.metadata_encryption_key_.ClearToEmpty();
}
inline const std::string& PublicCertificate::metadata_encryption_key() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.metadata_encryption_key)
  return _internal_metadata_encryption_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_metadata_encryption_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.metadata_encryption_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.metadata_encryption_key)
}
inline std::string* PublicCertificate::mutable_metadata_encryption_key() {
  std::string* _s = _internal_mutable_metadata_encryption_key();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.metadata_encryption_key)
  return _s;
}
inline const std::string& PublicCertificate::_internal_metadata_encryption_key() const {
  return _impl_.metadata_encryption_key_.Get();
}
inline void PublicCertificate::_internal_set_metadata_encryption_key(const std::string& value) {
  ;


  _impl_.metadata_encryption_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_metadata_encryption_key() {
  ;
  return _impl_.metadata_encryption_key_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_metadata_encryption_key() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.metadata_encryption_key)
  return _impl_.metadata_encryption_key_.Release();
}
inline void PublicCertificate::set_allocated_metadata_encryption_key(std::string* value) {
  _impl_.metadata_encryption_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_encryption_key_.IsDefault()) {
          _impl_.metadata_encryption_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.metadata_encryption_key)
}

// bytes encrypted_metadata_bytes = 8;
inline void PublicCertificate::clear_encrypted_metadata_bytes() {
  _impl_.encrypted_metadata_bytes_.ClearToEmpty();
}
inline const std::string& PublicCertificate::encrypted_metadata_bytes() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.encrypted_metadata_bytes)
  return _internal_encrypted_metadata_bytes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_encrypted_metadata_bytes(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.encrypted_metadata_bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.encrypted_metadata_bytes)
}
inline std::string* PublicCertificate::mutable_encrypted_metadata_bytes() {
  std::string* _s = _internal_mutable_encrypted_metadata_bytes();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.encrypted_metadata_bytes)
  return _s;
}
inline const std::string& PublicCertificate::_internal_encrypted_metadata_bytes() const {
  return _impl_.encrypted_metadata_bytes_.Get();
}
inline void PublicCertificate::_internal_set_encrypted_metadata_bytes(const std::string& value) {
  ;


  _impl_.encrypted_metadata_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_encrypted_metadata_bytes() {
  ;
  return _impl_.encrypted_metadata_bytes_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_encrypted_metadata_bytes() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.encrypted_metadata_bytes)
  return _impl_.encrypted_metadata_bytes_.Release();
}
inline void PublicCertificate::set_allocated_encrypted_metadata_bytes(std::string* value) {
  _impl_.encrypted_metadata_bytes_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encrypted_metadata_bytes_.IsDefault()) {
          _impl_.encrypted_metadata_bytes_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.encrypted_metadata_bytes)
}

// bytes metadata_encryption_key_tag = 9;
inline void PublicCertificate::clear_metadata_encryption_key_tag() {
  _impl_.metadata_encryption_key_tag_.ClearToEmpty();
}
inline const std::string& PublicCertificate::metadata_encryption_key_tag() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.metadata_encryption_key_tag)
  return _internal_metadata_encryption_key_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_metadata_encryption_key_tag(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.metadata_encryption_key_tag_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.metadata_encryption_key_tag)
}
inline std::string* PublicCertificate::mutable_metadata_encryption_key_tag() {
  std::string* _s = _internal_mutable_metadata_encryption_key_tag();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.PublicCertificate.metadata_encryption_key_tag)
  return _s;
}
inline const std::string& PublicCertificate::_internal_metadata_encryption_key_tag() const {
  return _impl_.metadata_encryption_key_tag_.Get();
}
inline void PublicCertificate::_internal_set_metadata_encryption_key_tag(const std::string& value) {
  ;


  _impl_.metadata_encryption_key_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_metadata_encryption_key_tag() {
  ;
  return _impl_.metadata_encryption_key_tag_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_metadata_encryption_key_tag() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.PublicCertificate.metadata_encryption_key_tag)
  return _impl_.metadata_encryption_key_tag_.Release();
}
inline void PublicCertificate::set_allocated_metadata_encryption_key_tag(std::string* value) {
  _impl_.metadata_encryption_key_tag_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_encryption_key_tag_.IsDefault()) {
          _impl_.metadata_encryption_key_tag_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.PublicCertificate.metadata_encryption_key_tag)
}

// bool for_self_share = 10;
inline void PublicCertificate::clear_for_self_share() {
  _impl_.for_self_share_ = false;
}
inline bool PublicCertificate::for_self_share() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.PublicCertificate.for_self_share)
  return _internal_for_self_share();
}
inline void PublicCertificate::set_for_self_share(bool value) {
  _internal_set_for_self_share(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.PublicCertificate.for_self_share)
}
inline bool PublicCertificate::_internal_for_self_share() const {
  return _impl_.for_self_share_;
}
inline void PublicCertificate::_internal_set_for_self_share(bool value) {
  ;
  _impl_.for_self_share_ = value;
}

// -------------------------------------------------------------------

// Contact_Identifier

// string obfuscated_gaia = 1;
inline bool Contact_Identifier::has_obfuscated_gaia() const {
  return identifier_case() == kObfuscatedGaia;
}
inline void Contact_Identifier::set_has_obfuscated_gaia() {
  _impl_._oneof_case_[0] = kObfuscatedGaia;
}
inline void Contact_Identifier::clear_obfuscated_gaia() {
  if (identifier_case() == kObfuscatedGaia) {
    _impl_.identifier_.obfuscated_gaia_.Destroy();
    clear_has_identifier();
  }
}
inline const std::string& Contact_Identifier::obfuscated_gaia() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Contact.Identifier.obfuscated_gaia)
  return _internal_obfuscated_gaia();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact_Identifier::set_obfuscated_gaia(Arg_&& arg,
                                                     Args_... args) {
  if (identifier_case() != kObfuscatedGaia) {
    clear_identifier();

    set_has_obfuscated_gaia();
    _impl_.identifier_.obfuscated_gaia_.InitDefault();
  }
  _impl_.identifier_.obfuscated_gaia_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Contact.Identifier.obfuscated_gaia)
}
inline std::string* Contact_Identifier::mutable_obfuscated_gaia() {
  std::string* _s = _internal_mutable_obfuscated_gaia();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Contact.Identifier.obfuscated_gaia)
  return _s;
}
inline const std::string& Contact_Identifier::_internal_obfuscated_gaia() const {
  if (identifier_case() != kObfuscatedGaia) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.identifier_.obfuscated_gaia_.Get();
}
inline void Contact_Identifier::_internal_set_obfuscated_gaia(const std::string& value) {
  if (identifier_case() != kObfuscatedGaia) {
    clear_identifier();

    set_has_obfuscated_gaia();
    _impl_.identifier_.obfuscated_gaia_.InitDefault();
  }


  _impl_.identifier_.obfuscated_gaia_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact_Identifier::_internal_mutable_obfuscated_gaia() {
  if (identifier_case() != kObfuscatedGaia) {
    clear_identifier();

    set_has_obfuscated_gaia();
    _impl_.identifier_.obfuscated_gaia_.InitDefault();
  }
  return _impl_.identifier_.obfuscated_gaia_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact_Identifier::release_obfuscated_gaia() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.Contact.Identifier.obfuscated_gaia)
  if (identifier_case() != kObfuscatedGaia) {
    return nullptr;
  }
  clear_has_identifier();
  return _impl_.identifier_.obfuscated_gaia_.Release();
}
inline void Contact_Identifier::set_allocated_obfuscated_gaia(std::string* value) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (value != nullptr) {
    set_has_obfuscated_gaia();
    _impl_.identifier_.obfuscated_gaia_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.Contact.Identifier.obfuscated_gaia)
}

// string phone_number = 2;
inline bool Contact_Identifier::has_phone_number() const {
  return identifier_case() == kPhoneNumber;
}
inline void Contact_Identifier::set_has_phone_number() {
  _impl_._oneof_case_[0] = kPhoneNumber;
}
inline void Contact_Identifier::clear_phone_number() {
  if (identifier_case() == kPhoneNumber) {
    _impl_.identifier_.phone_number_.Destroy();
    clear_has_identifier();
  }
}
inline const std::string& Contact_Identifier::phone_number() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Contact.Identifier.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact_Identifier::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  if (identifier_case() != kPhoneNumber) {
    clear_identifier();

    set_has_phone_number();
    _impl_.identifier_.phone_number_.InitDefault();
  }
  _impl_.identifier_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Contact.Identifier.phone_number)
}
inline std::string* Contact_Identifier::mutable_phone_number() {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Contact.Identifier.phone_number)
  return _s;
}
inline const std::string& Contact_Identifier::_internal_phone_number() const {
  if (identifier_case() != kPhoneNumber) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.identifier_.phone_number_.Get();
}
inline void Contact_Identifier::_internal_set_phone_number(const std::string& value) {
  if (identifier_case() != kPhoneNumber) {
    clear_identifier();

    set_has_phone_number();
    _impl_.identifier_.phone_number_.InitDefault();
  }


  _impl_.identifier_.phone_number_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact_Identifier::_internal_mutable_phone_number() {
  if (identifier_case() != kPhoneNumber) {
    clear_identifier();

    set_has_phone_number();
    _impl_.identifier_.phone_number_.InitDefault();
  }
  return _impl_.identifier_.phone_number_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact_Identifier::release_phone_number() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.Contact.Identifier.phone_number)
  if (identifier_case() != kPhoneNumber) {
    return nullptr;
  }
  clear_has_identifier();
  return _impl_.identifier_.phone_number_.Release();
}
inline void Contact_Identifier::set_allocated_phone_number(std::string* value) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (value != nullptr) {
    set_has_phone_number();
    _impl_.identifier_.phone_number_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.Contact.Identifier.phone_number)
}

// string account_name = 3;
inline bool Contact_Identifier::has_account_name() const {
  return identifier_case() == kAccountName;
}
inline void Contact_Identifier::set_has_account_name() {
  _impl_._oneof_case_[0] = kAccountName;
}
inline void Contact_Identifier::clear_account_name() {
  if (identifier_case() == kAccountName) {
    _impl_.identifier_.account_name_.Destroy();
    clear_has_identifier();
  }
}
inline const std::string& Contact_Identifier::account_name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Contact.Identifier.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact_Identifier::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  if (identifier_case() != kAccountName) {
    clear_identifier();

    set_has_account_name();
    _impl_.identifier_.account_name_.InitDefault();
  }
  _impl_.identifier_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Contact.Identifier.account_name)
}
inline std::string* Contact_Identifier::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Contact.Identifier.account_name)
  return _s;
}
inline const std::string& Contact_Identifier::_internal_account_name() const {
  if (identifier_case() != kAccountName) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.identifier_.account_name_.Get();
}
inline void Contact_Identifier::_internal_set_account_name(const std::string& value) {
  if (identifier_case() != kAccountName) {
    clear_identifier();

    set_has_account_name();
    _impl_.identifier_.account_name_.InitDefault();
  }


  _impl_.identifier_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact_Identifier::_internal_mutable_account_name() {
  if (identifier_case() != kAccountName) {
    clear_identifier();

    set_has_account_name();
    _impl_.identifier_.account_name_.InitDefault();
  }
  return _impl_.identifier_.account_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact_Identifier::release_account_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.Contact.Identifier.account_name)
  if (identifier_case() != kAccountName) {
    return nullptr;
  }
  clear_has_identifier();
  return _impl_.identifier_.account_name_.Release();
}
inline void Contact_Identifier::set_allocated_account_name(std::string* value) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (value != nullptr) {
    set_has_account_name();
    _impl_.identifier_.account_name_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.Contact.Identifier.account_name)
}

inline bool Contact_Identifier::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void Contact_Identifier::clear_has_identifier() {
  _impl_._oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline Contact_Identifier::IdentifierCase Contact_Identifier::identifier_case() const {
  return Contact_Identifier::IdentifierCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Contact

// .nearby.sharing.proto.Contact.Identifier identifier = 1;
inline bool Contact::has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.identifier_ != nullptr);
  return value;
}
inline void Contact::clear_identifier() {
  if (_impl_.identifier_ != nullptr) _impl_.identifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nearby::sharing::proto::Contact_Identifier& Contact::_internal_identifier() const {
  const ::nearby::sharing::proto::Contact_Identifier* p = _impl_.identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::proto::Contact_Identifier&>(
      ::nearby::sharing::proto::_Contact_Identifier_default_instance_);
}
inline const ::nearby::sharing::proto::Contact_Identifier& Contact::identifier() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Contact.identifier)
  return _internal_identifier();
}
inline void Contact::unsafe_arena_set_allocated_identifier(
    ::nearby::sharing::proto::Contact_Identifier* identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifier_);
  }
  _impl_.identifier_ = identifier;
  if (identifier) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.proto.Contact.identifier)
}
inline ::nearby::sharing::proto::Contact_Identifier* Contact::release_identifier() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::proto::Contact_Identifier* temp = _impl_.identifier_;
  _impl_.identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::proto::Contact_Identifier* Contact::unsafe_arena_release_identifier() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.Contact.identifier)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::proto::Contact_Identifier* temp = _impl_.identifier_;
  _impl_.identifier_ = nullptr;
  return temp;
}
inline ::nearby::sharing::proto::Contact_Identifier* Contact::_internal_mutable_identifier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::proto::Contact_Identifier>(GetArenaForAllocation());
    _impl_.identifier_ = p;
  }
  return _impl_.identifier_;
}
inline ::nearby::sharing::proto::Contact_Identifier* Contact::mutable_identifier() {
  ::nearby::sharing::proto::Contact_Identifier* _msg = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Contact.identifier)
  return _msg;
}
inline void Contact::set_allocated_identifier(::nearby::sharing::proto::Contact_Identifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifier);
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.Contact.identifier)
}

// bool is_selected = 2;
inline void Contact::clear_is_selected() {
  _impl_.is_selected_ = false;
}
inline bool Contact::is_selected() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Contact.is_selected)
  return _internal_is_selected();
}
inline void Contact::set_is_selected(bool value) {
  _internal_set_is_selected(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Contact.is_selected)
}
inline bool Contact::_internal_is_selected() const {
  return _impl_.is_selected_;
}
inline void Contact::_internal_set_is_selected(bool value) {
  ;
  _impl_.is_selected_ = value;
}

// bool is_self = 3;
inline void Contact::clear_is_self() {
  _impl_.is_self_ = false;
}
inline bool Contact::is_self() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Contact.is_self)
  return _internal_is_self();
}
inline void Contact::set_is_self(bool value) {
  _internal_set_is_self(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Contact.is_self)
}
inline bool Contact::_internal_is_self() const {
  return _impl_.is_self_;
}
inline void Contact::_internal_set_is_self(bool value) {
  ;
  _impl_.is_self_ = value;
}

// -------------------------------------------------------------------

// ContactRecord

// string id = 1;
inline void ContactRecord::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ContactRecord::id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ContactRecord.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContactRecord::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.ContactRecord.id)
}
inline std::string* ContactRecord::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.ContactRecord.id)
  return _s;
}
inline const std::string& ContactRecord::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ContactRecord::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactRecord::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* ContactRecord::release_id() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.ContactRecord.id)
  return _impl_.id_.Release();
}
inline void ContactRecord::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.ContactRecord.id)
}

// string person_name = 2;
inline void ContactRecord::clear_person_name() {
  _impl_.person_name_.ClearToEmpty();
}
inline const std::string& ContactRecord::person_name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ContactRecord.person_name)
  return _internal_person_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContactRecord::set_person_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.person_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.ContactRecord.person_name)
}
inline std::string* ContactRecord::mutable_person_name() {
  std::string* _s = _internal_mutable_person_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.ContactRecord.person_name)
  return _s;
}
inline const std::string& ContactRecord::_internal_person_name() const {
  return _impl_.person_name_.Get();
}
inline void ContactRecord::_internal_set_person_name(const std::string& value) {
  ;


  _impl_.person_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactRecord::_internal_mutable_person_name() {
  ;
  return _impl_.person_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ContactRecord::release_person_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.ContactRecord.person_name)
  return _impl_.person_name_.Release();
}
inline void ContactRecord::set_allocated_person_name(std::string* value) {
  _impl_.person_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.person_name_.IsDefault()) {
          _impl_.person_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.ContactRecord.person_name)
}

// string image_url = 3;
inline void ContactRecord::clear_image_url() {
  _impl_.image_url_.ClearToEmpty();
}
inline const std::string& ContactRecord::image_url() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ContactRecord.image_url)
  return _internal_image_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContactRecord::set_image_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.image_url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.ContactRecord.image_url)
}
inline std::string* ContactRecord::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.ContactRecord.image_url)
  return _s;
}
inline const std::string& ContactRecord::_internal_image_url() const {
  return _impl_.image_url_.Get();
}
inline void ContactRecord::_internal_set_image_url(const std::string& value) {
  ;


  _impl_.image_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactRecord::_internal_mutable_image_url() {
  ;
  return _impl_.image_url_.Mutable( GetArenaForAllocation());
}
inline std::string* ContactRecord::release_image_url() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.ContactRecord.image_url)
  return _impl_.image_url_.Release();
}
inline void ContactRecord::set_allocated_image_url(std::string* value) {
  _impl_.image_url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.image_url_.IsDefault()) {
          _impl_.image_url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.ContactRecord.image_url)
}

// repeated .nearby.sharing.proto.Contact.Identifier identifiers = 4;
inline int ContactRecord::_internal_identifiers_size() const {
  return _impl_.identifiers_.size();
}
inline int ContactRecord::identifiers_size() const {
  return _internal_identifiers_size();
}
inline void ContactRecord::clear_identifiers() {
  _internal_mutable_identifiers()->Clear();
}
inline ::nearby::sharing::proto::Contact_Identifier* ContactRecord::mutable_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.ContactRecord.identifiers)
  return _internal_mutable_identifiers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact_Identifier >*
ContactRecord::mutable_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.proto.ContactRecord.identifiers)
  return _internal_mutable_identifiers();
}
inline const ::nearby::sharing::proto::Contact_Identifier& ContactRecord::_internal_identifiers(int index) const {
  return _internal_identifiers().Get(index);
}
inline const ::nearby::sharing::proto::Contact_Identifier& ContactRecord::identifiers(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ContactRecord.identifiers)
  return _internal_identifiers(index);
}
inline ::nearby::sharing::proto::Contact_Identifier* ContactRecord::_internal_add_identifiers() {
  return _internal_mutable_identifiers()->Add();
}
inline ::nearby::sharing::proto::Contact_Identifier* ContactRecord::add_identifiers() {
  ::nearby::sharing::proto::Contact_Identifier* _add = _internal_add_identifiers();
  // @@protoc_insertion_point(field_add:nearby.sharing.proto.ContactRecord.identifiers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact_Identifier >&
ContactRecord::identifiers() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.proto.ContactRecord.identifiers)
  return _internal_identifiers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact_Identifier>&
ContactRecord::_internal_identifiers() const {
  return _impl_.identifiers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact_Identifier>*
ContactRecord::_internal_mutable_identifiers() {
  return &_impl_.identifiers_;
}

// .nearby.sharing.proto.ContactRecord.Type type = 5;
inline void ContactRecord::clear_type() {
  _impl_.type_ = 0;
}
inline ::nearby::sharing::proto::ContactRecord_Type ContactRecord::type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ContactRecord.type)
  return _internal_type();
}
inline void ContactRecord::set_type(::nearby::sharing::proto::ContactRecord_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.ContactRecord.type)
}
inline ::nearby::sharing::proto::ContactRecord_Type ContactRecord::_internal_type() const {
  return static_cast<::nearby::sharing::proto::ContactRecord_Type>(_impl_.type_);
}
inline void ContactRecord::_internal_set_type(::nearby::sharing::proto::ContactRecord_Type value) {
  ;
  _impl_.type_ = value;
}

// bool is_reachable = 6;
inline void ContactRecord::clear_is_reachable() {
  _impl_.is_reachable_ = false;
}
inline bool ContactRecord::is_reachable() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ContactRecord.is_reachable)
  return _internal_is_reachable();
}
inline void ContactRecord::set_is_reachable(bool value) {
  _internal_set_is_reachable(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.ContactRecord.is_reachable)
}
inline bool ContactRecord::_internal_is_reachable() const {
  return _impl_.is_reachable_;
}
inline void ContactRecord::_internal_set_is_reachable(bool value) {
  ;
  _impl_.is_reachable_ = value;
}

// -------------------------------------------------------------------

// ShareTarget

// repeated .nearby.sharing.proto.PublicCertificate public_certificates = 1;
inline int ShareTarget::_internal_public_certificates_size() const {
  return _impl_.public_certificates_.size();
}
inline int ShareTarget::public_certificates_size() const {
  return _internal_public_certificates_size();
}
inline void ShareTarget::clear_public_certificates() {
  _internal_mutable_public_certificates()->Clear();
}
inline ::nearby::sharing::proto::PublicCertificate* ShareTarget::mutable_public_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.ShareTarget.public_certificates)
  return _internal_mutable_public_certificates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >*
ShareTarget::mutable_public_certificates() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.proto.ShareTarget.public_certificates)
  return _internal_mutable_public_certificates();
}
inline const ::nearby::sharing::proto::PublicCertificate& ShareTarget::_internal_public_certificates(int index) const {
  return _internal_public_certificates().Get(index);
}
inline const ::nearby::sharing::proto::PublicCertificate& ShareTarget::public_certificates(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.ShareTarget.public_certificates)
  return _internal_public_certificates(index);
}
inline ::nearby::sharing::proto::PublicCertificate* ShareTarget::_internal_add_public_certificates() {
  return _internal_mutable_public_certificates()->Add();
}
inline ::nearby::sharing::proto::PublicCertificate* ShareTarget::add_public_certificates() {
  ::nearby::sharing::proto::PublicCertificate* _add = _internal_add_public_certificates();
  // @@protoc_insertion_point(field_add:nearby.sharing.proto.ShareTarget.public_certificates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >&
ShareTarget::public_certificates() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.proto.ShareTarget.public_certificates)
  return _internal_public_certificates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>&
ShareTarget::_internal_public_certificates() const {
  return _impl_.public_certificates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>*
ShareTarget::_internal_mutable_public_certificates() {
  return &_impl_.public_certificates_;
}

// -------------------------------------------------------------------

// Device

// string name = 1;
inline void Device::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Device::name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Device.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Device::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Device.name)
}
inline std::string* Device::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Device.name)
  return _s;
}
inline const std::string& Device::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Device::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Device::release_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.Device.name)
  return _impl_.name_.Release();
}
inline void Device::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.Device.name)
}

// string display_name = 2;
inline void Device::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Device::display_name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Device.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Device::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.proto.Device.display_name)
}
inline std::string* Device::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Device.display_name)
  return _s;
}
inline const std::string& Device::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Device::_internal_set_display_name(const std::string& value) {
  ;


  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_display_name() {
  ;
  return _impl_.display_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Device::release_display_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.proto.Device.display_name)
  return _impl_.display_name_.Release();
}
inline void Device::set_allocated_display_name(std::string* value) {
  _impl_.display_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.proto.Device.display_name)
}

// repeated .nearby.sharing.proto.Contact contacts = 3;
inline int Device::_internal_contacts_size() const {
  return _impl_.contacts_.size();
}
inline int Device::contacts_size() const {
  return _internal_contacts_size();
}
inline void Device::clear_contacts() {
  _internal_mutable_contacts()->Clear();
}
inline ::nearby::sharing::proto::Contact* Device::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Device.contacts)
  return _internal_mutable_contacts()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact >*
Device::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.proto.Device.contacts)
  return _internal_mutable_contacts();
}
inline const ::nearby::sharing::proto::Contact& Device::_internal_contacts(int index) const {
  return _internal_contacts().Get(index);
}
inline const ::nearby::sharing::proto::Contact& Device::contacts(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Device.contacts)
  return _internal_contacts(index);
}
inline ::nearby::sharing::proto::Contact* Device::_internal_add_contacts() {
  return _internal_mutable_contacts()->Add();
}
inline ::nearby::sharing::proto::Contact* Device::add_contacts() {
  ::nearby::sharing::proto::Contact* _add = _internal_add_contacts();
  // @@protoc_insertion_point(field_add:nearby.sharing.proto.Device.contacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::Contact >&
Device::contacts() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.proto.Device.contacts)
  return _internal_contacts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact>&
Device::_internal_contacts() const {
  return _impl_.contacts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::Contact>*
Device::_internal_mutable_contacts() {
  return &_impl_.contacts_;
}

// repeated .nearby.sharing.proto.PublicCertificate public_certificates = 4;
inline int Device::_internal_public_certificates_size() const {
  return _impl_.public_certificates_.size();
}
inline int Device::public_certificates_size() const {
  return _internal_public_certificates_size();
}
inline void Device::clear_public_certificates() {
  _internal_mutable_public_certificates()->Clear();
}
inline ::nearby::sharing::proto::PublicCertificate* Device::mutable_public_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.proto.Device.public_certificates)
  return _internal_mutable_public_certificates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >*
Device::mutable_public_certificates() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.proto.Device.public_certificates)
  return _internal_mutable_public_certificates();
}
inline const ::nearby::sharing::proto::PublicCertificate& Device::_internal_public_certificates(int index) const {
  return _internal_public_certificates().Get(index);
}
inline const ::nearby::sharing::proto::PublicCertificate& Device::public_certificates(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.proto.Device.public_certificates)
  return _internal_public_certificates(index);
}
inline ::nearby::sharing::proto::PublicCertificate* Device::_internal_add_public_certificates() {
  return _internal_mutable_public_certificates()->Add();
}
inline ::nearby::sharing::proto::PublicCertificate* Device::add_public_certificates() {
  ::nearby::sharing::proto::PublicCertificate* _add = _internal_add_public_certificates();
  // @@protoc_insertion_point(field_add:nearby.sharing.proto.Device.public_certificates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::proto::PublicCertificate >&
Device::public_certificates() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.proto.Device.public_certificates)
  return _internal_public_certificates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>&
Device::_internal_public_certificates() const {
  return _impl_.public_certificates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::proto::PublicCertificate>*
Device::_internal_mutable_public_certificates() {
  return &_impl_.public_certificates_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace sharing
}  // namespace nearby


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::nearby::sharing::proto::ContactRecord_Type> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2frpc_5fresources_2eproto_2epb_2eh
