// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing/proto/wire_format.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2fwire_5fformat_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2fwire_5fformat_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry_lite.h"
#include "google/protobuf/map_field_lite.h"
#include "google/protobuf/generated_enum_util.h"
#include "proto/sharing_enums.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sharing_2fproto_2fwire_5fformat_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sharing_2fproto_2fwire_5fformat_2eproto {
  static const ::uint32_t offsets[];
};
namespace nearby {
namespace sharing {
namespace service {
namespace proto {
class AppMetadata;
struct AppMetadataDefaultTypeInternal;
extern AppMetadataDefaultTypeInternal _AppMetadata_default_instance_;
class AttachmentDetails;
struct AttachmentDetailsDefaultTypeInternal;
extern AttachmentDetailsDefaultTypeInternal _AttachmentDetails_default_instance_;
class CertificateInfoFrame;
struct CertificateInfoFrameDefaultTypeInternal;
extern CertificateInfoFrameDefaultTypeInternal _CertificateInfoFrame_default_instance_;
class ConnectionResponseFrame;
struct ConnectionResponseFrameDefaultTypeInternal;
extern ConnectionResponseFrameDefaultTypeInternal _ConnectionResponseFrame_default_instance_;
class ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse;
struct ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUseDefaultTypeInternal;
extern ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUseDefaultTypeInternal _ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse_default_instance_;
class FileAttachmentDetails;
struct FileAttachmentDetailsDefaultTypeInternal;
extern FileAttachmentDetailsDefaultTypeInternal _FileAttachmentDetails_default_instance_;
class FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse;
struct FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUseDefaultTypeInternal;
extern FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUseDefaultTypeInternal _FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse_default_instance_;
class FileMetadata;
struct FileMetadataDefaultTypeInternal;
extern FileMetadataDefaultTypeInternal _FileMetadata_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class IntroductionFrame;
struct IntroductionFrameDefaultTypeInternal;
extern IntroductionFrameDefaultTypeInternal _IntroductionFrame_default_instance_;
class PairedKeyEncryptionFrame;
struct PairedKeyEncryptionFrameDefaultTypeInternal;
extern PairedKeyEncryptionFrameDefaultTypeInternal _PairedKeyEncryptionFrame_default_instance_;
class PairedKeyResultFrame;
struct PairedKeyResultFrameDefaultTypeInternal;
extern PairedKeyResultFrameDefaultTypeInternal _PairedKeyResultFrame_default_instance_;
class PayloadDetails;
struct PayloadDetailsDefaultTypeInternal;
extern PayloadDetailsDefaultTypeInternal _PayloadDetails_default_instance_;
class PayloadsDetails;
struct PayloadsDetailsDefaultTypeInternal;
extern PayloadsDetailsDefaultTypeInternal _PayloadsDetails_default_instance_;
class ProgressUpdateFrame;
struct ProgressUpdateFrameDefaultTypeInternal;
extern ProgressUpdateFrameDefaultTypeInternal _ProgressUpdateFrame_default_instance_;
class PublicCertificate;
struct PublicCertificateDefaultTypeInternal;
extern PublicCertificateDefaultTypeInternal _PublicCertificate_default_instance_;
class TextMetadata;
struct TextMetadataDefaultTypeInternal;
extern TextMetadataDefaultTypeInternal _TextMetadata_default_instance_;
class V1Frame;
struct V1FrameDefaultTypeInternal;
extern V1FrameDefaultTypeInternal _V1Frame_default_instance_;
class WifiCredentials;
struct WifiCredentialsDefaultTypeInternal;
extern WifiCredentialsDefaultTypeInternal _WifiCredentials_default_instance_;
class WifiCredentialsMetadata;
struct WifiCredentialsMetadataDefaultTypeInternal;
extern WifiCredentialsMetadataDefaultTypeInternal _WifiCredentialsMetadata_default_instance_;
}  // namespace proto
}  // namespace service
}  // namespace sharing
}  // namespace nearby
PROTOBUF_NAMESPACE_OPEN
template <>
::nearby::sharing::service::proto::AppMetadata* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::AppMetadata>(Arena*);
template <>
::nearby::sharing::service::proto::AttachmentDetails* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::AttachmentDetails>(Arena*);
template <>
::nearby::sharing::service::proto::CertificateInfoFrame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::CertificateInfoFrame>(Arena*);
template <>
::nearby::sharing::service::proto::ConnectionResponseFrame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::ConnectionResponseFrame>(Arena*);
template <>
::nearby::sharing::service::proto::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse>(Arena*);
template <>
::nearby::sharing::service::proto::FileAttachmentDetails* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::FileAttachmentDetails>(Arena*);
template <>
::nearby::sharing::service::proto::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse>(Arena*);
template <>
::nearby::sharing::service::proto::FileMetadata* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::FileMetadata>(Arena*);
template <>
::nearby::sharing::service::proto::Frame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::Frame>(Arena*);
template <>
::nearby::sharing::service::proto::IntroductionFrame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::IntroductionFrame>(Arena*);
template <>
::nearby::sharing::service::proto::PairedKeyEncryptionFrame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::PairedKeyEncryptionFrame>(Arena*);
template <>
::nearby::sharing::service::proto::PairedKeyResultFrame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::PairedKeyResultFrame>(Arena*);
template <>
::nearby::sharing::service::proto::PayloadDetails* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::PayloadDetails>(Arena*);
template <>
::nearby::sharing::service::proto::PayloadsDetails* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::PayloadsDetails>(Arena*);
template <>
::nearby::sharing::service::proto::ProgressUpdateFrame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::ProgressUpdateFrame>(Arena*);
template <>
::nearby::sharing::service::proto::PublicCertificate* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::PublicCertificate>(Arena*);
template <>
::nearby::sharing::service::proto::TextMetadata* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::TextMetadata>(Arena*);
template <>
::nearby::sharing::service::proto::V1Frame* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::V1Frame>(Arena*);
template <>
::nearby::sharing::service::proto::WifiCredentials* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::WifiCredentials>(Arena*);
template <>
::nearby::sharing::service::proto::WifiCredentialsMetadata* Arena::CreateMaybeMessage<::nearby::sharing::service::proto::WifiCredentialsMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace nearby {
namespace sharing {
namespace service {
namespace proto {
enum FileMetadata_Type : int {
  FileMetadata_Type_UNKNOWN = 0,
  FileMetadata_Type_IMAGE = 1,
  FileMetadata_Type_VIDEO = 2,
  FileMetadata_Type_ANDROID_APP = 3,
  FileMetadata_Type_AUDIO = 4,
  FileMetadata_Type_DOCUMENT = 5,
};

bool FileMetadata_Type_IsValid(int value);
constexpr FileMetadata_Type FileMetadata_Type_Type_MIN = static_cast<FileMetadata_Type>(0);
constexpr FileMetadata_Type FileMetadata_Type_Type_MAX = static_cast<FileMetadata_Type>(5);
constexpr int FileMetadata_Type_Type_ARRAYSIZE = 5 + 1;
const std::string& FileMetadata_Type_Name(FileMetadata_Type value);
template <typename T>
const std::string& FileMetadata_Type_Name(T value) {
  static_assert(std::is_same<T, FileMetadata_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return FileMetadata_Type_Name(static_cast<FileMetadata_Type>(value));
}
const std::string& FileMetadata_Type_Name(FileMetadata_Type value);
bool FileMetadata_Type_Parse(absl::string_view name, FileMetadata_Type* value);
enum TextMetadata_Type : int {
  TextMetadata_Type_UNKNOWN = 0,
  TextMetadata_Type_TEXT = 1,
  TextMetadata_Type_URL = 2,
  TextMetadata_Type_ADDRESS = 3,
  TextMetadata_Type_PHONE_NUMBER = 4,
};

bool TextMetadata_Type_IsValid(int value);
constexpr TextMetadata_Type TextMetadata_Type_Type_MIN = static_cast<TextMetadata_Type>(0);
constexpr TextMetadata_Type TextMetadata_Type_Type_MAX = static_cast<TextMetadata_Type>(4);
constexpr int TextMetadata_Type_Type_ARRAYSIZE = 4 + 1;
const std::string& TextMetadata_Type_Name(TextMetadata_Type value);
template <typename T>
const std::string& TextMetadata_Type_Name(T value) {
  static_assert(std::is_same<T, TextMetadata_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TextMetadata_Type_Name(static_cast<TextMetadata_Type>(value));
}
const std::string& TextMetadata_Type_Name(TextMetadata_Type value);
bool TextMetadata_Type_Parse(absl::string_view name, TextMetadata_Type* value);
enum WifiCredentialsMetadata_SecurityType : int {
  WifiCredentialsMetadata_SecurityType_UNKNOWN_SECURITY_TYPE = 0,
  WifiCredentialsMetadata_SecurityType_OPEN = 1,
  WifiCredentialsMetadata_SecurityType_WPA_PSK = 2,
  WifiCredentialsMetadata_SecurityType_WEP = 3,
  WifiCredentialsMetadata_SecurityType_SAE = 4,
};

bool WifiCredentialsMetadata_SecurityType_IsValid(int value);
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata_SecurityType_SecurityType_MIN = static_cast<WifiCredentialsMetadata_SecurityType>(0);
constexpr WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata_SecurityType_SecurityType_MAX = static_cast<WifiCredentialsMetadata_SecurityType>(4);
constexpr int WifiCredentialsMetadata_SecurityType_SecurityType_ARRAYSIZE = 4 + 1;
const std::string& WifiCredentialsMetadata_SecurityType_Name(WifiCredentialsMetadata_SecurityType value);
template <typename T>
const std::string& WifiCredentialsMetadata_SecurityType_Name(T value) {
  static_assert(std::is_same<T, WifiCredentialsMetadata_SecurityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SecurityType_Name().");
  return WifiCredentialsMetadata_SecurityType_Name(static_cast<WifiCredentialsMetadata_SecurityType>(value));
}
const std::string& WifiCredentialsMetadata_SecurityType_Name(WifiCredentialsMetadata_SecurityType value);
bool WifiCredentialsMetadata_SecurityType_Parse(absl::string_view name, WifiCredentialsMetadata_SecurityType* value);
enum Frame_Version : int {
  Frame_Version_UNKNOWN_VERSION = 0,
  Frame_Version_V1 = 1,
};

bool Frame_Version_IsValid(int value);
constexpr Frame_Version Frame_Version_Version_MIN = static_cast<Frame_Version>(0);
constexpr Frame_Version Frame_Version_Version_MAX = static_cast<Frame_Version>(1);
constexpr int Frame_Version_Version_ARRAYSIZE = 1 + 1;
const std::string& Frame_Version_Name(Frame_Version value);
template <typename T>
const std::string& Frame_Version_Name(T value) {
  static_assert(std::is_same<T, Frame_Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return Frame_Version_Name(static_cast<Frame_Version>(value));
}
const std::string& Frame_Version_Name(Frame_Version value);
bool Frame_Version_Parse(absl::string_view name, Frame_Version* value);
enum V1Frame_FrameType : int {
  V1Frame_FrameType_UNKNOWN_FRAME_TYPE = 0,
  V1Frame_FrameType_INTRODUCTION = 1,
  V1Frame_FrameType_RESPONSE = 2,
  V1Frame_FrameType_PAIRED_KEY_ENCRYPTION = 3,
  V1Frame_FrameType_PAIRED_KEY_RESULT = 4,
  V1Frame_FrameType_CERTIFICATE_INFO = 5,
  V1Frame_FrameType_CANCEL = 6,
  V1Frame_FrameType_PROGRESS_UPDATE = 7,
};

bool V1Frame_FrameType_IsValid(int value);
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MIN = static_cast<V1Frame_FrameType>(0);
constexpr V1Frame_FrameType V1Frame_FrameType_FrameType_MAX = static_cast<V1Frame_FrameType>(7);
constexpr int V1Frame_FrameType_FrameType_ARRAYSIZE = 7 + 1;
const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value);
template <typename T>
const std::string& V1Frame_FrameType_Name(T value) {
  static_assert(std::is_same<T, V1Frame_FrameType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FrameType_Name().");
  return V1Frame_FrameType_Name(static_cast<V1Frame_FrameType>(value));
}
const std::string& V1Frame_FrameType_Name(V1Frame_FrameType value);
bool V1Frame_FrameType_Parse(absl::string_view name, V1Frame_FrameType* value);
enum ConnectionResponseFrame_Status : int {
  ConnectionResponseFrame_Status_UNKNOWN = 0,
  ConnectionResponseFrame_Status_ACCEPT = 1,
  ConnectionResponseFrame_Status_REJECT = 2,
  ConnectionResponseFrame_Status_NOT_ENOUGH_SPACE = 3,
  ConnectionResponseFrame_Status_UNSUPPORTED_ATTACHMENT_TYPE = 4,
  ConnectionResponseFrame_Status_TIMED_OUT = 5,
};

bool ConnectionResponseFrame_Status_IsValid(int value);
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame_Status_Status_MIN = static_cast<ConnectionResponseFrame_Status>(0);
constexpr ConnectionResponseFrame_Status ConnectionResponseFrame_Status_Status_MAX = static_cast<ConnectionResponseFrame_Status>(5);
constexpr int ConnectionResponseFrame_Status_Status_ARRAYSIZE = 5 + 1;
const std::string& ConnectionResponseFrame_Status_Name(ConnectionResponseFrame_Status value);
template <typename T>
const std::string& ConnectionResponseFrame_Status_Name(T value) {
  static_assert(std::is_same<T, ConnectionResponseFrame_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return ConnectionResponseFrame_Status_Name(static_cast<ConnectionResponseFrame_Status>(value));
}
const std::string& ConnectionResponseFrame_Status_Name(ConnectionResponseFrame_Status value);
bool ConnectionResponseFrame_Status_Parse(absl::string_view name, ConnectionResponseFrame_Status* value);
enum AttachmentDetails_Type : int {
  AttachmentDetails_Type_UNKNOWN = 0,
  AttachmentDetails_Type_FILE = 1,
  AttachmentDetails_Type_TEXT = 2,
  AttachmentDetails_Type_WIFI_CREDENTIALS = 3,
  AttachmentDetails_Type_APP = 4,
};

bool AttachmentDetails_Type_IsValid(int value);
constexpr AttachmentDetails_Type AttachmentDetails_Type_Type_MIN = static_cast<AttachmentDetails_Type>(0);
constexpr AttachmentDetails_Type AttachmentDetails_Type_Type_MAX = static_cast<AttachmentDetails_Type>(4);
constexpr int AttachmentDetails_Type_Type_ARRAYSIZE = 4 + 1;
const std::string& AttachmentDetails_Type_Name(AttachmentDetails_Type value);
template <typename T>
const std::string& AttachmentDetails_Type_Name(T value) {
  static_assert(std::is_same<T, AttachmentDetails_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return AttachmentDetails_Type_Name(static_cast<AttachmentDetails_Type>(value));
}
const std::string& AttachmentDetails_Type_Name(AttachmentDetails_Type value);
bool AttachmentDetails_Type_Parse(absl::string_view name, AttachmentDetails_Type* value);
enum PairedKeyResultFrame_Status : int {
  PairedKeyResultFrame_Status_UNKNOWN = 0,
  PairedKeyResultFrame_Status_SUCCESS = 1,
  PairedKeyResultFrame_Status_FAIL = 2,
  PairedKeyResultFrame_Status_UNABLE = 3,
};

bool PairedKeyResultFrame_Status_IsValid(int value);
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame_Status_Status_MIN = static_cast<PairedKeyResultFrame_Status>(0);
constexpr PairedKeyResultFrame_Status PairedKeyResultFrame_Status_Status_MAX = static_cast<PairedKeyResultFrame_Status>(3);
constexpr int PairedKeyResultFrame_Status_Status_ARRAYSIZE = 3 + 1;
const std::string& PairedKeyResultFrame_Status_Name(PairedKeyResultFrame_Status value);
template <typename T>
const std::string& PairedKeyResultFrame_Status_Name(T value) {
  static_assert(std::is_same<T, PairedKeyResultFrame_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return PairedKeyResultFrame_Status_Name(static_cast<PairedKeyResultFrame_Status>(value));
}
const std::string& PairedKeyResultFrame_Status_Name(PairedKeyResultFrame_Status value);
bool PairedKeyResultFrame_Status_Parse(absl::string_view name, PairedKeyResultFrame_Status* value);

// ===================================================================


// -------------------------------------------------------------------

class FileMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.FileMetadata) */ {
 public:
  inline FileMetadata() : FileMetadata(nullptr) {}
  ~FileMetadata() override;
  explicit PROTOBUF_CONSTEXPR FileMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileMetadata(const FileMetadata& from);
  FileMetadata(FileMetadata&& from) noexcept
    : FileMetadata() {
    *this = ::std::move(from);
  }

  inline FileMetadata& operator=(const FileMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMetadata& operator=(FileMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FileMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMetadata* internal_default_instance() {
    return reinterpret_cast<const FileMetadata*>(
               &_FileMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FileMetadata& a, FileMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileMetadata& from);
  void MergeFrom(const FileMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.FileMetadata";
  }
  protected:
  explicit FileMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = FileMetadata_Type;
  static constexpr Type UNKNOWN = FileMetadata_Type_UNKNOWN;
  static constexpr Type IMAGE = FileMetadata_Type_IMAGE;
  static constexpr Type VIDEO = FileMetadata_Type_VIDEO;
  static constexpr Type ANDROID_APP = FileMetadata_Type_ANDROID_APP;
  static constexpr Type AUDIO = FileMetadata_Type_AUDIO;
  static constexpr Type DOCUMENT = FileMetadata_Type_DOCUMENT;
  static inline bool Type_IsValid(int value) {
    return FileMetadata_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = FileMetadata_Type_Type_MIN;
  static constexpr Type Type_MAX = FileMetadata_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = FileMetadata_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return FileMetadata_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return FileMetadata_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMimeTypeFieldNumber = 5,
    kParentFolderFieldNumber = 7,
    kPayloadIdFieldNumber = 3,
    kSizeFieldNumber = 4,
    kIdFieldNumber = 6,
    kAttachmentHashFieldNumber = 8,
    kTypeFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string mime_type = 5 [default = "application/octet-stream"];
  bool has_mime_type() const;
  void clear_mime_type() ;
  const std::string& mime_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mime_type(Arg_&& arg, Args_... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* ptr);

  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(
      const std::string& value);
  std::string* _internal_mutable_mime_type();

  public:
  // optional string parent_folder = 7;
  bool has_parent_folder() const;
  void clear_parent_folder() ;
  const std::string& parent_folder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_folder(Arg_&& arg, Args_... args);
  std::string* mutable_parent_folder();
  PROTOBUF_NODISCARD std::string* release_parent_folder();
  void set_allocated_parent_folder(std::string* ptr);

  private:
  const std::string& _internal_parent_folder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_folder(
      const std::string& value);
  std::string* _internal_mutable_parent_folder();

  public:
  // optional int64 payload_id = 3;
  bool has_payload_id() const;
  void clear_payload_id() ;
  ::int64_t payload_id() const;
  void set_payload_id(::int64_t value);

  private:
  ::int64_t _internal_payload_id() const;
  void _internal_set_payload_id(::int64_t value);

  public:
  // optional int64 size = 4;
  bool has_size() const;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // optional int64 id = 6;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional int64 attachment_hash = 8;
  bool has_attachment_hash() const;
  void clear_attachment_hash() ;
  ::int64_t attachment_hash() const;
  void set_attachment_hash(::int64_t value);

  private:
  ::int64_t _internal_attachment_hash() const;
  void _internal_set_attachment_hash(::int64_t value);

  public:
  // optional .nearby.sharing.service.proto.FileMetadata.Type type = 2 [default = UNKNOWN];
  bool has_type() const;
  void clear_type() ;
  ::nearby::sharing::service::proto::FileMetadata_Type type() const;
  void set_type(::nearby::sharing::service::proto::FileMetadata_Type value);

  private:
  ::nearby::sharing::service::proto::FileMetadata_Type _internal_type() const;
  void _internal_set_type(::nearby::sharing::service::proto::FileMetadata_Type value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.FileMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_folder_;
    ::int64_t payload_id_;
    ::int64_t size_;
    ::int64_t id_;
    ::int64_t attachment_hash_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class TextMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.TextMetadata) */ {
 public:
  inline TextMetadata() : TextMetadata(nullptr) {}
  ~TextMetadata() override;
  explicit PROTOBUF_CONSTEXPR TextMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextMetadata(const TextMetadata& from);
  TextMetadata(TextMetadata&& from) noexcept
    : TextMetadata() {
    *this = ::std::move(from);
  }

  inline TextMetadata& operator=(const TextMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextMetadata& operator=(TextMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextMetadata* internal_default_instance() {
    return reinterpret_cast<const TextMetadata*>(
               &_TextMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TextMetadata& a, TextMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TextMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextMetadata& from);
  void MergeFrom(const TextMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.TextMetadata";
  }
  protected:
  explicit TextMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = TextMetadata_Type;
  static constexpr Type UNKNOWN = TextMetadata_Type_UNKNOWN;
  static constexpr Type TEXT = TextMetadata_Type_TEXT;
  static constexpr Type URL = TextMetadata_Type_URL;
  static constexpr Type ADDRESS = TextMetadata_Type_ADDRESS;
  static constexpr Type PHONE_NUMBER = TextMetadata_Type_PHONE_NUMBER;
  static inline bool Type_IsValid(int value) {
    return TextMetadata_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TextMetadata_Type_Type_MIN;
  static constexpr Type Type_MAX = TextMetadata_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TextMetadata_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TextMetadata_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TextMetadata_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextTitleFieldNumber = 2,
    kPayloadIdFieldNumber = 4,
    kSizeFieldNumber = 5,
    kIdFieldNumber = 6,
    kTypeFieldNumber = 3,
  };
  // optional string text_title = 2;
  bool has_text_title() const;
  void clear_text_title() ;
  const std::string& text_title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_title(Arg_&& arg, Args_... args);
  std::string* mutable_text_title();
  PROTOBUF_NODISCARD std::string* release_text_title();
  void set_allocated_text_title(std::string* ptr);

  private:
  const std::string& _internal_text_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_title(
      const std::string& value);
  std::string* _internal_mutable_text_title();

  public:
  // optional int64 payload_id = 4;
  bool has_payload_id() const;
  void clear_payload_id() ;
  ::int64_t payload_id() const;
  void set_payload_id(::int64_t value);

  private:
  ::int64_t _internal_payload_id() const;
  void _internal_set_payload_id(::int64_t value);

  public:
  // optional int64 size = 5;
  bool has_size() const;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // optional int64 id = 6;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional .nearby.sharing.service.proto.TextMetadata.Type type = 3 [default = UNKNOWN];
  bool has_type() const;
  void clear_type() ;
  ::nearby::sharing::service::proto::TextMetadata_Type type() const;
  void set_type(::nearby::sharing::service::proto::TextMetadata_Type value);

  private:
  ::nearby::sharing::service::proto::TextMetadata_Type _internal_type() const;
  void _internal_set_type(::nearby::sharing::service::proto::TextMetadata_Type value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.TextMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_title_;
    ::int64_t payload_id_;
    ::int64_t size_;
    ::int64_t id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class WifiCredentialsMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.WifiCredentialsMetadata) */ {
 public:
  inline WifiCredentialsMetadata() : WifiCredentialsMetadata(nullptr) {}
  ~WifiCredentialsMetadata() override;
  explicit PROTOBUF_CONSTEXPR WifiCredentialsMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiCredentialsMetadata(const WifiCredentialsMetadata& from);
  WifiCredentialsMetadata(WifiCredentialsMetadata&& from) noexcept
    : WifiCredentialsMetadata() {
    *this = ::std::move(from);
  }

  inline WifiCredentialsMetadata& operator=(const WifiCredentialsMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiCredentialsMetadata& operator=(WifiCredentialsMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiCredentialsMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiCredentialsMetadata* internal_default_instance() {
    return reinterpret_cast<const WifiCredentialsMetadata*>(
               &_WifiCredentialsMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WifiCredentialsMetadata& a, WifiCredentialsMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiCredentialsMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiCredentialsMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiCredentialsMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiCredentialsMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiCredentialsMetadata& from);
  void MergeFrom(const WifiCredentialsMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiCredentialsMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.WifiCredentialsMetadata";
  }
  protected:
  explicit WifiCredentialsMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using SecurityType = WifiCredentialsMetadata_SecurityType;
  static constexpr SecurityType UNKNOWN_SECURITY_TYPE = WifiCredentialsMetadata_SecurityType_UNKNOWN_SECURITY_TYPE;
  static constexpr SecurityType OPEN = WifiCredentialsMetadata_SecurityType_OPEN;
  static constexpr SecurityType WPA_PSK = WifiCredentialsMetadata_SecurityType_WPA_PSK;
  static constexpr SecurityType WEP = WifiCredentialsMetadata_SecurityType_WEP;
  static constexpr SecurityType SAE = WifiCredentialsMetadata_SecurityType_SAE;
  static inline bool SecurityType_IsValid(int value) {
    return WifiCredentialsMetadata_SecurityType_IsValid(value);
  }
  static constexpr SecurityType SecurityType_MIN = WifiCredentialsMetadata_SecurityType_SecurityType_MIN;
  static constexpr SecurityType SecurityType_MAX = WifiCredentialsMetadata_SecurityType_SecurityType_MAX;
  static constexpr int SecurityType_ARRAYSIZE = WifiCredentialsMetadata_SecurityType_SecurityType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& SecurityType_Name(T value) {
    return WifiCredentialsMetadata_SecurityType_Name(value);
  }
  static inline bool SecurityType_Parse(absl::string_view name, SecurityType* value) {
    return WifiCredentialsMetadata_SecurityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 2,
    kPayloadIdFieldNumber = 4,
    kIdFieldNumber = 5,
    kSecurityTypeFieldNumber = 3,
  };
  // optional string ssid = 2;
  bool has_ssid() const;
  void clear_ssid() ;
  const std::string& ssid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ssid(Arg_&& arg, Args_... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ptr);

  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(
      const std::string& value);
  std::string* _internal_mutable_ssid();

  public:
  // optional int64 payload_id = 4;
  bool has_payload_id() const;
  void clear_payload_id() ;
  ::int64_t payload_id() const;
  void set_payload_id(::int64_t value);

  private:
  ::int64_t _internal_payload_id() const;
  void _internal_set_payload_id(::int64_t value);

  public:
  // optional int64 id = 5;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional .nearby.sharing.service.proto.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
  bool has_security_type() const;
  void clear_security_type() ;
  ::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType security_type() const;
  void set_security_type(::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType value);

  private:
  ::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType _internal_security_type() const;
  void _internal_set_security_type(::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.WifiCredentialsMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
    ::int64_t payload_id_;
    ::int64_t id_;
    int security_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class AppMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.AppMetadata) */ {
 public:
  inline AppMetadata() : AppMetadata(nullptr) {}
  ~AppMetadata() override;
  explicit PROTOBUF_CONSTEXPR AppMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMetadata(const AppMetadata& from);
  AppMetadata(AppMetadata&& from) noexcept
    : AppMetadata() {
    *this = ::std::move(from);
  }

  inline AppMetadata& operator=(const AppMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMetadata& operator=(AppMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AppMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMetadata* internal_default_instance() {
    return reinterpret_cast<const AppMetadata*>(
               &_AppMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AppMetadata& a, AppMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AppMetadata& from);
  void MergeFrom(const AppMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.AppMetadata";
  }
  protected:
  explicit AppMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadIdFieldNumber = 3,
    kFileNameFieldNumber = 5,
    kFileSizeFieldNumber = 6,
    kAppNameFieldNumber = 1,
    kPackageNameFieldNumber = 7,
    kSizeFieldNumber = 2,
    kIdFieldNumber = 4,
  };
  // repeated int64 payload_id = 3 [packed = true];
  int payload_id_size() const;
  private:
  int _internal_payload_id_size() const;

  public:
  void clear_payload_id() ;
  ::int64_t payload_id(int index) const;
  void set_payload_id(int index, ::int64_t value);
  void add_payload_id(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& payload_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* mutable_payload_id();

  private:
  ::int64_t _internal_payload_id(int index) const;
  void _internal_add_payload_id(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& _internal_payload_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* _internal_mutable_payload_id();

  public:
  // repeated string file_name = 5;
  int file_name_size() const;
  private:
  int _internal_file_name_size() const;

  public:
  void clear_file_name() ;
  const std::string& file_name(int index) const;
  std::string* mutable_file_name(int index);
  void set_file_name(int index, const std::string& value);
  void set_file_name(int index, std::string&& value);
  void set_file_name(int index, const char* value);
  void set_file_name(int index, const char* value, std::size_t size);
  void set_file_name(int index, absl::string_view value);
  std::string* add_file_name();
  void add_file_name(const std::string& value);
  void add_file_name(std::string&& value);
  void add_file_name(const char* value);
  void add_file_name(const char* value, std::size_t size);
  void add_file_name(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& file_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_file_name();

  private:
  const std::string& _internal_file_name(int index) const;
  std::string* _internal_add_file_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_file_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_file_name();

  public:
  // repeated int64 file_size = 6 [packed = true];
  int file_size_size() const;
  private:
  int _internal_file_size_size() const;

  public:
  void clear_file_size() ;
  ::int64_t file_size(int index) const;
  void set_file_size(int index, ::int64_t value);
  void add_file_size(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& file_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* mutable_file_size();

  private:
  ::int64_t _internal_file_size(int index) const;
  void _internal_add_file_size(::int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& _internal_file_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* _internal_mutable_file_size();

  public:
  // optional string app_name = 1;
  bool has_app_name() const;
  void clear_app_name() ;
  const std::string& app_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_name(Arg_&& arg, Args_... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* ptr);

  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(
      const std::string& value);
  std::string* _internal_mutable_app_name();

  public:
  // optional string package_name = 7;
  bool has_package_name() const;
  void clear_package_name() ;
  const std::string& package_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_package_name(Arg_&& arg, Args_... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* ptr);

  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(
      const std::string& value);
  std::string* _internal_mutable_package_name();

  public:
  // optional int64 size = 2;
  bool has_size() const;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // optional int64 id = 4;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.AppMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t> payload_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _payload_id_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> file_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t> file_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _file_size_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::int64_t size_;
    ::int64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Version = Frame_Version;
  static constexpr Version UNKNOWN_VERSION = Frame_Version_UNKNOWN_VERSION;
  static constexpr Version V1 = Frame_Version_V1;
  static inline bool Version_IsValid(int value) {
    return Frame_Version_IsValid(value);
  }
  static constexpr Version Version_MIN = Frame_Version_Version_MIN;
  static constexpr Version Version_MAX = Frame_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE = Frame_Version_Version_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Version_Name(T value) {
    return Frame_Version_Name(value);
  }
  static inline bool Version_Parse(absl::string_view name, Version* value) {
    return Frame_Version_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kV1FieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // optional .nearby.sharing.service.proto.V1Frame v1 = 2;
  bool has_v1() const;
  void clear_v1() ;
  const ::nearby::sharing::service::proto::V1Frame& v1() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::V1Frame* release_v1();
  ::nearby::sharing::service::proto::V1Frame* mutable_v1();
  void set_allocated_v1(::nearby::sharing::service::proto::V1Frame* v1);
  private:
  const ::nearby::sharing::service::proto::V1Frame& _internal_v1() const;
  ::nearby::sharing::service::proto::V1Frame* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::nearby::sharing::service::proto::V1Frame* v1);
  ::nearby::sharing::service::proto::V1Frame* unsafe_arena_release_v1();
  // optional .nearby.sharing.service.proto.Frame.Version version = 1;
  bool has_version() const;
  void clear_version() ;
  ::nearby::sharing::service::proto::Frame_Version version() const;
  void set_version(::nearby::sharing::service::proto::Frame_Version value);

  private:
  ::nearby::sharing::service::proto::Frame_Version _internal_version() const;
  void _internal_set_version(::nearby::sharing::service::proto::Frame_Version value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::nearby::sharing::service::proto::V1Frame* v1_;
    int version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class V1Frame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.V1Frame) */ {
 public:
  inline V1Frame() : V1Frame(nullptr) {}
  ~V1Frame() override;
  explicit PROTOBUF_CONSTEXPR V1Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V1Frame(const V1Frame& from);
  V1Frame(V1Frame&& from) noexcept
    : V1Frame() {
    *this = ::std::move(from);
  }

  inline V1Frame& operator=(const V1Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline V1Frame& operator=(V1Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V1Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const V1Frame* internal_default_instance() {
    return reinterpret_cast<const V1Frame*>(
               &_V1Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(V1Frame& a, V1Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(V1Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V1Frame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V1Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V1Frame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V1Frame& from);
  void MergeFrom(const V1Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V1Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.V1Frame";
  }
  protected:
  explicit V1Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using FrameType = V1Frame_FrameType;
  static constexpr FrameType UNKNOWN_FRAME_TYPE = V1Frame_FrameType_UNKNOWN_FRAME_TYPE;
  static constexpr FrameType INTRODUCTION = V1Frame_FrameType_INTRODUCTION;
  static constexpr FrameType RESPONSE = V1Frame_FrameType_RESPONSE;
  static constexpr FrameType PAIRED_KEY_ENCRYPTION = V1Frame_FrameType_PAIRED_KEY_ENCRYPTION;
  static constexpr FrameType PAIRED_KEY_RESULT = V1Frame_FrameType_PAIRED_KEY_RESULT;
  static constexpr FrameType CERTIFICATE_INFO = V1Frame_FrameType_CERTIFICATE_INFO;
  static constexpr FrameType CANCEL = V1Frame_FrameType_CANCEL;
  static constexpr FrameType PROGRESS_UPDATE = V1Frame_FrameType_PROGRESS_UPDATE;
  static inline bool FrameType_IsValid(int value) {
    return V1Frame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN = V1Frame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX = V1Frame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE = V1Frame_FrameType_FrameType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& FrameType_Name(T value) {
    return V1Frame_FrameType_Name(value);
  }
  static inline bool FrameType_Parse(absl::string_view name, FrameType* value) {
    return V1Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntroductionFieldNumber = 2,
    kConnectionResponseFieldNumber = 3,
    kPairedKeyEncryptionFieldNumber = 4,
    kPairedKeyResultFieldNumber = 5,
    kCertificateInfoFieldNumber = 6,
    kProgressUpdateFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // optional .nearby.sharing.service.proto.IntroductionFrame introduction = 2;
  bool has_introduction() const;
  void clear_introduction() ;
  const ::nearby::sharing::service::proto::IntroductionFrame& introduction() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::IntroductionFrame* release_introduction();
  ::nearby::sharing::service::proto::IntroductionFrame* mutable_introduction();
  void set_allocated_introduction(::nearby::sharing::service::proto::IntroductionFrame* introduction);
  private:
  const ::nearby::sharing::service::proto::IntroductionFrame& _internal_introduction() const;
  ::nearby::sharing::service::proto::IntroductionFrame* _internal_mutable_introduction();
  public:
  void unsafe_arena_set_allocated_introduction(
      ::nearby::sharing::service::proto::IntroductionFrame* introduction);
  ::nearby::sharing::service::proto::IntroductionFrame* unsafe_arena_release_introduction();
  // optional .nearby.sharing.service.proto.ConnectionResponseFrame connection_response = 3;
  bool has_connection_response() const;
  void clear_connection_response() ;
  const ::nearby::sharing::service::proto::ConnectionResponseFrame& connection_response() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::ConnectionResponseFrame* release_connection_response();
  ::nearby::sharing::service::proto::ConnectionResponseFrame* mutable_connection_response();
  void set_allocated_connection_response(::nearby::sharing::service::proto::ConnectionResponseFrame* connection_response);
  private:
  const ::nearby::sharing::service::proto::ConnectionResponseFrame& _internal_connection_response() const;
  ::nearby::sharing::service::proto::ConnectionResponseFrame* _internal_mutable_connection_response();
  public:
  void unsafe_arena_set_allocated_connection_response(
      ::nearby::sharing::service::proto::ConnectionResponseFrame* connection_response);
  ::nearby::sharing::service::proto::ConnectionResponseFrame* unsafe_arena_release_connection_response();
  // optional .nearby.sharing.service.proto.PairedKeyEncryptionFrame paired_key_encryption = 4;
  bool has_paired_key_encryption() const;
  void clear_paired_key_encryption() ;
  const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame& paired_key_encryption() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* release_paired_key_encryption();
  ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* mutable_paired_key_encryption();
  void set_allocated_paired_key_encryption(::nearby::sharing::service::proto::PairedKeyEncryptionFrame* paired_key_encryption);
  private:
  const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame& _internal_paired_key_encryption() const;
  ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* _internal_mutable_paired_key_encryption();
  public:
  void unsafe_arena_set_allocated_paired_key_encryption(
      ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* paired_key_encryption);
  ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* unsafe_arena_release_paired_key_encryption();
  // optional .nearby.sharing.service.proto.PairedKeyResultFrame paired_key_result = 5;
  bool has_paired_key_result() const;
  void clear_paired_key_result() ;
  const ::nearby::sharing::service::proto::PairedKeyResultFrame& paired_key_result() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::PairedKeyResultFrame* release_paired_key_result();
  ::nearby::sharing::service::proto::PairedKeyResultFrame* mutable_paired_key_result();
  void set_allocated_paired_key_result(::nearby::sharing::service::proto::PairedKeyResultFrame* paired_key_result);
  private:
  const ::nearby::sharing::service::proto::PairedKeyResultFrame& _internal_paired_key_result() const;
  ::nearby::sharing::service::proto::PairedKeyResultFrame* _internal_mutable_paired_key_result();
  public:
  void unsafe_arena_set_allocated_paired_key_result(
      ::nearby::sharing::service::proto::PairedKeyResultFrame* paired_key_result);
  ::nearby::sharing::service::proto::PairedKeyResultFrame* unsafe_arena_release_paired_key_result();
  // optional .nearby.sharing.service.proto.CertificateInfoFrame certificate_info = 6;
  bool has_certificate_info() const;
  void clear_certificate_info() ;
  const ::nearby::sharing::service::proto::CertificateInfoFrame& certificate_info() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::CertificateInfoFrame* release_certificate_info();
  ::nearby::sharing::service::proto::CertificateInfoFrame* mutable_certificate_info();
  void set_allocated_certificate_info(::nearby::sharing::service::proto::CertificateInfoFrame* certificate_info);
  private:
  const ::nearby::sharing::service::proto::CertificateInfoFrame& _internal_certificate_info() const;
  ::nearby::sharing::service::proto::CertificateInfoFrame* _internal_mutable_certificate_info();
  public:
  void unsafe_arena_set_allocated_certificate_info(
      ::nearby::sharing::service::proto::CertificateInfoFrame* certificate_info);
  ::nearby::sharing::service::proto::CertificateInfoFrame* unsafe_arena_release_certificate_info();
  // optional .nearby.sharing.service.proto.ProgressUpdateFrame progress_update = 7;
  bool has_progress_update() const;
  void clear_progress_update() ;
  const ::nearby::sharing::service::proto::ProgressUpdateFrame& progress_update() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::ProgressUpdateFrame* release_progress_update();
  ::nearby::sharing::service::proto::ProgressUpdateFrame* mutable_progress_update();
  void set_allocated_progress_update(::nearby::sharing::service::proto::ProgressUpdateFrame* progress_update);
  private:
  const ::nearby::sharing::service::proto::ProgressUpdateFrame& _internal_progress_update() const;
  ::nearby::sharing::service::proto::ProgressUpdateFrame* _internal_mutable_progress_update();
  public:
  void unsafe_arena_set_allocated_progress_update(
      ::nearby::sharing::service::proto::ProgressUpdateFrame* progress_update);
  ::nearby::sharing::service::proto::ProgressUpdateFrame* unsafe_arena_release_progress_update();
  // optional .nearby.sharing.service.proto.V1Frame.FrameType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::nearby::sharing::service::proto::V1Frame_FrameType type() const;
  void set_type(::nearby::sharing::service::proto::V1Frame_FrameType value);

  private:
  ::nearby::sharing::service::proto::V1Frame_FrameType _internal_type() const;
  void _internal_set_type(::nearby::sharing::service::proto::V1Frame_FrameType value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.V1Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::nearby::sharing::service::proto::IntroductionFrame* introduction_;
    ::nearby::sharing::service::proto::ConnectionResponseFrame* connection_response_;
    ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* paired_key_encryption_;
    ::nearby::sharing::service::proto::PairedKeyResultFrame* paired_key_result_;
    ::nearby::sharing::service::proto::CertificateInfoFrame* certificate_info_;
    ::nearby::sharing::service::proto::ProgressUpdateFrame* progress_update_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class IntroductionFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.IntroductionFrame) */ {
 public:
  inline IntroductionFrame() : IntroductionFrame(nullptr) {}
  ~IntroductionFrame() override;
  explicit PROTOBUF_CONSTEXPR IntroductionFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntroductionFrame(const IntroductionFrame& from);
  IntroductionFrame(IntroductionFrame&& from) noexcept
    : IntroductionFrame() {
    *this = ::std::move(from);
  }

  inline IntroductionFrame& operator=(const IntroductionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntroductionFrame& operator=(IntroductionFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IntroductionFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntroductionFrame* internal_default_instance() {
    return reinterpret_cast<const IntroductionFrame*>(
               &_IntroductionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IntroductionFrame& a, IntroductionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(IntroductionFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntroductionFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntroductionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntroductionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IntroductionFrame& from);
  void MergeFrom(const IntroductionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntroductionFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.IntroductionFrame";
  }
  protected:
  explicit IntroductionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileMetadataFieldNumber = 1,
    kTextMetadataFieldNumber = 2,
    kWifiCredentialsMetadataFieldNumber = 4,
    kAppMetadataFieldNumber = 5,
    kRequiredPackageFieldNumber = 3,
    kStartTransferFieldNumber = 6,
  };
  // repeated .nearby.sharing.service.proto.FileMetadata file_metadata = 1;
  int file_metadata_size() const;
  private:
  int _internal_file_metadata_size() const;

  public:
  void clear_file_metadata() ;
  ::nearby::sharing::service::proto::FileMetadata* mutable_file_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::FileMetadata >*
      mutable_file_metadata();
  private:
  const ::nearby::sharing::service::proto::FileMetadata& _internal_file_metadata(int index) const;
  ::nearby::sharing::service::proto::FileMetadata* _internal_add_file_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::FileMetadata>& _internal_file_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::FileMetadata>* _internal_mutable_file_metadata();
  public:
  const ::nearby::sharing::service::proto::FileMetadata& file_metadata(int index) const;
  ::nearby::sharing::service::proto::FileMetadata* add_file_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::FileMetadata >&
      file_metadata() const;
  // repeated .nearby.sharing.service.proto.TextMetadata text_metadata = 2;
  int text_metadata_size() const;
  private:
  int _internal_text_metadata_size() const;

  public:
  void clear_text_metadata() ;
  ::nearby::sharing::service::proto::TextMetadata* mutable_text_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::TextMetadata >*
      mutable_text_metadata();
  private:
  const ::nearby::sharing::service::proto::TextMetadata& _internal_text_metadata(int index) const;
  ::nearby::sharing::service::proto::TextMetadata* _internal_add_text_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::TextMetadata>& _internal_text_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::TextMetadata>* _internal_mutable_text_metadata();
  public:
  const ::nearby::sharing::service::proto::TextMetadata& text_metadata(int index) const;
  ::nearby::sharing::service::proto::TextMetadata* add_text_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::TextMetadata >&
      text_metadata() const;
  // repeated .nearby.sharing.service.proto.WifiCredentialsMetadata wifi_credentials_metadata = 4;
  int wifi_credentials_metadata_size() const;
  private:
  int _internal_wifi_credentials_metadata_size() const;

  public:
  void clear_wifi_credentials_metadata() ;
  ::nearby::sharing::service::proto::WifiCredentialsMetadata* mutable_wifi_credentials_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::WifiCredentialsMetadata >*
      mutable_wifi_credentials_metadata();
  private:
  const ::nearby::sharing::service::proto::WifiCredentialsMetadata& _internal_wifi_credentials_metadata(int index) const;
  ::nearby::sharing::service::proto::WifiCredentialsMetadata* _internal_add_wifi_credentials_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::WifiCredentialsMetadata>& _internal_wifi_credentials_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::WifiCredentialsMetadata>* _internal_mutable_wifi_credentials_metadata();
  public:
  const ::nearby::sharing::service::proto::WifiCredentialsMetadata& wifi_credentials_metadata(int index) const;
  ::nearby::sharing::service::proto::WifiCredentialsMetadata* add_wifi_credentials_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::WifiCredentialsMetadata >&
      wifi_credentials_metadata() const;
  // repeated .nearby.sharing.service.proto.AppMetadata app_metadata = 5;
  int app_metadata_size() const;
  private:
  int _internal_app_metadata_size() const;

  public:
  void clear_app_metadata() ;
  ::nearby::sharing::service::proto::AppMetadata* mutable_app_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::AppMetadata >*
      mutable_app_metadata();
  private:
  const ::nearby::sharing::service::proto::AppMetadata& _internal_app_metadata(int index) const;
  ::nearby::sharing::service::proto::AppMetadata* _internal_add_app_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::AppMetadata>& _internal_app_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::AppMetadata>* _internal_mutable_app_metadata();
  public:
  const ::nearby::sharing::service::proto::AppMetadata& app_metadata(int index) const;
  ::nearby::sharing::service::proto::AppMetadata* add_app_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::AppMetadata >&
      app_metadata() const;
  // optional string required_package = 3;
  bool has_required_package() const;
  void clear_required_package() ;
  const std::string& required_package() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_required_package(Arg_&& arg, Args_... args);
  std::string* mutable_required_package();
  PROTOBUF_NODISCARD std::string* release_required_package();
  void set_allocated_required_package(std::string* ptr);

  private:
  const std::string& _internal_required_package() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_package(
      const std::string& value);
  std::string* _internal_mutable_required_package();

  public:
  // optional bool start_transfer = 6;
  bool has_start_transfer() const;
  void clear_start_transfer() ;
  bool start_transfer() const;
  void set_start_transfer(bool value);

  private:
  bool _internal_start_transfer() const;
  void _internal_set_start_transfer(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.IntroductionFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::FileMetadata > file_metadata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::TextMetadata > text_metadata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::WifiCredentialsMetadata > wifi_credentials_metadata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::AppMetadata > app_metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_package_;
    bool start_transfer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class ProgressUpdateFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.ProgressUpdateFrame) */ {
 public:
  inline ProgressUpdateFrame() : ProgressUpdateFrame(nullptr) {}
  ~ProgressUpdateFrame() override;
  explicit PROTOBUF_CONSTEXPR ProgressUpdateFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProgressUpdateFrame(const ProgressUpdateFrame& from);
  ProgressUpdateFrame(ProgressUpdateFrame&& from) noexcept
    : ProgressUpdateFrame() {
    *this = ::std::move(from);
  }

  inline ProgressUpdateFrame& operator=(const ProgressUpdateFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProgressUpdateFrame& operator=(ProgressUpdateFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProgressUpdateFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProgressUpdateFrame* internal_default_instance() {
    return reinterpret_cast<const ProgressUpdateFrame*>(
               &_ProgressUpdateFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProgressUpdateFrame& a, ProgressUpdateFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ProgressUpdateFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProgressUpdateFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProgressUpdateFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProgressUpdateFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProgressUpdateFrame& from);
  void MergeFrom(const ProgressUpdateFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProgressUpdateFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.ProgressUpdateFrame";
  }
  protected:
  explicit ProgressUpdateFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProgressFieldNumber = 1,
    kStartTransferFieldNumber = 2,
  };
  // optional float progress = 1;
  bool has_progress() const;
  void clear_progress() ;
  float progress() const;
  void set_progress(float value);

  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);

  public:
  // optional bool start_transfer = 2;
  bool has_start_transfer() const;
  void clear_start_transfer() ;
  bool start_transfer() const;
  void set_start_transfer(bool value);

  private:
  bool _internal_start_transfer() const;
  void _internal_set_start_transfer(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.ProgressUpdateFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float progress_;
    bool start_transfer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse, 
    ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse, 
    ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse& other);
  static const ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse*>(&_ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class ConnectionResponseFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.ConnectionResponseFrame) */ {
 public:
  inline ConnectionResponseFrame() : ConnectionResponseFrame(nullptr) {}
  ~ConnectionResponseFrame() override;
  explicit PROTOBUF_CONSTEXPR ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionResponseFrame(const ConnectionResponseFrame& from);
  ConnectionResponseFrame(ConnectionResponseFrame&& from) noexcept
    : ConnectionResponseFrame() {
    *this = ::std::move(from);
  }

  inline ConnectionResponseFrame& operator=(const ConnectionResponseFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionResponseFrame& operator=(ConnectionResponseFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConnectionResponseFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionResponseFrame* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponseFrame*>(
               &_ConnectionResponseFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConnectionResponseFrame& a, ConnectionResponseFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionResponseFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionResponseFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionResponseFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionResponseFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConnectionResponseFrame& from);
  void MergeFrom(const ConnectionResponseFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionResponseFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.ConnectionResponseFrame";
  }
  protected:
  explicit ConnectionResponseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  using Status = ConnectionResponseFrame_Status;
  static constexpr Status UNKNOWN = ConnectionResponseFrame_Status_UNKNOWN;
  static constexpr Status ACCEPT = ConnectionResponseFrame_Status_ACCEPT;
  static constexpr Status REJECT = ConnectionResponseFrame_Status_REJECT;
  static constexpr Status NOT_ENOUGH_SPACE = ConnectionResponseFrame_Status_NOT_ENOUGH_SPACE;
  static constexpr Status UNSUPPORTED_ATTACHMENT_TYPE = ConnectionResponseFrame_Status_UNSUPPORTED_ATTACHMENT_TYPE;
  static constexpr Status TIMED_OUT = ConnectionResponseFrame_Status_TIMED_OUT;
  static inline bool Status_IsValid(int value) {
    return ConnectionResponseFrame_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = ConnectionResponseFrame_Status_Status_MIN;
  static constexpr Status Status_MAX = ConnectionResponseFrame_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = ConnectionResponseFrame_Status_Status_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return ConnectionResponseFrame_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return ConnectionResponseFrame_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentDetailsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // map<int64, .nearby.sharing.service.proto.AttachmentDetails> attachment_details = 2;
  int attachment_details_size() const;
  private:
  int _internal_attachment_details_size() const;

  public:
  void clear_attachment_details() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >&
      _internal_attachment_details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >*
      _internal_mutable_attachment_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >&
      attachment_details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >*
      mutable_attachment_details();
  // optional .nearby.sharing.service.proto.ConnectionResponseFrame.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  ::nearby::sharing::service::proto::ConnectionResponseFrame_Status status() const;
  void set_status(::nearby::sharing::service::proto::ConnectionResponseFrame_Status value);

  private:
  ::nearby::sharing::service::proto::ConnectionResponseFrame_Status _internal_status() const;
  void _internal_set_status(::nearby::sharing::service::proto::ConnectionResponseFrame_Status value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.ConnectionResponseFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        ConnectionResponseFrame_AttachmentDetailsEntry_DoNotUse,
        ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attachment_details_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class AttachmentDetails final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.AttachmentDetails) */ {
 public:
  inline AttachmentDetails() : AttachmentDetails(nullptr) {}
  ~AttachmentDetails() override;
  explicit PROTOBUF_CONSTEXPR AttachmentDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttachmentDetails(const AttachmentDetails& from);
  AttachmentDetails(AttachmentDetails&& from) noexcept
    : AttachmentDetails() {
    *this = ::std::move(from);
  }

  inline AttachmentDetails& operator=(const AttachmentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttachmentDetails& operator=(AttachmentDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AttachmentDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttachmentDetails* internal_default_instance() {
    return reinterpret_cast<const AttachmentDetails*>(
               &_AttachmentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AttachmentDetails& a, AttachmentDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(AttachmentDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttachmentDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttachmentDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttachmentDetails>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AttachmentDetails& from);
  void MergeFrom(const AttachmentDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachmentDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.AttachmentDetails";
  }
  protected:
  explicit AttachmentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = AttachmentDetails_Type;
  static constexpr Type UNKNOWN = AttachmentDetails_Type_UNKNOWN;
  static constexpr Type FILE = AttachmentDetails_Type_FILE;
  static constexpr Type TEXT = AttachmentDetails_Type_TEXT;
  static constexpr Type WIFI_CREDENTIALS = AttachmentDetails_Type_WIFI_CREDENTIALS;
  static constexpr Type APP = AttachmentDetails_Type_APP;
  static inline bool Type_IsValid(int value) {
    return AttachmentDetails_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = AttachmentDetails_Type_Type_MIN;
  static constexpr Type Type_MAX = AttachmentDetails_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = AttachmentDetails_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return AttachmentDetails_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return AttachmentDetails_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFileAttachmentDetailsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .nearby.sharing.service.proto.FileAttachmentDetails file_attachment_details = 2;
  bool has_file_attachment_details() const;
  void clear_file_attachment_details() ;
  const ::nearby::sharing::service::proto::FileAttachmentDetails& file_attachment_details() const;
  PROTOBUF_NODISCARD ::nearby::sharing::service::proto::FileAttachmentDetails* release_file_attachment_details();
  ::nearby::sharing::service::proto::FileAttachmentDetails* mutable_file_attachment_details();
  void set_allocated_file_attachment_details(::nearby::sharing::service::proto::FileAttachmentDetails* file_attachment_details);
  private:
  const ::nearby::sharing::service::proto::FileAttachmentDetails& _internal_file_attachment_details() const;
  ::nearby::sharing::service::proto::FileAttachmentDetails* _internal_mutable_file_attachment_details();
  public:
  void unsafe_arena_set_allocated_file_attachment_details(
      ::nearby::sharing::service::proto::FileAttachmentDetails* file_attachment_details);
  ::nearby::sharing::service::proto::FileAttachmentDetails* unsafe_arena_release_file_attachment_details();
  // optional .nearby.sharing.service.proto.AttachmentDetails.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::nearby::sharing::service::proto::AttachmentDetails_Type type() const;
  void set_type(::nearby::sharing::service::proto::AttachmentDetails_Type value);

  private:
  ::nearby::sharing::service::proto::AttachmentDetails_Type _internal_type() const;
  void _internal_set_type(::nearby::sharing::service::proto::AttachmentDetails_Type value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.AttachmentDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::nearby::sharing::service::proto::FileAttachmentDetails* file_attachment_details_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse, 
    ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse, 
    ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse& other);
  static const FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse*>(&_FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};
// -------------------------------------------------------------------

class FileAttachmentDetails final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.FileAttachmentDetails) */ {
 public:
  inline FileAttachmentDetails() : FileAttachmentDetails(nullptr) {}
  ~FileAttachmentDetails() override;
  explicit PROTOBUF_CONSTEXPR FileAttachmentDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileAttachmentDetails(const FileAttachmentDetails& from);
  FileAttachmentDetails(FileAttachmentDetails&& from) noexcept
    : FileAttachmentDetails() {
    *this = ::std::move(from);
  }

  inline FileAttachmentDetails& operator=(const FileAttachmentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileAttachmentDetails& operator=(FileAttachmentDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FileAttachmentDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileAttachmentDetails* internal_default_instance() {
    return reinterpret_cast<const FileAttachmentDetails*>(
               &_FileAttachmentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FileAttachmentDetails& a, FileAttachmentDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(FileAttachmentDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileAttachmentDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileAttachmentDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileAttachmentDetails>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FileAttachmentDetails& from);
  void MergeFrom(const FileAttachmentDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileAttachmentDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.FileAttachmentDetails";
  }
  protected:
  explicit FileAttachmentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentHashPayloadsFieldNumber = 2,
    kReceiverExistingFileSizeFieldNumber = 1,
  };
  // map<int64, .nearby.sharing.service.proto.PayloadsDetails> attachment_hash_payloads = 2;
  int attachment_hash_payloads_size() const;
  private:
  int _internal_attachment_hash_payloads_size() const;

  public:
  void clear_attachment_hash_payloads() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >&
      _internal_attachment_hash_payloads() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >*
      _internal_mutable_attachment_hash_payloads();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >&
      attachment_hash_payloads() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >*
      mutable_attachment_hash_payloads();
  // optional int64 receiver_existing_file_size = 1;
  bool has_receiver_existing_file_size() const;
  void clear_receiver_existing_file_size() ;
  ::int64_t receiver_existing_file_size() const;
  void set_receiver_existing_file_size(::int64_t value);

  private:
  ::int64_t _internal_receiver_existing_file_size() const;
  void _internal_set_receiver_existing_file_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.FileAttachmentDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        FileAttachmentDetails_AttachmentHashPayloadsEntry_DoNotUse,
        ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attachment_hash_payloads_;
    ::int64_t receiver_existing_file_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class PayloadsDetails final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.PayloadsDetails) */ {
 public:
  inline PayloadsDetails() : PayloadsDetails(nullptr) {}
  ~PayloadsDetails() override;
  explicit PROTOBUF_CONSTEXPR PayloadsDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadsDetails(const PayloadsDetails& from);
  PayloadsDetails(PayloadsDetails&& from) noexcept
    : PayloadsDetails() {
    *this = ::std::move(from);
  }

  inline PayloadsDetails& operator=(const PayloadsDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadsDetails& operator=(PayloadsDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadsDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadsDetails* internal_default_instance() {
    return reinterpret_cast<const PayloadsDetails*>(
               &_PayloadsDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PayloadsDetails& a, PayloadsDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadsDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadsDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadsDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadsDetails>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadsDetails& from);
  void MergeFrom(const PayloadsDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadsDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.PayloadsDetails";
  }
  protected:
  explicit PayloadsDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadDetailsFieldNumber = 1,
  };
  // repeated .nearby.sharing.service.proto.PayloadDetails payload_details = 1;
  int payload_details_size() const;
  private:
  int _internal_payload_details_size() const;

  public:
  void clear_payload_details() ;
  ::nearby::sharing::service::proto::PayloadDetails* mutable_payload_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PayloadDetails >*
      mutable_payload_details();
  private:
  const ::nearby::sharing::service::proto::PayloadDetails& _internal_payload_details(int index) const;
  ::nearby::sharing::service::proto::PayloadDetails* _internal_add_payload_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PayloadDetails>& _internal_payload_details() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PayloadDetails>* _internal_mutable_payload_details();
  public:
  const ::nearby::sharing::service::proto::PayloadDetails& payload_details(int index) const;
  ::nearby::sharing::service::proto::PayloadDetails* add_payload_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PayloadDetails >&
      payload_details() const;
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.PayloadsDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PayloadDetails > payload_details_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class PayloadDetails final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.PayloadDetails) */ {
 public:
  inline PayloadDetails() : PayloadDetails(nullptr) {}
  ~PayloadDetails() override;
  explicit PROTOBUF_CONSTEXPR PayloadDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PayloadDetails(const PayloadDetails& from);
  PayloadDetails(PayloadDetails&& from) noexcept
    : PayloadDetails() {
    *this = ::std::move(from);
  }

  inline PayloadDetails& operator=(const PayloadDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadDetails& operator=(PayloadDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PayloadDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PayloadDetails* internal_default_instance() {
    return reinterpret_cast<const PayloadDetails*>(
               &_PayloadDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PayloadDetails& a, PayloadDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PayloadDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PayloadDetails>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PayloadDetails& from);
  void MergeFrom(const PayloadDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PayloadDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.PayloadDetails";
  }
  protected:
  explicit PayloadDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCreationTimestampMillisFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // optional int64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // optional int64 creation_timestamp_millis = 2;
  bool has_creation_timestamp_millis() const;
  void clear_creation_timestamp_millis() ;
  ::int64_t creation_timestamp_millis() const;
  void set_creation_timestamp_millis(::int64_t value);

  private:
  ::int64_t _internal_creation_timestamp_millis() const;
  void _internal_set_creation_timestamp_millis(::int64_t value);

  public:
  // optional int64 size = 3;
  bool has_size() const;
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.PayloadDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t id_;
    ::int64_t creation_timestamp_millis_;
    ::int64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class PairedKeyEncryptionFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.PairedKeyEncryptionFrame) */ {
 public:
  inline PairedKeyEncryptionFrame() : PairedKeyEncryptionFrame(nullptr) {}
  ~PairedKeyEncryptionFrame() override;
  explicit PROTOBUF_CONSTEXPR PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PairedKeyEncryptionFrame(const PairedKeyEncryptionFrame& from);
  PairedKeyEncryptionFrame(PairedKeyEncryptionFrame&& from) noexcept
    : PairedKeyEncryptionFrame() {
    *this = ::std::move(from);
  }

  inline PairedKeyEncryptionFrame& operator=(const PairedKeyEncryptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairedKeyEncryptionFrame& operator=(PairedKeyEncryptionFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PairedKeyEncryptionFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairedKeyEncryptionFrame* internal_default_instance() {
    return reinterpret_cast<const PairedKeyEncryptionFrame*>(
               &_PairedKeyEncryptionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PairedKeyEncryptionFrame& a, PairedKeyEncryptionFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairedKeyEncryptionFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairedKeyEncryptionFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PairedKeyEncryptionFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PairedKeyEncryptionFrame& from);
  void MergeFrom(const PairedKeyEncryptionFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairedKeyEncryptionFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.PairedKeyEncryptionFrame";
  }
  protected:
  explicit PairedKeyEncryptionFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedDataFieldNumber = 1,
    kSecretIdHashFieldNumber = 2,
    kOptionalSignedDataFieldNumber = 3,
    kQrCodeHandshakeDataFieldNumber = 4,
  };
  // optional bytes signed_data = 1;
  bool has_signed_data() const;
  void clear_signed_data() ;
  const std::string& signed_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signed_data(Arg_&& arg, Args_... args);
  std::string* mutable_signed_data();
  PROTOBUF_NODISCARD std::string* release_signed_data();
  void set_allocated_signed_data(std::string* ptr);

  private:
  const std::string& _internal_signed_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signed_data(
      const std::string& value);
  std::string* _internal_mutable_signed_data();

  public:
  // optional bytes secret_id_hash = 2;
  bool has_secret_id_hash() const;
  void clear_secret_id_hash() ;
  const std::string& secret_id_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret_id_hash(Arg_&& arg, Args_... args);
  std::string* mutable_secret_id_hash();
  PROTOBUF_NODISCARD std::string* release_secret_id_hash();
  void set_allocated_secret_id_hash(std::string* ptr);

  private:
  const std::string& _internal_secret_id_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id_hash(
      const std::string& value);
  std::string* _internal_mutable_secret_id_hash();

  public:
  // optional bytes optional_signed_data = 3;
  bool has_optional_signed_data() const;
  void clear_optional_signed_data() ;
  const std::string& optional_signed_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_optional_signed_data(Arg_&& arg, Args_... args);
  std::string* mutable_optional_signed_data();
  PROTOBUF_NODISCARD std::string* release_optional_signed_data();
  void set_allocated_optional_signed_data(std::string* ptr);

  private:
  const std::string& _internal_optional_signed_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_signed_data(
      const std::string& value);
  std::string* _internal_mutable_optional_signed_data();

  public:
  // optional bytes qr_code_handshake_data = 4;
  bool has_qr_code_handshake_data() const;
  void clear_qr_code_handshake_data() ;
  const std::string& qr_code_handshake_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_qr_code_handshake_data(Arg_&& arg, Args_... args);
  std::string* mutable_qr_code_handshake_data();
  PROTOBUF_NODISCARD std::string* release_qr_code_handshake_data();
  void set_allocated_qr_code_handshake_data(std::string* ptr);

  private:
  const std::string& _internal_qr_code_handshake_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qr_code_handshake_data(
      const std::string& value);
  std::string* _internal_mutable_qr_code_handshake_data();

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.PairedKeyEncryptionFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_signed_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qr_code_handshake_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class PairedKeyResultFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.PairedKeyResultFrame) */ {
 public:
  inline PairedKeyResultFrame() : PairedKeyResultFrame(nullptr) {}
  ~PairedKeyResultFrame() override;
  explicit PROTOBUF_CONSTEXPR PairedKeyResultFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PairedKeyResultFrame(const PairedKeyResultFrame& from);
  PairedKeyResultFrame(PairedKeyResultFrame&& from) noexcept
    : PairedKeyResultFrame() {
    *this = ::std::move(from);
  }

  inline PairedKeyResultFrame& operator=(const PairedKeyResultFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline PairedKeyResultFrame& operator=(PairedKeyResultFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PairedKeyResultFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const PairedKeyResultFrame* internal_default_instance() {
    return reinterpret_cast<const PairedKeyResultFrame*>(
               &_PairedKeyResultFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PairedKeyResultFrame& a, PairedKeyResultFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(PairedKeyResultFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PairedKeyResultFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PairedKeyResultFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PairedKeyResultFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PairedKeyResultFrame& from);
  void MergeFrom(const PairedKeyResultFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PairedKeyResultFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.PairedKeyResultFrame";
  }
  protected:
  explicit PairedKeyResultFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Status = PairedKeyResultFrame_Status;
  static constexpr Status UNKNOWN = PairedKeyResultFrame_Status_UNKNOWN;
  static constexpr Status SUCCESS = PairedKeyResultFrame_Status_SUCCESS;
  static constexpr Status FAIL = PairedKeyResultFrame_Status_FAIL;
  static constexpr Status UNABLE = PairedKeyResultFrame_Status_UNABLE;
  static inline bool Status_IsValid(int value) {
    return PairedKeyResultFrame_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = PairedKeyResultFrame_Status_Status_MIN;
  static constexpr Status Status_MAX = PairedKeyResultFrame_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = PairedKeyResultFrame_Status_Status_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return PairedKeyResultFrame_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return PairedKeyResultFrame_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kOsTypeFieldNumber = 2,
  };
  // optional .nearby.sharing.service.proto.PairedKeyResultFrame.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  ::nearby::sharing::service::proto::PairedKeyResultFrame_Status status() const;
  void set_status(::nearby::sharing::service::proto::PairedKeyResultFrame_Status value);

  private:
  ::nearby::sharing::service::proto::PairedKeyResultFrame_Status _internal_status() const;
  void _internal_set_status(::nearby::sharing::service::proto::PairedKeyResultFrame_Status value);

  public:
  // optional .location.nearby.proto.sharing.OSType os_type = 2;
  bool has_os_type() const;
  void clear_os_type() ;
  ::location::nearby::proto::sharing::OSType os_type() const;
  void set_os_type(::location::nearby::proto::sharing::OSType value);

  private:
  ::location::nearby::proto::sharing::OSType _internal_os_type() const;
  void _internal_set_os_type(::location::nearby::proto::sharing::OSType value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.PairedKeyResultFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int status_;
    int os_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class CertificateInfoFrame final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.CertificateInfoFrame) */ {
 public:
  inline CertificateInfoFrame() : CertificateInfoFrame(nullptr) {}
  ~CertificateInfoFrame() override;
  explicit PROTOBUF_CONSTEXPR CertificateInfoFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateInfoFrame(const CertificateInfoFrame& from);
  CertificateInfoFrame(CertificateInfoFrame&& from) noexcept
    : CertificateInfoFrame() {
    *this = ::std::move(from);
  }

  inline CertificateInfoFrame& operator=(const CertificateInfoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateInfoFrame& operator=(CertificateInfoFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CertificateInfoFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateInfoFrame* internal_default_instance() {
    return reinterpret_cast<const CertificateInfoFrame*>(
               &_CertificateInfoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CertificateInfoFrame& a, CertificateInfoFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateInfoFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateInfoFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateInfoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateInfoFrame>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CertificateInfoFrame& from);
  void MergeFrom(const CertificateInfoFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CertificateInfoFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.CertificateInfoFrame";
  }
  protected:
  explicit CertificateInfoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicCertificateFieldNumber = 1,
  };
  // repeated .nearby.sharing.service.proto.PublicCertificate public_certificate = 1;
  int public_certificate_size() const;
  private:
  int _internal_public_certificate_size() const;

  public:
  void clear_public_certificate() ;
  ::nearby::sharing::service::proto::PublicCertificate* mutable_public_certificate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PublicCertificate >*
      mutable_public_certificate();
  private:
  const ::nearby::sharing::service::proto::PublicCertificate& _internal_public_certificate(int index) const;
  ::nearby::sharing::service::proto::PublicCertificate* _internal_add_public_certificate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PublicCertificate>& _internal_public_certificate() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PublicCertificate>* _internal_mutable_public_certificate();
  public:
  const ::nearby::sharing::service::proto::PublicCertificate& public_certificate(int index) const;
  ::nearby::sharing::service::proto::PublicCertificate* add_public_certificate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PublicCertificate >&
      public_certificate() const;
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.CertificateInfoFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PublicCertificate > public_certificate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class PublicCertificate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.PublicCertificate) */ {
 public:
  inline PublicCertificate() : PublicCertificate(nullptr) {}
  ~PublicCertificate() override;
  explicit PROTOBUF_CONSTEXPR PublicCertificate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicCertificate(const PublicCertificate& from);
  PublicCertificate(PublicCertificate&& from) noexcept
    : PublicCertificate() {
    *this = ::std::move(from);
  }

  inline PublicCertificate& operator=(const PublicCertificate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicCertificate& operator=(PublicCertificate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PublicCertificate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicCertificate* internal_default_instance() {
    return reinterpret_cast<const PublicCertificate*>(
               &_PublicCertificate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PublicCertificate& a, PublicCertificate& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicCertificate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicCertificate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicCertificate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicCertificate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PublicCertificate& from);
  void MergeFrom(const PublicCertificate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicCertificate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.PublicCertificate";
  }
  protected:
  explicit PublicCertificate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretIdFieldNumber = 1,
    kAuthenticityKeyFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
    kEncryptedMetadataBytesFieldNumber = 6,
    kMetadataEncryptionKeyTagFieldNumber = 7,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
  };
  // optional bytes secret_id = 1;
  bool has_secret_id() const;
  void clear_secret_id() ;
  const std::string& secret_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret_id(Arg_&& arg, Args_... args);
  std::string* mutable_secret_id();
  PROTOBUF_NODISCARD std::string* release_secret_id();
  void set_allocated_secret_id(std::string* ptr);

  private:
  const std::string& _internal_secret_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_id(
      const std::string& value);
  std::string* _internal_mutable_secret_id();

  public:
  // optional bytes authenticity_key = 2;
  bool has_authenticity_key() const;
  void clear_authenticity_key() ;
  const std::string& authenticity_key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_authenticity_key(Arg_&& arg, Args_... args);
  std::string* mutable_authenticity_key();
  PROTOBUF_NODISCARD std::string* release_authenticity_key();
  void set_allocated_authenticity_key(std::string* ptr);

  private:
  const std::string& _internal_authenticity_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authenticity_key(
      const std::string& value);
  std::string* _internal_mutable_authenticity_key();

  public:
  // optional bytes public_key = 3;
  bool has_public_key() const;
  void clear_public_key() ;
  const std::string& public_key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* ptr);

  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(
      const std::string& value);
  std::string* _internal_mutable_public_key();

  public:
  // optional bytes encrypted_metadata_bytes = 6;
  bool has_encrypted_metadata_bytes() const;
  void clear_encrypted_metadata_bytes() ;
  const std::string& encrypted_metadata_bytes() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encrypted_metadata_bytes(Arg_&& arg, Args_... args);
  std::string* mutable_encrypted_metadata_bytes();
  PROTOBUF_NODISCARD std::string* release_encrypted_metadata_bytes();
  void set_allocated_encrypted_metadata_bytes(std::string* ptr);

  private:
  const std::string& _internal_encrypted_metadata_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_metadata_bytes(
      const std::string& value);
  std::string* _internal_mutable_encrypted_metadata_bytes();

  public:
  // optional bytes metadata_encryption_key_tag = 7;
  bool has_metadata_encryption_key_tag() const;
  void clear_metadata_encryption_key_tag() ;
  const std::string& metadata_encryption_key_tag() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metadata_encryption_key_tag(Arg_&& arg, Args_... args);
  std::string* mutable_metadata_encryption_key_tag();
  PROTOBUF_NODISCARD std::string* release_metadata_encryption_key_tag();
  void set_allocated_metadata_encryption_key_tag(std::string* ptr);

  private:
  const std::string& _internal_metadata_encryption_key_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata_encryption_key_tag(
      const std::string& value);
  std::string* _internal_mutable_metadata_encryption_key_tag();

  public:
  // optional int64 start_time = 4;
  bool has_start_time() const;
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // optional int64 end_time = 5;
  bool has_end_time() const;
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.PublicCertificate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authenticity_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_metadata_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_encryption_key_tag_;
    ::int64_t start_time_;
    ::int64_t end_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};// -------------------------------------------------------------------

class WifiCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:nearby.sharing.service.proto.WifiCredentials) */ {
 public:
  inline WifiCredentials() : WifiCredentials(nullptr) {}
  ~WifiCredentials() override;
  explicit PROTOBUF_CONSTEXPR WifiCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WifiCredentials(const WifiCredentials& from);
  WifiCredentials(WifiCredentials&& from) noexcept
    : WifiCredentials() {
    *this = ::std::move(from);
  }

  inline WifiCredentials& operator=(const WifiCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline WifiCredentials& operator=(WifiCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WifiCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const WifiCredentials* internal_default_instance() {
    return reinterpret_cast<const WifiCredentials*>(
               &_WifiCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(WifiCredentials& a, WifiCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(WifiCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WifiCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WifiCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WifiCredentials>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WifiCredentials& from);
  void MergeFrom(const WifiCredentials& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WifiCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "nearby.sharing.service.proto.WifiCredentials";
  }
  protected:
  explicit WifiCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
    kHiddenSsidFieldNumber = 2,
  };
  // optional string password = 1;
  bool has_password() const;
  void clear_password() ;
  const std::string& password() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* ptr);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // optional bool hidden_ssid = 2 [default = false];
  bool has_hidden_ssid() const;
  void clear_hidden_ssid() ;
  bool hidden_ssid() const;
  void set_hidden_ssid(bool value);

  private:
  bool _internal_hidden_ssid() const;
  void _internal_set_hidden_ssid(bool value);

  public:
  // @@protoc_insertion_point(class_scope:nearby.sharing.service.proto.WifiCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    bool hidden_ssid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sharing_2fproto_2fwire_5fformat_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FileMetadata

// optional string name = 1;
inline bool FileMetadata::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FileMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileMetadata::name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileMetadata::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.name)
}
inline std::string* FileMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.FileMetadata.name)
  return _s;
}
inline const std::string& FileMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FileMetadata::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMetadata::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* FileMetadata::release_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.FileMetadata.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FileMetadata::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.FileMetadata.name)
}

// optional .nearby.sharing.service.proto.FileMetadata.Type type = 2 [default = UNKNOWN];
inline bool FileMetadata::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FileMetadata::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::nearby::sharing::service::proto::FileMetadata_Type FileMetadata::type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.type)
  return _internal_type();
}
inline void FileMetadata::set_type(::nearby::sharing::service::proto::FileMetadata_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.type)
}
inline ::nearby::sharing::service::proto::FileMetadata_Type FileMetadata::_internal_type() const {
  return static_cast<::nearby::sharing::service::proto::FileMetadata_Type>(_impl_.type_);
}
inline void FileMetadata::_internal_set_type(::nearby::sharing::service::proto::FileMetadata_Type value) {
  assert(::nearby::sharing::service::proto::FileMetadata_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.type_ = value;
}

// optional int64 payload_id = 3;
inline bool FileMetadata::has_payload_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FileMetadata::clear_payload_id() {
  _impl_.payload_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t FileMetadata::payload_id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.payload_id)
  return _internal_payload_id();
}
inline void FileMetadata::set_payload_id(::int64_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.payload_id)
}
inline ::int64_t FileMetadata::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline void FileMetadata::_internal_set_payload_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.payload_id_ = value;
}

// optional int64 size = 4;
inline bool FileMetadata::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FileMetadata::clear_size() {
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t FileMetadata::size() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.size)
  return _internal_size();
}
inline void FileMetadata::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.size)
}
inline ::int64_t FileMetadata::_internal_size() const {
  return _impl_.size_;
}
inline void FileMetadata::_internal_set_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_ = value;
}

// optional string mime_type = 5 [default = "application/octet-stream"];
inline bool FileMetadata::has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FileMetadata::clear_mime_type() {
  _impl_.mime_type_.ClearToDefault(::nearby::sharing::service::proto::FileMetadata::Impl_::_i_give_permission_to_break_this_code_default_mime_type_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileMetadata::mime_type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.mime_type)
  if (_impl_.mime_type_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_mime_type_.get();
  }
  return _internal_mime_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileMetadata::set_mime_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mime_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.mime_type)
}
inline std::string* FileMetadata::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.FileMetadata.mime_type)
  return _s;
}
inline const std::string& FileMetadata::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void FileMetadata::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMetadata::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mime_type_.Mutable(::nearby::sharing::service::proto::FileMetadata::Impl_::_i_give_permission_to_break_this_code_default_mime_type_, GetArenaForAllocation());
}
inline std::string* FileMetadata::release_mime_type() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.FileMetadata.mime_type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  return _impl_.mime_type_.Release();
}
inline void FileMetadata::set_allocated_mime_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mime_type_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.FileMetadata.mime_type)
}

// optional int64 id = 6;
inline bool FileMetadata::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FileMetadata::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t FileMetadata::id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.id)
  return _internal_id();
}
inline void FileMetadata::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.id)
}
inline ::int64_t FileMetadata::_internal_id() const {
  return _impl_.id_;
}
inline void FileMetadata::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.id_ = value;
}

// optional string parent_folder = 7;
inline bool FileMetadata::has_parent_folder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FileMetadata::clear_parent_folder() {
  _impl_.parent_folder_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FileMetadata::parent_folder() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.parent_folder)
  return _internal_parent_folder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileMetadata::set_parent_folder(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_folder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.parent_folder)
}
inline std::string* FileMetadata::mutable_parent_folder() {
  std::string* _s = _internal_mutable_parent_folder();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.FileMetadata.parent_folder)
  return _s;
}
inline const std::string& FileMetadata::_internal_parent_folder() const {
  return _impl_.parent_folder_.Get();
}
inline void FileMetadata::_internal_set_parent_folder(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.parent_folder_.Set(value, GetArenaForAllocation());
}
inline std::string* FileMetadata::_internal_mutable_parent_folder() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.parent_folder_.Mutable( GetArenaForAllocation());
}
inline std::string* FileMetadata::release_parent_folder() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.FileMetadata.parent_folder)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.parent_folder_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_folder_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FileMetadata::set_allocated_parent_folder(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.parent_folder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_folder_.IsDefault()) {
          _impl_.parent_folder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.FileMetadata.parent_folder)
}

// optional int64 attachment_hash = 8;
inline bool FileMetadata::has_attachment_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void FileMetadata::clear_attachment_hash() {
  _impl_.attachment_hash_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t FileMetadata::attachment_hash() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileMetadata.attachment_hash)
  return _internal_attachment_hash();
}
inline void FileMetadata::set_attachment_hash(::int64_t value) {
  _internal_set_attachment_hash(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileMetadata.attachment_hash)
}
inline ::int64_t FileMetadata::_internal_attachment_hash() const {
  return _impl_.attachment_hash_;
}
inline void FileMetadata::_internal_set_attachment_hash(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.attachment_hash_ = value;
}

// -------------------------------------------------------------------

// TextMetadata

// optional string text_title = 2;
inline bool TextMetadata::has_text_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TextMetadata::clear_text_title() {
  _impl_.text_title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextMetadata::text_title() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.TextMetadata.text_title)
  return _internal_text_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TextMetadata::set_text_title(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.TextMetadata.text_title)
}
inline std::string* TextMetadata::mutable_text_title() {
  std::string* _s = _internal_mutable_text_title();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.TextMetadata.text_title)
  return _s;
}
inline const std::string& TextMetadata::_internal_text_title() const {
  return _impl_.text_title_.Get();
}
inline void TextMetadata::_internal_set_text_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.text_title_.Set(value, GetArenaForAllocation());
}
inline std::string* TextMetadata::_internal_mutable_text_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_title_.Mutable( GetArenaForAllocation());
}
inline std::string* TextMetadata::release_text_title() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.TextMetadata.text_title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_title_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TextMetadata::set_allocated_text_title(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_title_.IsDefault()) {
          _impl_.text_title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.TextMetadata.text_title)
}

// optional .nearby.sharing.service.proto.TextMetadata.Type type = 3 [default = UNKNOWN];
inline bool TextMetadata::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TextMetadata::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::nearby::sharing::service::proto::TextMetadata_Type TextMetadata::type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.TextMetadata.type)
  return _internal_type();
}
inline void TextMetadata::set_type(::nearby::sharing::service::proto::TextMetadata_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.TextMetadata.type)
}
inline ::nearby::sharing::service::proto::TextMetadata_Type TextMetadata::_internal_type() const {
  return static_cast<::nearby::sharing::service::proto::TextMetadata_Type>(_impl_.type_);
}
inline void TextMetadata::_internal_set_type(::nearby::sharing::service::proto::TextMetadata_Type value) {
  assert(::nearby::sharing::service::proto::TextMetadata_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}

// optional int64 payload_id = 4;
inline bool TextMetadata::has_payload_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TextMetadata::clear_payload_id() {
  _impl_.payload_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t TextMetadata::payload_id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.TextMetadata.payload_id)
  return _internal_payload_id();
}
inline void TextMetadata::set_payload_id(::int64_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.TextMetadata.payload_id)
}
inline ::int64_t TextMetadata::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline void TextMetadata::_internal_set_payload_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.payload_id_ = value;
}

// optional int64 size = 5;
inline bool TextMetadata::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TextMetadata::clear_size() {
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t TextMetadata::size() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.TextMetadata.size)
  return _internal_size();
}
inline void TextMetadata::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.TextMetadata.size)
}
inline ::int64_t TextMetadata::_internal_size() const {
  return _impl_.size_;
}
inline void TextMetadata::_internal_set_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}

// optional int64 id = 6;
inline bool TextMetadata::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TextMetadata::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t TextMetadata::id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.TextMetadata.id)
  return _internal_id();
}
inline void TextMetadata::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.TextMetadata.id)
}
inline ::int64_t TextMetadata::_internal_id() const {
  return _impl_.id_;
}
inline void TextMetadata::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// WifiCredentialsMetadata

// optional string ssid = 2;
inline bool WifiCredentialsMetadata::has_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WifiCredentialsMetadata::clear_ssid() {
  _impl_.ssid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WifiCredentialsMetadata::ssid() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.WifiCredentialsMetadata.ssid)
  return _internal_ssid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WifiCredentialsMetadata::set_ssid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ssid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.WifiCredentialsMetadata.ssid)
}
inline std::string* WifiCredentialsMetadata::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.WifiCredentialsMetadata.ssid)
  return _s;
}
inline const std::string& WifiCredentialsMetadata::_internal_ssid() const {
  return _impl_.ssid_.Get();
}
inline void WifiCredentialsMetadata::_internal_set_ssid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.ssid_.Set(value, GetArenaForAllocation());
}
inline std::string* WifiCredentialsMetadata::_internal_mutable_ssid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ssid_.Mutable( GetArenaForAllocation());
}
inline std::string* WifiCredentialsMetadata::release_ssid() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.WifiCredentialsMetadata.ssid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ssid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void WifiCredentialsMetadata::set_allocated_ssid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ssid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ssid_.IsDefault()) {
          _impl_.ssid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.WifiCredentialsMetadata.ssid)
}

// optional .nearby.sharing.service.proto.WifiCredentialsMetadata.SecurityType security_type = 3 [default = UNKNOWN_SECURITY_TYPE];
inline bool WifiCredentialsMetadata::has_security_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void WifiCredentialsMetadata::clear_security_type() {
  _impl_.security_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::security_type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.WifiCredentialsMetadata.security_type)
  return _internal_security_type();
}
inline void WifiCredentialsMetadata::set_security_type(::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType value) {
   _internal_set_security_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.WifiCredentialsMetadata.security_type)
}
inline ::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType WifiCredentialsMetadata::_internal_security_type() const {
  return static_cast<::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType>(_impl_.security_type_);
}
inline void WifiCredentialsMetadata::_internal_set_security_type(::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType value) {
  assert(::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.security_type_ = value;
}

// optional int64 payload_id = 4;
inline bool WifiCredentialsMetadata::has_payload_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WifiCredentialsMetadata::clear_payload_id() {
  _impl_.payload_id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t WifiCredentialsMetadata::payload_id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.WifiCredentialsMetadata.payload_id)
  return _internal_payload_id();
}
inline void WifiCredentialsMetadata::set_payload_id(::int64_t value) {
  _internal_set_payload_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.WifiCredentialsMetadata.payload_id)
}
inline ::int64_t WifiCredentialsMetadata::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline void WifiCredentialsMetadata::_internal_set_payload_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.payload_id_ = value;
}

// optional int64 id = 5;
inline bool WifiCredentialsMetadata::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void WifiCredentialsMetadata::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t WifiCredentialsMetadata::id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.WifiCredentialsMetadata.id)
  return _internal_id();
}
inline void WifiCredentialsMetadata::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.WifiCredentialsMetadata.id)
}
inline ::int64_t WifiCredentialsMetadata::_internal_id() const {
  return _impl_.id_;
}
inline void WifiCredentialsMetadata::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// AppMetadata

// optional string app_name = 1;
inline bool AppMetadata::has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AppMetadata::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppMetadata::app_name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.app_name)
  return _internal_app_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AppMetadata::set_app_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.app_name)
}
inline std::string* AppMetadata::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.AppMetadata.app_name)
  return _s;
}
inline const std::string& AppMetadata::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void AppMetadata::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppMetadata::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AppMetadata::release_app_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.AppMetadata.app_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.app_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AppMetadata::set_allocated_app_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_name_.IsDefault()) {
          _impl_.app_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.AppMetadata.app_name)
}

// optional int64 size = 2;
inline bool AppMetadata::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AppMetadata::clear_size() {
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t AppMetadata::size() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.size)
  return _internal_size();
}
inline void AppMetadata::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.size)
}
inline ::int64_t AppMetadata::_internal_size() const {
  return _impl_.size_;
}
inline void AppMetadata::_internal_set_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}

// repeated int64 payload_id = 3 [packed = true];
inline int AppMetadata::_internal_payload_id_size() const {
  return _impl_.payload_id_.size();
}
inline int AppMetadata::payload_id_size() const {
  return _internal_payload_id_size();
}
inline void AppMetadata::clear_payload_id() {
  _internal_mutable_payload_id()->Clear();
}
inline ::int64_t AppMetadata::payload_id(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.payload_id)
  return _internal_payload_id(index);
}
inline void AppMetadata::set_payload_id(int index, ::int64_t value) {
  _internal_mutable_payload_id()->Set(index, value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.payload_id)
}
inline void AppMetadata::add_payload_id(::int64_t value) {
  _internal_add_payload_id(value);
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.AppMetadata.payload_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& AppMetadata::payload_id() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.AppMetadata.payload_id)
  return _internal_payload_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* AppMetadata::mutable_payload_id() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.AppMetadata.payload_id)
  return _internal_mutable_payload_id();
}

inline ::int64_t AppMetadata::_internal_payload_id(int index) const {
  return _internal_payload_id().Get(index);
}
inline void AppMetadata::_internal_add_payload_id(::int64_t value) {
  _internal_mutable_payload_id()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& AppMetadata::_internal_payload_id() const {
  return _impl_.payload_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* AppMetadata::_internal_mutable_payload_id() {
  return &_impl_.payload_id_;
}

// optional int64 id = 4;
inline bool AppMetadata::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AppMetadata::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t AppMetadata::id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.id)
  return _internal_id();
}
inline void AppMetadata::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.id)
}
inline ::int64_t AppMetadata::_internal_id() const {
  return _impl_.id_;
}
inline void AppMetadata::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.id_ = value;
}

// repeated string file_name = 5;
inline int AppMetadata::_internal_file_name_size() const {
  return _impl_.file_name_.size();
}
inline int AppMetadata::file_name_size() const {
  return _internal_file_name_size();
}
inline void AppMetadata::clear_file_name() {
  _internal_mutable_file_name()->Clear();
}
inline std::string* AppMetadata::add_file_name() {
  std::string* _s = _internal_add_file_name();
  // @@protoc_insertion_point(field_add_mutable:nearby.sharing.service.proto.AppMetadata.file_name)
  return _s;
}
inline const std::string& AppMetadata::file_name(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.file_name)
  return _internal_file_name(index);
}
inline std::string* AppMetadata::mutable_file_name(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.AppMetadata.file_name)
  return _internal_mutable_file_name()->Mutable(index);
}
inline void AppMetadata::set_file_name(int index, const std::string& value) {
  _internal_mutable_file_name()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::set_file_name(int index, std::string&& value) {
  _internal_mutable_file_name()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::set_file_name(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_file_name()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::set_file_name(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_file_name()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::set_file_name(int index, absl::string_view value) {
  _internal_mutable_file_name()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::add_file_name(const std::string& value) {
  _internal_mutable_file_name()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::add_file_name(std::string&& value) {
  _internal_mutable_file_name()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::add_file_name(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_file_name()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::add_file_name(const char* value, std::size_t size) {
  _internal_mutable_file_name()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline void AppMetadata::add_file_name(absl::string_view value) {
  _internal_mutable_file_name()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:nearby.sharing.service.proto.AppMetadata.file_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppMetadata::file_name() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.AppMetadata.file_name)
  return _internal_file_name();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AppMetadata::mutable_file_name() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.AppMetadata.file_name)
  return _internal_mutable_file_name();
}
inline const std::string& AppMetadata::_internal_file_name(int index) const {
  return _internal_file_name().Get(index);
}
inline std::string* AppMetadata::_internal_add_file_name() {
  return _internal_mutable_file_name()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppMetadata::_internal_file_name() const {
  return _impl_.file_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppMetadata::_internal_mutable_file_name() {
  return &_impl_.file_name_;
}

// repeated int64 file_size = 6 [packed = true];
inline int AppMetadata::_internal_file_size_size() const {
  return _impl_.file_size_.size();
}
inline int AppMetadata::file_size_size() const {
  return _internal_file_size_size();
}
inline void AppMetadata::clear_file_size() {
  _internal_mutable_file_size()->Clear();
}
inline ::int64_t AppMetadata::file_size(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.file_size)
  return _internal_file_size(index);
}
inline void AppMetadata::set_file_size(int index, ::int64_t value) {
  _internal_mutable_file_size()->Set(index, value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.file_size)
}
inline void AppMetadata::add_file_size(::int64_t value) {
  _internal_add_file_size(value);
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.AppMetadata.file_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& AppMetadata::file_size() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.AppMetadata.file_size)
  return _internal_file_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* AppMetadata::mutable_file_size() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.AppMetadata.file_size)
  return _internal_mutable_file_size();
}

inline ::int64_t AppMetadata::_internal_file_size(int index) const {
  return _internal_file_size().Get(index);
}
inline void AppMetadata::_internal_add_file_size(::int64_t value) {
  _internal_mutable_file_size()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>& AppMetadata::_internal_file_size() const {
  return _impl_.file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int64_t>* AppMetadata::_internal_mutable_file_size() {
  return &_impl_.file_size_;
}

// optional string package_name = 7;
inline bool AppMetadata::has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AppMetadata::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppMetadata::package_name() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AppMetadata.package_name)
  return _internal_package_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AppMetadata::set_package_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AppMetadata.package_name)
}
inline std::string* AppMetadata::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.AppMetadata.package_name)
  return _s;
}
inline const std::string& AppMetadata::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void AppMetadata::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppMetadata::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable( GetArenaForAllocation());
}
inline std::string* AppMetadata::release_package_name() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.AppMetadata.package_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.package_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.package_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AppMetadata::set_allocated_package_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.package_name_.IsDefault()) {
          _impl_.package_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.AppMetadata.package_name)
}

// -------------------------------------------------------------------

// Frame

// optional .nearby.sharing.service.proto.Frame.Version version = 1;
inline bool Frame::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Frame::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::nearby::sharing::service::proto::Frame_Version Frame::version() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.Frame.version)
  return _internal_version();
}
inline void Frame::set_version(::nearby::sharing::service::proto::Frame_Version value) {
   _internal_set_version(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.Frame.version)
}
inline ::nearby::sharing::service::proto::Frame_Version Frame::_internal_version() const {
  return static_cast<::nearby::sharing::service::proto::Frame_Version>(_impl_.version_);
}
inline void Frame::_internal_set_version(::nearby::sharing::service::proto::Frame_Version value) {
  assert(::nearby::sharing::service::proto::Frame_Version_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}

// optional .nearby.sharing.service.proto.V1Frame v1 = 2;
inline bool Frame::has_v1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.v1_ != nullptr);
  return value;
}
inline void Frame::clear_v1() {
  if (_impl_.v1_ != nullptr) _impl_.v1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nearby::sharing::service::proto::V1Frame& Frame::_internal_v1() const {
  const ::nearby::sharing::service::proto::V1Frame* p = _impl_.v1_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::V1Frame&>(
      ::nearby::sharing::service::proto::_V1Frame_default_instance_);
}
inline const ::nearby::sharing::service::proto::V1Frame& Frame::v1() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.Frame.v1)
  return _internal_v1();
}
inline void Frame::unsafe_arena_set_allocated_v1(
    ::nearby::sharing::service::proto::V1Frame* v1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.v1_);
  }
  _impl_.v1_ = v1;
  if (v1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.Frame.v1)
}
inline ::nearby::sharing::service::proto::V1Frame* Frame::release_v1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::service::proto::V1Frame* temp = _impl_.v1_;
  _impl_.v1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::V1Frame* Frame::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.Frame.v1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::service::proto::V1Frame* temp = _impl_.v1_;
  _impl_.v1_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::V1Frame* Frame::_internal_mutable_v1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.v1_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::V1Frame>(GetArenaForAllocation());
    _impl_.v1_ = p;
  }
  return _impl_.v1_;
}
inline ::nearby::sharing::service::proto::V1Frame* Frame::mutable_v1() {
  ::nearby::sharing::service::proto::V1Frame* _msg = _internal_mutable_v1();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.Frame.v1)
  return _msg;
}
inline void Frame::set_allocated_v1(::nearby::sharing::service::proto::V1Frame* v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.v1_;
  }
  if (v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(v1);
    if (message_arena != submessage_arena) {
      v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.v1_ = v1;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.Frame.v1)
}

// -------------------------------------------------------------------

// V1Frame

// optional .nearby.sharing.service.proto.V1Frame.FrameType type = 1;
inline bool V1Frame::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void V1Frame::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::nearby::sharing::service::proto::V1Frame_FrameType V1Frame::type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.type)
  return _internal_type();
}
inline void V1Frame::set_type(::nearby::sharing::service::proto::V1Frame_FrameType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.V1Frame.type)
}
inline ::nearby::sharing::service::proto::V1Frame_FrameType V1Frame::_internal_type() const {
  return static_cast<::nearby::sharing::service::proto::V1Frame_FrameType>(_impl_.type_);
}
inline void V1Frame::_internal_set_type(::nearby::sharing::service::proto::V1Frame_FrameType value) {
  assert(::nearby::sharing::service::proto::V1Frame_FrameType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.type_ = value;
}

// optional .nearby.sharing.service.proto.IntroductionFrame introduction = 2;
inline bool V1Frame::has_introduction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.introduction_ != nullptr);
  return value;
}
inline void V1Frame::clear_introduction() {
  if (_impl_.introduction_ != nullptr) _impl_.introduction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nearby::sharing::service::proto::IntroductionFrame& V1Frame::_internal_introduction() const {
  const ::nearby::sharing::service::proto::IntroductionFrame* p = _impl_.introduction_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::IntroductionFrame&>(
      ::nearby::sharing::service::proto::_IntroductionFrame_default_instance_);
}
inline const ::nearby::sharing::service::proto::IntroductionFrame& V1Frame::introduction() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.introduction)
  return _internal_introduction();
}
inline void V1Frame::unsafe_arena_set_allocated_introduction(
    ::nearby::sharing::service::proto::IntroductionFrame* introduction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.introduction_);
  }
  _impl_.introduction_ = introduction;
  if (introduction) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.V1Frame.introduction)
}
inline ::nearby::sharing::service::proto::IntroductionFrame* V1Frame::release_introduction() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::service::proto::IntroductionFrame* temp = _impl_.introduction_;
  _impl_.introduction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::IntroductionFrame* V1Frame::unsafe_arena_release_introduction() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.V1Frame.introduction)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::service::proto::IntroductionFrame* temp = _impl_.introduction_;
  _impl_.introduction_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::IntroductionFrame* V1Frame::_internal_mutable_introduction() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.introduction_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::IntroductionFrame>(GetArenaForAllocation());
    _impl_.introduction_ = p;
  }
  return _impl_.introduction_;
}
inline ::nearby::sharing::service::proto::IntroductionFrame* V1Frame::mutable_introduction() {
  ::nearby::sharing::service::proto::IntroductionFrame* _msg = _internal_mutable_introduction();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.V1Frame.introduction)
  return _msg;
}
inline void V1Frame::set_allocated_introduction(::nearby::sharing::service::proto::IntroductionFrame* introduction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.introduction_;
  }
  if (introduction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(introduction);
    if (message_arena != submessage_arena) {
      introduction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, introduction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.introduction_ = introduction;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.V1Frame.introduction)
}

// optional .nearby.sharing.service.proto.ConnectionResponseFrame connection_response = 3;
inline bool V1Frame::has_connection_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connection_response_ != nullptr);
  return value;
}
inline void V1Frame::clear_connection_response() {
  if (_impl_.connection_response_ != nullptr) _impl_.connection_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::nearby::sharing::service::proto::ConnectionResponseFrame& V1Frame::_internal_connection_response() const {
  const ::nearby::sharing::service::proto::ConnectionResponseFrame* p = _impl_.connection_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::ConnectionResponseFrame&>(
      ::nearby::sharing::service::proto::_ConnectionResponseFrame_default_instance_);
}
inline const ::nearby::sharing::service::proto::ConnectionResponseFrame& V1Frame::connection_response() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.connection_response)
  return _internal_connection_response();
}
inline void V1Frame::unsafe_arena_set_allocated_connection_response(
    ::nearby::sharing::service::proto::ConnectionResponseFrame* connection_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_response_);
  }
  _impl_.connection_response_ = connection_response;
  if (connection_response) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.V1Frame.connection_response)
}
inline ::nearby::sharing::service::proto::ConnectionResponseFrame* V1Frame::release_connection_response() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nearby::sharing::service::proto::ConnectionResponseFrame* temp = _impl_.connection_response_;
  _impl_.connection_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::ConnectionResponseFrame* V1Frame::unsafe_arena_release_connection_response() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.V1Frame.connection_response)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::nearby::sharing::service::proto::ConnectionResponseFrame* temp = _impl_.connection_response_;
  _impl_.connection_response_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::ConnectionResponseFrame* V1Frame::_internal_mutable_connection_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.connection_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::ConnectionResponseFrame>(GetArenaForAllocation());
    _impl_.connection_response_ = p;
  }
  return _impl_.connection_response_;
}
inline ::nearby::sharing::service::proto::ConnectionResponseFrame* V1Frame::mutable_connection_response() {
  ::nearby::sharing::service::proto::ConnectionResponseFrame* _msg = _internal_mutable_connection_response();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.V1Frame.connection_response)
  return _msg;
}
inline void V1Frame::set_allocated_connection_response(::nearby::sharing::service::proto::ConnectionResponseFrame* connection_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_response_;
  }
  if (connection_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_response);
    if (message_arena != submessage_arena) {
      connection_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.connection_response_ = connection_response;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.V1Frame.connection_response)
}

// optional .nearby.sharing.service.proto.PairedKeyEncryptionFrame paired_key_encryption = 4;
inline bool V1Frame::has_paired_key_encryption() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paired_key_encryption_ != nullptr);
  return value;
}
inline void V1Frame::clear_paired_key_encryption() {
  if (_impl_.paired_key_encryption_ != nullptr) _impl_.paired_key_encryption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame& V1Frame::_internal_paired_key_encryption() const {
  const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* p = _impl_.paired_key_encryption_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame&>(
      ::nearby::sharing::service::proto::_PairedKeyEncryptionFrame_default_instance_);
}
inline const ::nearby::sharing::service::proto::PairedKeyEncryptionFrame& V1Frame::paired_key_encryption() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.paired_key_encryption)
  return _internal_paired_key_encryption();
}
inline void V1Frame::unsafe_arena_set_allocated_paired_key_encryption(
    ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* paired_key_encryption) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paired_key_encryption_);
  }
  _impl_.paired_key_encryption_ = paired_key_encryption;
  if (paired_key_encryption) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.V1Frame.paired_key_encryption)
}
inline ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* V1Frame::release_paired_key_encryption() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* temp = _impl_.paired_key_encryption_;
  _impl_.paired_key_encryption_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* V1Frame::unsafe_arena_release_paired_key_encryption() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.V1Frame.paired_key_encryption)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* temp = _impl_.paired_key_encryption_;
  _impl_.paired_key_encryption_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* V1Frame::_internal_mutable_paired_key_encryption() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.paired_key_encryption_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::PairedKeyEncryptionFrame>(GetArenaForAllocation());
    _impl_.paired_key_encryption_ = p;
  }
  return _impl_.paired_key_encryption_;
}
inline ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* V1Frame::mutable_paired_key_encryption() {
  ::nearby::sharing::service::proto::PairedKeyEncryptionFrame* _msg = _internal_mutable_paired_key_encryption();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.V1Frame.paired_key_encryption)
  return _msg;
}
inline void V1Frame::set_allocated_paired_key_encryption(::nearby::sharing::service::proto::PairedKeyEncryptionFrame* paired_key_encryption) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paired_key_encryption_;
  }
  if (paired_key_encryption) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paired_key_encryption);
    if (message_arena != submessage_arena) {
      paired_key_encryption = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paired_key_encryption, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.paired_key_encryption_ = paired_key_encryption;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.V1Frame.paired_key_encryption)
}

// optional .nearby.sharing.service.proto.PairedKeyResultFrame paired_key_result = 5;
inline bool V1Frame::has_paired_key_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paired_key_result_ != nullptr);
  return value;
}
inline void V1Frame::clear_paired_key_result() {
  if (_impl_.paired_key_result_ != nullptr) _impl_.paired_key_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::nearby::sharing::service::proto::PairedKeyResultFrame& V1Frame::_internal_paired_key_result() const {
  const ::nearby::sharing::service::proto::PairedKeyResultFrame* p = _impl_.paired_key_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::PairedKeyResultFrame&>(
      ::nearby::sharing::service::proto::_PairedKeyResultFrame_default_instance_);
}
inline const ::nearby::sharing::service::proto::PairedKeyResultFrame& V1Frame::paired_key_result() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.paired_key_result)
  return _internal_paired_key_result();
}
inline void V1Frame::unsafe_arena_set_allocated_paired_key_result(
    ::nearby::sharing::service::proto::PairedKeyResultFrame* paired_key_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paired_key_result_);
  }
  _impl_.paired_key_result_ = paired_key_result;
  if (paired_key_result) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.V1Frame.paired_key_result)
}
inline ::nearby::sharing::service::proto::PairedKeyResultFrame* V1Frame::release_paired_key_result() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::nearby::sharing::service::proto::PairedKeyResultFrame* temp = _impl_.paired_key_result_;
  _impl_.paired_key_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::PairedKeyResultFrame* V1Frame::unsafe_arena_release_paired_key_result() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.V1Frame.paired_key_result)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::nearby::sharing::service::proto::PairedKeyResultFrame* temp = _impl_.paired_key_result_;
  _impl_.paired_key_result_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::PairedKeyResultFrame* V1Frame::_internal_mutable_paired_key_result() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.paired_key_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::PairedKeyResultFrame>(GetArenaForAllocation());
    _impl_.paired_key_result_ = p;
  }
  return _impl_.paired_key_result_;
}
inline ::nearby::sharing::service::proto::PairedKeyResultFrame* V1Frame::mutable_paired_key_result() {
  ::nearby::sharing::service::proto::PairedKeyResultFrame* _msg = _internal_mutable_paired_key_result();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.V1Frame.paired_key_result)
  return _msg;
}
inline void V1Frame::set_allocated_paired_key_result(::nearby::sharing::service::proto::PairedKeyResultFrame* paired_key_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paired_key_result_;
  }
  if (paired_key_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paired_key_result);
    if (message_arena != submessage_arena) {
      paired_key_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paired_key_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.paired_key_result_ = paired_key_result;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.V1Frame.paired_key_result)
}

// optional .nearby.sharing.service.proto.CertificateInfoFrame certificate_info = 6;
inline bool V1Frame::has_certificate_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.certificate_info_ != nullptr);
  return value;
}
inline void V1Frame::clear_certificate_info() {
  if (_impl_.certificate_info_ != nullptr) _impl_.certificate_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::nearby::sharing::service::proto::CertificateInfoFrame& V1Frame::_internal_certificate_info() const {
  const ::nearby::sharing::service::proto::CertificateInfoFrame* p = _impl_.certificate_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::CertificateInfoFrame&>(
      ::nearby::sharing::service::proto::_CertificateInfoFrame_default_instance_);
}
inline const ::nearby::sharing::service::proto::CertificateInfoFrame& V1Frame::certificate_info() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.certificate_info)
  return _internal_certificate_info();
}
inline void V1Frame::unsafe_arena_set_allocated_certificate_info(
    ::nearby::sharing::service::proto::CertificateInfoFrame* certificate_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.certificate_info_);
  }
  _impl_.certificate_info_ = certificate_info;
  if (certificate_info) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.V1Frame.certificate_info)
}
inline ::nearby::sharing::service::proto::CertificateInfoFrame* V1Frame::release_certificate_info() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::nearby::sharing::service::proto::CertificateInfoFrame* temp = _impl_.certificate_info_;
  _impl_.certificate_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::CertificateInfoFrame* V1Frame::unsafe_arena_release_certificate_info() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.V1Frame.certificate_info)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::nearby::sharing::service::proto::CertificateInfoFrame* temp = _impl_.certificate_info_;
  _impl_.certificate_info_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::CertificateInfoFrame* V1Frame::_internal_mutable_certificate_info() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.certificate_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::CertificateInfoFrame>(GetArenaForAllocation());
    _impl_.certificate_info_ = p;
  }
  return _impl_.certificate_info_;
}
inline ::nearby::sharing::service::proto::CertificateInfoFrame* V1Frame::mutable_certificate_info() {
  ::nearby::sharing::service::proto::CertificateInfoFrame* _msg = _internal_mutable_certificate_info();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.V1Frame.certificate_info)
  return _msg;
}
inline void V1Frame::set_allocated_certificate_info(::nearby::sharing::service::proto::CertificateInfoFrame* certificate_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.certificate_info_;
  }
  if (certificate_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(certificate_info);
    if (message_arena != submessage_arena) {
      certificate_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certificate_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.certificate_info_ = certificate_info;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.V1Frame.certificate_info)
}

// optional .nearby.sharing.service.proto.ProgressUpdateFrame progress_update = 7;
inline bool V1Frame::has_progress_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.progress_update_ != nullptr);
  return value;
}
inline void V1Frame::clear_progress_update() {
  if (_impl_.progress_update_ != nullptr) _impl_.progress_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::nearby::sharing::service::proto::ProgressUpdateFrame& V1Frame::_internal_progress_update() const {
  const ::nearby::sharing::service::proto::ProgressUpdateFrame* p = _impl_.progress_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::ProgressUpdateFrame&>(
      ::nearby::sharing::service::proto::_ProgressUpdateFrame_default_instance_);
}
inline const ::nearby::sharing::service::proto::ProgressUpdateFrame& V1Frame::progress_update() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.V1Frame.progress_update)
  return _internal_progress_update();
}
inline void V1Frame::unsafe_arena_set_allocated_progress_update(
    ::nearby::sharing::service::proto::ProgressUpdateFrame* progress_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.progress_update_);
  }
  _impl_.progress_update_ = progress_update;
  if (progress_update) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.V1Frame.progress_update)
}
inline ::nearby::sharing::service::proto::ProgressUpdateFrame* V1Frame::release_progress_update() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::nearby::sharing::service::proto::ProgressUpdateFrame* temp = _impl_.progress_update_;
  _impl_.progress_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::ProgressUpdateFrame* V1Frame::unsafe_arena_release_progress_update() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.V1Frame.progress_update)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::nearby::sharing::service::proto::ProgressUpdateFrame* temp = _impl_.progress_update_;
  _impl_.progress_update_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::ProgressUpdateFrame* V1Frame::_internal_mutable_progress_update() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.progress_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::ProgressUpdateFrame>(GetArenaForAllocation());
    _impl_.progress_update_ = p;
  }
  return _impl_.progress_update_;
}
inline ::nearby::sharing::service::proto::ProgressUpdateFrame* V1Frame::mutable_progress_update() {
  ::nearby::sharing::service::proto::ProgressUpdateFrame* _msg = _internal_mutable_progress_update();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.V1Frame.progress_update)
  return _msg;
}
inline void V1Frame::set_allocated_progress_update(::nearby::sharing::service::proto::ProgressUpdateFrame* progress_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.progress_update_;
  }
  if (progress_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(progress_update);
    if (message_arena != submessage_arena) {
      progress_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress_update, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.progress_update_ = progress_update;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.V1Frame.progress_update)
}

// -------------------------------------------------------------------

// IntroductionFrame

// repeated .nearby.sharing.service.proto.FileMetadata file_metadata = 1;
inline int IntroductionFrame::_internal_file_metadata_size() const {
  return _impl_.file_metadata_.size();
}
inline int IntroductionFrame::file_metadata_size() const {
  return _internal_file_metadata_size();
}
inline void IntroductionFrame::clear_file_metadata() {
  _internal_mutable_file_metadata()->Clear();
}
inline ::nearby::sharing::service::proto::FileMetadata* IntroductionFrame::mutable_file_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.IntroductionFrame.file_metadata)
  return _internal_mutable_file_metadata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::FileMetadata >*
IntroductionFrame::mutable_file_metadata() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.IntroductionFrame.file_metadata)
  return _internal_mutable_file_metadata();
}
inline const ::nearby::sharing::service::proto::FileMetadata& IntroductionFrame::_internal_file_metadata(int index) const {
  return _internal_file_metadata().Get(index);
}
inline const ::nearby::sharing::service::proto::FileMetadata& IntroductionFrame::file_metadata(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.IntroductionFrame.file_metadata)
  return _internal_file_metadata(index);
}
inline ::nearby::sharing::service::proto::FileMetadata* IntroductionFrame::_internal_add_file_metadata() {
  return _internal_mutable_file_metadata()->Add();
}
inline ::nearby::sharing::service::proto::FileMetadata* IntroductionFrame::add_file_metadata() {
  ::nearby::sharing::service::proto::FileMetadata* _add = _internal_add_file_metadata();
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.IntroductionFrame.file_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::FileMetadata >&
IntroductionFrame::file_metadata() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.IntroductionFrame.file_metadata)
  return _internal_file_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::FileMetadata>&
IntroductionFrame::_internal_file_metadata() const {
  return _impl_.file_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::FileMetadata>*
IntroductionFrame::_internal_mutable_file_metadata() {
  return &_impl_.file_metadata_;
}

// repeated .nearby.sharing.service.proto.TextMetadata text_metadata = 2;
inline int IntroductionFrame::_internal_text_metadata_size() const {
  return _impl_.text_metadata_.size();
}
inline int IntroductionFrame::text_metadata_size() const {
  return _internal_text_metadata_size();
}
inline void IntroductionFrame::clear_text_metadata() {
  _internal_mutable_text_metadata()->Clear();
}
inline ::nearby::sharing::service::proto::TextMetadata* IntroductionFrame::mutable_text_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.IntroductionFrame.text_metadata)
  return _internal_mutable_text_metadata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::TextMetadata >*
IntroductionFrame::mutable_text_metadata() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.IntroductionFrame.text_metadata)
  return _internal_mutable_text_metadata();
}
inline const ::nearby::sharing::service::proto::TextMetadata& IntroductionFrame::_internal_text_metadata(int index) const {
  return _internal_text_metadata().Get(index);
}
inline const ::nearby::sharing::service::proto::TextMetadata& IntroductionFrame::text_metadata(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.IntroductionFrame.text_metadata)
  return _internal_text_metadata(index);
}
inline ::nearby::sharing::service::proto::TextMetadata* IntroductionFrame::_internal_add_text_metadata() {
  return _internal_mutable_text_metadata()->Add();
}
inline ::nearby::sharing::service::proto::TextMetadata* IntroductionFrame::add_text_metadata() {
  ::nearby::sharing::service::proto::TextMetadata* _add = _internal_add_text_metadata();
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.IntroductionFrame.text_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::TextMetadata >&
IntroductionFrame::text_metadata() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.IntroductionFrame.text_metadata)
  return _internal_text_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::TextMetadata>&
IntroductionFrame::_internal_text_metadata() const {
  return _impl_.text_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::TextMetadata>*
IntroductionFrame::_internal_mutable_text_metadata() {
  return &_impl_.text_metadata_;
}

// optional string required_package = 3;
inline bool IntroductionFrame::has_required_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IntroductionFrame::clear_required_package() {
  _impl_.required_package_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IntroductionFrame::required_package() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.IntroductionFrame.required_package)
  return _internal_required_package();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IntroductionFrame::set_required_package(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.required_package_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.IntroductionFrame.required_package)
}
inline std::string* IntroductionFrame::mutable_required_package() {
  std::string* _s = _internal_mutable_required_package();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.IntroductionFrame.required_package)
  return _s;
}
inline const std::string& IntroductionFrame::_internal_required_package() const {
  return _impl_.required_package_.Get();
}
inline void IntroductionFrame::_internal_set_required_package(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.required_package_.Set(value, GetArenaForAllocation());
}
inline std::string* IntroductionFrame::_internal_mutable_required_package() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.required_package_.Mutable( GetArenaForAllocation());
}
inline std::string* IntroductionFrame::release_required_package() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.IntroductionFrame.required_package)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.required_package_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.required_package_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IntroductionFrame::set_allocated_required_package(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.required_package_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.required_package_.IsDefault()) {
          _impl_.required_package_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.IntroductionFrame.required_package)
}

// repeated .nearby.sharing.service.proto.WifiCredentialsMetadata wifi_credentials_metadata = 4;
inline int IntroductionFrame::_internal_wifi_credentials_metadata_size() const {
  return _impl_.wifi_credentials_metadata_.size();
}
inline int IntroductionFrame::wifi_credentials_metadata_size() const {
  return _internal_wifi_credentials_metadata_size();
}
inline void IntroductionFrame::clear_wifi_credentials_metadata() {
  _internal_mutable_wifi_credentials_metadata()->Clear();
}
inline ::nearby::sharing::service::proto::WifiCredentialsMetadata* IntroductionFrame::mutable_wifi_credentials_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.IntroductionFrame.wifi_credentials_metadata)
  return _internal_mutable_wifi_credentials_metadata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::WifiCredentialsMetadata >*
IntroductionFrame::mutable_wifi_credentials_metadata() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.IntroductionFrame.wifi_credentials_metadata)
  return _internal_mutable_wifi_credentials_metadata();
}
inline const ::nearby::sharing::service::proto::WifiCredentialsMetadata& IntroductionFrame::_internal_wifi_credentials_metadata(int index) const {
  return _internal_wifi_credentials_metadata().Get(index);
}
inline const ::nearby::sharing::service::proto::WifiCredentialsMetadata& IntroductionFrame::wifi_credentials_metadata(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.IntroductionFrame.wifi_credentials_metadata)
  return _internal_wifi_credentials_metadata(index);
}
inline ::nearby::sharing::service::proto::WifiCredentialsMetadata* IntroductionFrame::_internal_add_wifi_credentials_metadata() {
  return _internal_mutable_wifi_credentials_metadata()->Add();
}
inline ::nearby::sharing::service::proto::WifiCredentialsMetadata* IntroductionFrame::add_wifi_credentials_metadata() {
  ::nearby::sharing::service::proto::WifiCredentialsMetadata* _add = _internal_add_wifi_credentials_metadata();
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.IntroductionFrame.wifi_credentials_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::WifiCredentialsMetadata >&
IntroductionFrame::wifi_credentials_metadata() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.IntroductionFrame.wifi_credentials_metadata)
  return _internal_wifi_credentials_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::WifiCredentialsMetadata>&
IntroductionFrame::_internal_wifi_credentials_metadata() const {
  return _impl_.wifi_credentials_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::WifiCredentialsMetadata>*
IntroductionFrame::_internal_mutable_wifi_credentials_metadata() {
  return &_impl_.wifi_credentials_metadata_;
}

// repeated .nearby.sharing.service.proto.AppMetadata app_metadata = 5;
inline int IntroductionFrame::_internal_app_metadata_size() const {
  return _impl_.app_metadata_.size();
}
inline int IntroductionFrame::app_metadata_size() const {
  return _internal_app_metadata_size();
}
inline void IntroductionFrame::clear_app_metadata() {
  _internal_mutable_app_metadata()->Clear();
}
inline ::nearby::sharing::service::proto::AppMetadata* IntroductionFrame::mutable_app_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.IntroductionFrame.app_metadata)
  return _internal_mutable_app_metadata()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::AppMetadata >*
IntroductionFrame::mutable_app_metadata() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.IntroductionFrame.app_metadata)
  return _internal_mutable_app_metadata();
}
inline const ::nearby::sharing::service::proto::AppMetadata& IntroductionFrame::_internal_app_metadata(int index) const {
  return _internal_app_metadata().Get(index);
}
inline const ::nearby::sharing::service::proto::AppMetadata& IntroductionFrame::app_metadata(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.IntroductionFrame.app_metadata)
  return _internal_app_metadata(index);
}
inline ::nearby::sharing::service::proto::AppMetadata* IntroductionFrame::_internal_add_app_metadata() {
  return _internal_mutable_app_metadata()->Add();
}
inline ::nearby::sharing::service::proto::AppMetadata* IntroductionFrame::add_app_metadata() {
  ::nearby::sharing::service::proto::AppMetadata* _add = _internal_add_app_metadata();
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.IntroductionFrame.app_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::AppMetadata >&
IntroductionFrame::app_metadata() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.IntroductionFrame.app_metadata)
  return _internal_app_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::AppMetadata>&
IntroductionFrame::_internal_app_metadata() const {
  return _impl_.app_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::AppMetadata>*
IntroductionFrame::_internal_mutable_app_metadata() {
  return &_impl_.app_metadata_;
}

// optional bool start_transfer = 6;
inline bool IntroductionFrame::has_start_transfer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IntroductionFrame::clear_start_transfer() {
  _impl_.start_transfer_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool IntroductionFrame::start_transfer() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.IntroductionFrame.start_transfer)
  return _internal_start_transfer();
}
inline void IntroductionFrame::set_start_transfer(bool value) {
  _internal_set_start_transfer(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.IntroductionFrame.start_transfer)
}
inline bool IntroductionFrame::_internal_start_transfer() const {
  return _impl_.start_transfer_;
}
inline void IntroductionFrame::_internal_set_start_transfer(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_transfer_ = value;
}

// -------------------------------------------------------------------

// ProgressUpdateFrame

// optional float progress = 1;
inline bool ProgressUpdateFrame::has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ProgressUpdateFrame::clear_progress() {
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ProgressUpdateFrame::progress() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.ProgressUpdateFrame.progress)
  return _internal_progress();
}
inline void ProgressUpdateFrame::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.ProgressUpdateFrame.progress)
}
inline float ProgressUpdateFrame::_internal_progress() const {
  return _impl_.progress_;
}
inline void ProgressUpdateFrame::_internal_set_progress(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.progress_ = value;
}

// optional bool start_transfer = 2;
inline bool ProgressUpdateFrame::has_start_transfer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ProgressUpdateFrame::clear_start_transfer() {
  _impl_.start_transfer_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ProgressUpdateFrame::start_transfer() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.ProgressUpdateFrame.start_transfer)
  return _internal_start_transfer();
}
inline void ProgressUpdateFrame::set_start_transfer(bool value) {
  _internal_set_start_transfer(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.ProgressUpdateFrame.start_transfer)
}
inline bool ProgressUpdateFrame::_internal_start_transfer() const {
  return _impl_.start_transfer_;
}
inline void ProgressUpdateFrame::_internal_set_start_transfer(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_transfer_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ConnectionResponseFrame

// optional .nearby.sharing.service.proto.ConnectionResponseFrame.Status status = 1;
inline bool ConnectionResponseFrame::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConnectionResponseFrame::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::nearby::sharing::service::proto::ConnectionResponseFrame_Status ConnectionResponseFrame::status() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.ConnectionResponseFrame.status)
  return _internal_status();
}
inline void ConnectionResponseFrame::set_status(::nearby::sharing::service::proto::ConnectionResponseFrame_Status value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.ConnectionResponseFrame.status)
}
inline ::nearby::sharing::service::proto::ConnectionResponseFrame_Status ConnectionResponseFrame::_internal_status() const {
  return static_cast<::nearby::sharing::service::proto::ConnectionResponseFrame_Status>(_impl_.status_);
}
inline void ConnectionResponseFrame::_internal_set_status(::nearby::sharing::service::proto::ConnectionResponseFrame_Status value) {
  assert(::nearby::sharing::service::proto::ConnectionResponseFrame_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// map<int64, .nearby.sharing.service.proto.AttachmentDetails> attachment_details = 2;
inline int ConnectionResponseFrame::_internal_attachment_details_size() const {
  return _impl_.attachment_details_.size();
}
inline int ConnectionResponseFrame::attachment_details_size() const {
  return _internal_attachment_details_size();
}
inline void ConnectionResponseFrame::clear_attachment_details() {
  _impl_.attachment_details_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >&
ConnectionResponseFrame::_internal_attachment_details() const {
  return _impl_.attachment_details_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >&
ConnectionResponseFrame::attachment_details() const {
  // @@protoc_insertion_point(field_map:nearby.sharing.service.proto.ConnectionResponseFrame.attachment_details)
  return _internal_attachment_details();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >*
ConnectionResponseFrame::_internal_mutable_attachment_details() {
  return _impl_.attachment_details_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::AttachmentDetails >*
ConnectionResponseFrame::mutable_attachment_details() {
  // @@protoc_insertion_point(field_mutable_map:nearby.sharing.service.proto.ConnectionResponseFrame.attachment_details)
  return _internal_mutable_attachment_details();
}

// -------------------------------------------------------------------

// AttachmentDetails

// optional .nearby.sharing.service.proto.AttachmentDetails.Type type = 1;
inline bool AttachmentDetails::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AttachmentDetails::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::nearby::sharing::service::proto::AttachmentDetails_Type AttachmentDetails::type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AttachmentDetails.type)
  return _internal_type();
}
inline void AttachmentDetails::set_type(::nearby::sharing::service::proto::AttachmentDetails_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.AttachmentDetails.type)
}
inline ::nearby::sharing::service::proto::AttachmentDetails_Type AttachmentDetails::_internal_type() const {
  return static_cast<::nearby::sharing::service::proto::AttachmentDetails_Type>(_impl_.type_);
}
inline void AttachmentDetails::_internal_set_type(::nearby::sharing::service::proto::AttachmentDetails_Type value) {
  assert(::nearby::sharing::service::proto::AttachmentDetails_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional .nearby.sharing.service.proto.FileAttachmentDetails file_attachment_details = 2;
inline bool AttachmentDetails::has_file_attachment_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.file_attachment_details_ != nullptr);
  return value;
}
inline void AttachmentDetails::clear_file_attachment_details() {
  if (_impl_.file_attachment_details_ != nullptr) _impl_.file_attachment_details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::nearby::sharing::service::proto::FileAttachmentDetails& AttachmentDetails::_internal_file_attachment_details() const {
  const ::nearby::sharing::service::proto::FileAttachmentDetails* p = _impl_.file_attachment_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::nearby::sharing::service::proto::FileAttachmentDetails&>(
      ::nearby::sharing::service::proto::_FileAttachmentDetails_default_instance_);
}
inline const ::nearby::sharing::service::proto::FileAttachmentDetails& AttachmentDetails::file_attachment_details() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.AttachmentDetails.file_attachment_details)
  return _internal_file_attachment_details();
}
inline void AttachmentDetails::unsafe_arena_set_allocated_file_attachment_details(
    ::nearby::sharing::service::proto::FileAttachmentDetails* file_attachment_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_attachment_details_);
  }
  _impl_.file_attachment_details_ = file_attachment_details;
  if (file_attachment_details) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nearby.sharing.service.proto.AttachmentDetails.file_attachment_details)
}
inline ::nearby::sharing::service::proto::FileAttachmentDetails* AttachmentDetails::release_file_attachment_details() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::service::proto::FileAttachmentDetails* temp = _impl_.file_attachment_details_;
  _impl_.file_attachment_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nearby::sharing::service::proto::FileAttachmentDetails* AttachmentDetails::unsafe_arena_release_file_attachment_details() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.AttachmentDetails.file_attachment_details)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::nearby::sharing::service::proto::FileAttachmentDetails* temp = _impl_.file_attachment_details_;
  _impl_.file_attachment_details_ = nullptr;
  return temp;
}
inline ::nearby::sharing::service::proto::FileAttachmentDetails* AttachmentDetails::_internal_mutable_file_attachment_details() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.file_attachment_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::nearby::sharing::service::proto::FileAttachmentDetails>(GetArenaForAllocation());
    _impl_.file_attachment_details_ = p;
  }
  return _impl_.file_attachment_details_;
}
inline ::nearby::sharing::service::proto::FileAttachmentDetails* AttachmentDetails::mutable_file_attachment_details() {
  ::nearby::sharing::service::proto::FileAttachmentDetails* _msg = _internal_mutable_file_attachment_details();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.AttachmentDetails.file_attachment_details)
  return _msg;
}
inline void AttachmentDetails::set_allocated_file_attachment_details(::nearby::sharing::service::proto::FileAttachmentDetails* file_attachment_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.file_attachment_details_;
  }
  if (file_attachment_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_attachment_details);
    if (message_arena != submessage_arena) {
      file_attachment_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_attachment_details, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.file_attachment_details_ = file_attachment_details;
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.AttachmentDetails.file_attachment_details)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FileAttachmentDetails

// optional int64 receiver_existing_file_size = 1;
inline bool FileAttachmentDetails::has_receiver_existing_file_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FileAttachmentDetails::clear_receiver_existing_file_size() {
  _impl_.receiver_existing_file_size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t FileAttachmentDetails::receiver_existing_file_size() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.FileAttachmentDetails.receiver_existing_file_size)
  return _internal_receiver_existing_file_size();
}
inline void FileAttachmentDetails::set_receiver_existing_file_size(::int64_t value) {
  _internal_set_receiver_existing_file_size(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.FileAttachmentDetails.receiver_existing_file_size)
}
inline ::int64_t FileAttachmentDetails::_internal_receiver_existing_file_size() const {
  return _impl_.receiver_existing_file_size_;
}
inline void FileAttachmentDetails::_internal_set_receiver_existing_file_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.receiver_existing_file_size_ = value;
}

// map<int64, .nearby.sharing.service.proto.PayloadsDetails> attachment_hash_payloads = 2;
inline int FileAttachmentDetails::_internal_attachment_hash_payloads_size() const {
  return _impl_.attachment_hash_payloads_.size();
}
inline int FileAttachmentDetails::attachment_hash_payloads_size() const {
  return _internal_attachment_hash_payloads_size();
}
inline void FileAttachmentDetails::clear_attachment_hash_payloads() {
  _impl_.attachment_hash_payloads_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >&
FileAttachmentDetails::_internal_attachment_hash_payloads() const {
  return _impl_.attachment_hash_payloads_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >&
FileAttachmentDetails::attachment_hash_payloads() const {
  // @@protoc_insertion_point(field_map:nearby.sharing.service.proto.FileAttachmentDetails.attachment_hash_payloads)
  return _internal_attachment_hash_payloads();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >*
FileAttachmentDetails::_internal_mutable_attachment_hash_payloads() {
  return _impl_.attachment_hash_payloads_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::nearby::sharing::service::proto::PayloadsDetails >*
FileAttachmentDetails::mutable_attachment_hash_payloads() {
  // @@protoc_insertion_point(field_mutable_map:nearby.sharing.service.proto.FileAttachmentDetails.attachment_hash_payloads)
  return _internal_mutable_attachment_hash_payloads();
}

// -------------------------------------------------------------------

// PayloadsDetails

// repeated .nearby.sharing.service.proto.PayloadDetails payload_details = 1;
inline int PayloadsDetails::_internal_payload_details_size() const {
  return _impl_.payload_details_.size();
}
inline int PayloadsDetails::payload_details_size() const {
  return _internal_payload_details_size();
}
inline void PayloadsDetails::clear_payload_details() {
  _internal_mutable_payload_details()->Clear();
}
inline ::nearby::sharing::service::proto::PayloadDetails* PayloadsDetails::mutable_payload_details(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PayloadsDetails.payload_details)
  return _internal_mutable_payload_details()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PayloadDetails >*
PayloadsDetails::mutable_payload_details() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.PayloadsDetails.payload_details)
  return _internal_mutable_payload_details();
}
inline const ::nearby::sharing::service::proto::PayloadDetails& PayloadsDetails::_internal_payload_details(int index) const {
  return _internal_payload_details().Get(index);
}
inline const ::nearby::sharing::service::proto::PayloadDetails& PayloadsDetails::payload_details(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PayloadsDetails.payload_details)
  return _internal_payload_details(index);
}
inline ::nearby::sharing::service::proto::PayloadDetails* PayloadsDetails::_internal_add_payload_details() {
  return _internal_mutable_payload_details()->Add();
}
inline ::nearby::sharing::service::proto::PayloadDetails* PayloadsDetails::add_payload_details() {
  ::nearby::sharing::service::proto::PayloadDetails* _add = _internal_add_payload_details();
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.PayloadsDetails.payload_details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PayloadDetails >&
PayloadsDetails::payload_details() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.PayloadsDetails.payload_details)
  return _internal_payload_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PayloadDetails>&
PayloadsDetails::_internal_payload_details() const {
  return _impl_.payload_details_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PayloadDetails>*
PayloadsDetails::_internal_mutable_payload_details() {
  return &_impl_.payload_details_;
}

// -------------------------------------------------------------------

// PayloadDetails

// optional int64 id = 1;
inline bool PayloadDetails::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PayloadDetails::clear_id() {
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t PayloadDetails::id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PayloadDetails.id)
  return _internal_id();
}
inline void PayloadDetails::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PayloadDetails.id)
}
inline ::int64_t PayloadDetails::_internal_id() const {
  return _impl_.id_;
}
inline void PayloadDetails::_internal_set_id(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}

// optional int64 creation_timestamp_millis = 2;
inline bool PayloadDetails::has_creation_timestamp_millis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PayloadDetails::clear_creation_timestamp_millis() {
  _impl_.creation_timestamp_millis_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t PayloadDetails::creation_timestamp_millis() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PayloadDetails.creation_timestamp_millis)
  return _internal_creation_timestamp_millis();
}
inline void PayloadDetails::set_creation_timestamp_millis(::int64_t value) {
  _internal_set_creation_timestamp_millis(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PayloadDetails.creation_timestamp_millis)
}
inline ::int64_t PayloadDetails::_internal_creation_timestamp_millis() const {
  return _impl_.creation_timestamp_millis_;
}
inline void PayloadDetails::_internal_set_creation_timestamp_millis(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.creation_timestamp_millis_ = value;
}

// optional int64 size = 3;
inline bool PayloadDetails::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PayloadDetails::clear_size() {
  _impl_.size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t PayloadDetails::size() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PayloadDetails.size)
  return _internal_size();
}
inline void PayloadDetails::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PayloadDetails.size)
}
inline ::int64_t PayloadDetails::_internal_size() const {
  return _impl_.size_;
}
inline void PayloadDetails::_internal_set_size(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// PairedKeyEncryptionFrame

// optional bytes signed_data = 1;
inline bool PairedKeyEncryptionFrame::has_signed_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PairedKeyEncryptionFrame::clear_signed_data() {
  _impl_.signed_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PairedKeyEncryptionFrame::signed_data() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PairedKeyEncryptionFrame.signed_data)
  return _internal_signed_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PairedKeyEncryptionFrame::set_signed_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signed_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PairedKeyEncryptionFrame.signed_data)
}
inline std::string* PairedKeyEncryptionFrame::mutable_signed_data() {
  std::string* _s = _internal_mutable_signed_data();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PairedKeyEncryptionFrame.signed_data)
  return _s;
}
inline const std::string& PairedKeyEncryptionFrame::_internal_signed_data() const {
  return _impl_.signed_data_.Get();
}
inline void PairedKeyEncryptionFrame::_internal_set_signed_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.signed_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::_internal_mutable_signed_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signed_data_.Mutable( GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::release_signed_data() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PairedKeyEncryptionFrame.signed_data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.signed_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PairedKeyEncryptionFrame::set_allocated_signed_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signed_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signed_data_.IsDefault()) {
          _impl_.signed_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PairedKeyEncryptionFrame.signed_data)
}

// optional bytes secret_id_hash = 2;
inline bool PairedKeyEncryptionFrame::has_secret_id_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PairedKeyEncryptionFrame::clear_secret_id_hash() {
  _impl_.secret_id_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PairedKeyEncryptionFrame::secret_id_hash() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PairedKeyEncryptionFrame.secret_id_hash)
  return _internal_secret_id_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PairedKeyEncryptionFrame::set_secret_id_hash(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.secret_id_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PairedKeyEncryptionFrame.secret_id_hash)
}
inline std::string* PairedKeyEncryptionFrame::mutable_secret_id_hash() {
  std::string* _s = _internal_mutable_secret_id_hash();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PairedKeyEncryptionFrame.secret_id_hash)
  return _s;
}
inline const std::string& PairedKeyEncryptionFrame::_internal_secret_id_hash() const {
  return _impl_.secret_id_hash_.Get();
}
inline void PairedKeyEncryptionFrame::_internal_set_secret_id_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.secret_id_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::_internal_mutable_secret_id_hash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.secret_id_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::release_secret_id_hash() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PairedKeyEncryptionFrame.secret_id_hash)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.secret_id_hash_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secret_id_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PairedKeyEncryptionFrame::set_allocated_secret_id_hash(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.secret_id_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_id_hash_.IsDefault()) {
          _impl_.secret_id_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PairedKeyEncryptionFrame.secret_id_hash)
}

// optional bytes optional_signed_data = 3;
inline bool PairedKeyEncryptionFrame::has_optional_signed_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PairedKeyEncryptionFrame::clear_optional_signed_data() {
  _impl_.optional_signed_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PairedKeyEncryptionFrame::optional_signed_data() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PairedKeyEncryptionFrame.optional_signed_data)
  return _internal_optional_signed_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PairedKeyEncryptionFrame::set_optional_signed_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.optional_signed_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PairedKeyEncryptionFrame.optional_signed_data)
}
inline std::string* PairedKeyEncryptionFrame::mutable_optional_signed_data() {
  std::string* _s = _internal_mutable_optional_signed_data();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PairedKeyEncryptionFrame.optional_signed_data)
  return _s;
}
inline const std::string& PairedKeyEncryptionFrame::_internal_optional_signed_data() const {
  return _impl_.optional_signed_data_.Get();
}
inline void PairedKeyEncryptionFrame::_internal_set_optional_signed_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.optional_signed_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::_internal_mutable_optional_signed_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.optional_signed_data_.Mutable( GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::release_optional_signed_data() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PairedKeyEncryptionFrame.optional_signed_data)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.optional_signed_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.optional_signed_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PairedKeyEncryptionFrame::set_allocated_optional_signed_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.optional_signed_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.optional_signed_data_.IsDefault()) {
          _impl_.optional_signed_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PairedKeyEncryptionFrame.optional_signed_data)
}

// optional bytes qr_code_handshake_data = 4;
inline bool PairedKeyEncryptionFrame::has_qr_code_handshake_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PairedKeyEncryptionFrame::clear_qr_code_handshake_data() {
  _impl_.qr_code_handshake_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PairedKeyEncryptionFrame::qr_code_handshake_data() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PairedKeyEncryptionFrame.qr_code_handshake_data)
  return _internal_qr_code_handshake_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PairedKeyEncryptionFrame::set_qr_code_handshake_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.qr_code_handshake_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PairedKeyEncryptionFrame.qr_code_handshake_data)
}
inline std::string* PairedKeyEncryptionFrame::mutable_qr_code_handshake_data() {
  std::string* _s = _internal_mutable_qr_code_handshake_data();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PairedKeyEncryptionFrame.qr_code_handshake_data)
  return _s;
}
inline const std::string& PairedKeyEncryptionFrame::_internal_qr_code_handshake_data() const {
  return _impl_.qr_code_handshake_data_.Get();
}
inline void PairedKeyEncryptionFrame::_internal_set_qr_code_handshake_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.qr_code_handshake_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::_internal_mutable_qr_code_handshake_data() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.qr_code_handshake_data_.Mutable( GetArenaForAllocation());
}
inline std::string* PairedKeyEncryptionFrame::release_qr_code_handshake_data() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PairedKeyEncryptionFrame.qr_code_handshake_data)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.qr_code_handshake_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.qr_code_handshake_data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PairedKeyEncryptionFrame::set_allocated_qr_code_handshake_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.qr_code_handshake_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.qr_code_handshake_data_.IsDefault()) {
          _impl_.qr_code_handshake_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PairedKeyEncryptionFrame.qr_code_handshake_data)
}

// -------------------------------------------------------------------

// PairedKeyResultFrame

// optional .nearby.sharing.service.proto.PairedKeyResultFrame.Status status = 1;
inline bool PairedKeyResultFrame::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PairedKeyResultFrame::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::nearby::sharing::service::proto::PairedKeyResultFrame_Status PairedKeyResultFrame::status() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PairedKeyResultFrame.status)
  return _internal_status();
}
inline void PairedKeyResultFrame::set_status(::nearby::sharing::service::proto::PairedKeyResultFrame_Status value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PairedKeyResultFrame.status)
}
inline ::nearby::sharing::service::proto::PairedKeyResultFrame_Status PairedKeyResultFrame::_internal_status() const {
  return static_cast<::nearby::sharing::service::proto::PairedKeyResultFrame_Status>(_impl_.status_);
}
inline void PairedKeyResultFrame::_internal_set_status(::nearby::sharing::service::proto::PairedKeyResultFrame_Status value) {
  assert(::nearby::sharing::service::proto::PairedKeyResultFrame_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}

// optional .location.nearby.proto.sharing.OSType os_type = 2;
inline bool PairedKeyResultFrame::has_os_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PairedKeyResultFrame::clear_os_type() {
  _impl_.os_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::location::nearby::proto::sharing::OSType PairedKeyResultFrame::os_type() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PairedKeyResultFrame.os_type)
  return _internal_os_type();
}
inline void PairedKeyResultFrame::set_os_type(::location::nearby::proto::sharing::OSType value) {
   _internal_set_os_type(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PairedKeyResultFrame.os_type)
}
inline ::location::nearby::proto::sharing::OSType PairedKeyResultFrame::_internal_os_type() const {
  return static_cast<::location::nearby::proto::sharing::OSType>(_impl_.os_type_);
}
inline void PairedKeyResultFrame::_internal_set_os_type(::location::nearby::proto::sharing::OSType value) {
  assert(::location::nearby::proto::sharing::OSType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.os_type_ = value;
}

// -------------------------------------------------------------------

// CertificateInfoFrame

// repeated .nearby.sharing.service.proto.PublicCertificate public_certificate = 1;
inline int CertificateInfoFrame::_internal_public_certificate_size() const {
  return _impl_.public_certificate_.size();
}
inline int CertificateInfoFrame::public_certificate_size() const {
  return _internal_public_certificate_size();
}
inline void CertificateInfoFrame::clear_public_certificate() {
  _internal_mutable_public_certificate()->Clear();
}
inline ::nearby::sharing::service::proto::PublicCertificate* CertificateInfoFrame::mutable_public_certificate(int index) {
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.CertificateInfoFrame.public_certificate)
  return _internal_mutable_public_certificate()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PublicCertificate >*
CertificateInfoFrame::mutable_public_certificate() {
  // @@protoc_insertion_point(field_mutable_list:nearby.sharing.service.proto.CertificateInfoFrame.public_certificate)
  return _internal_mutable_public_certificate();
}
inline const ::nearby::sharing::service::proto::PublicCertificate& CertificateInfoFrame::_internal_public_certificate(int index) const {
  return _internal_public_certificate().Get(index);
}
inline const ::nearby::sharing::service::proto::PublicCertificate& CertificateInfoFrame::public_certificate(int index) const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.CertificateInfoFrame.public_certificate)
  return _internal_public_certificate(index);
}
inline ::nearby::sharing::service::proto::PublicCertificate* CertificateInfoFrame::_internal_add_public_certificate() {
  return _internal_mutable_public_certificate()->Add();
}
inline ::nearby::sharing::service::proto::PublicCertificate* CertificateInfoFrame::add_public_certificate() {
  ::nearby::sharing::service::proto::PublicCertificate* _add = _internal_add_public_certificate();
  // @@protoc_insertion_point(field_add:nearby.sharing.service.proto.CertificateInfoFrame.public_certificate)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nearby::sharing::service::proto::PublicCertificate >&
CertificateInfoFrame::public_certificate() const {
  // @@protoc_insertion_point(field_list:nearby.sharing.service.proto.CertificateInfoFrame.public_certificate)
  return _internal_public_certificate();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PublicCertificate>&
CertificateInfoFrame::_internal_public_certificate() const {
  return _impl_.public_certificate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::nearby::sharing::service::proto::PublicCertificate>*
CertificateInfoFrame::_internal_mutable_public_certificate() {
  return &_impl_.public_certificate_;
}

// -------------------------------------------------------------------

// PublicCertificate

// optional bytes secret_id = 1;
inline bool PublicCertificate::has_secret_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PublicCertificate::clear_secret_id() {
  _impl_.secret_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublicCertificate::secret_id() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.secret_id)
  return _internal_secret_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_secret_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.secret_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.secret_id)
}
inline std::string* PublicCertificate::mutable_secret_id() {
  std::string* _s = _internal_mutable_secret_id();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PublicCertificate.secret_id)
  return _s;
}
inline const std::string& PublicCertificate::_internal_secret_id() const {
  return _impl_.secret_id_.Get();
}
inline void PublicCertificate::_internal_set_secret_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.secret_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_secret_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.secret_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_secret_id() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PublicCertificate.secret_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.secret_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secret_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PublicCertificate::set_allocated_secret_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.secret_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_id_.IsDefault()) {
          _impl_.secret_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PublicCertificate.secret_id)
}

// optional bytes authenticity_key = 2;
inline bool PublicCertificate::has_authenticity_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PublicCertificate::clear_authenticity_key() {
  _impl_.authenticity_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PublicCertificate::authenticity_key() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.authenticity_key)
  return _internal_authenticity_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_authenticity_key(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.authenticity_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.authenticity_key)
}
inline std::string* PublicCertificate::mutable_authenticity_key() {
  std::string* _s = _internal_mutable_authenticity_key();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PublicCertificate.authenticity_key)
  return _s;
}
inline const std::string& PublicCertificate::_internal_authenticity_key() const {
  return _impl_.authenticity_key_.Get();
}
inline void PublicCertificate::_internal_set_authenticity_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.authenticity_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_authenticity_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.authenticity_key_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_authenticity_key() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PublicCertificate.authenticity_key)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.authenticity_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.authenticity_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PublicCertificate::set_allocated_authenticity_key(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.authenticity_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.authenticity_key_.IsDefault()) {
          _impl_.authenticity_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PublicCertificate.authenticity_key)
}

// optional bytes public_key = 3;
inline bool PublicCertificate::has_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PublicCertificate::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PublicCertificate::public_key() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_public_key(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.public_key)
}
inline std::string* PublicCertificate::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PublicCertificate.public_key)
  return _s;
}
inline const std::string& PublicCertificate::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void PublicCertificate::_internal_set_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_public_key() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.public_key_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_public_key() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PublicCertificate.public_key)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.public_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PublicCertificate::set_allocated_public_key(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.public_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.public_key_.IsDefault()) {
          _impl_.public_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PublicCertificate.public_key)
}

// optional int64 start_time = 4;
inline bool PublicCertificate::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PublicCertificate::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t PublicCertificate::start_time() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.start_time)
  return _internal_start_time();
}
inline void PublicCertificate::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.start_time)
}
inline ::int64_t PublicCertificate::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void PublicCertificate::_internal_set_start_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.start_time_ = value;
}

// optional int64 end_time = 5;
inline bool PublicCertificate::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PublicCertificate::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t PublicCertificate::end_time() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.end_time)
  return _internal_end_time();
}
inline void PublicCertificate::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.end_time)
}
inline ::int64_t PublicCertificate::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void PublicCertificate::_internal_set_end_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.end_time_ = value;
}

// optional bytes encrypted_metadata_bytes = 6;
inline bool PublicCertificate::has_encrypted_metadata_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PublicCertificate::clear_encrypted_metadata_bytes() {
  _impl_.encrypted_metadata_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PublicCertificate::encrypted_metadata_bytes() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.encrypted_metadata_bytes)
  return _internal_encrypted_metadata_bytes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_encrypted_metadata_bytes(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.encrypted_metadata_bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.encrypted_metadata_bytes)
}
inline std::string* PublicCertificate::mutable_encrypted_metadata_bytes() {
  std::string* _s = _internal_mutable_encrypted_metadata_bytes();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PublicCertificate.encrypted_metadata_bytes)
  return _s;
}
inline const std::string& PublicCertificate::_internal_encrypted_metadata_bytes() const {
  return _impl_.encrypted_metadata_bytes_.Get();
}
inline void PublicCertificate::_internal_set_encrypted_metadata_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.encrypted_metadata_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_encrypted_metadata_bytes() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.encrypted_metadata_bytes_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_encrypted_metadata_bytes() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PublicCertificate.encrypted_metadata_bytes)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.encrypted_metadata_bytes_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encrypted_metadata_bytes_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PublicCertificate::set_allocated_encrypted_metadata_bytes(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.encrypted_metadata_bytes_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encrypted_metadata_bytes_.IsDefault()) {
          _impl_.encrypted_metadata_bytes_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PublicCertificate.encrypted_metadata_bytes)
}

// optional bytes metadata_encryption_key_tag = 7;
inline bool PublicCertificate::has_metadata_encryption_key_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PublicCertificate::clear_metadata_encryption_key_tag() {
  _impl_.metadata_encryption_key_tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PublicCertificate::metadata_encryption_key_tag() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.PublicCertificate.metadata_encryption_key_tag)
  return _internal_metadata_encryption_key_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublicCertificate::set_metadata_encryption_key_tag(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.metadata_encryption_key_tag_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.PublicCertificate.metadata_encryption_key_tag)
}
inline std::string* PublicCertificate::mutable_metadata_encryption_key_tag() {
  std::string* _s = _internal_mutable_metadata_encryption_key_tag();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.PublicCertificate.metadata_encryption_key_tag)
  return _s;
}
inline const std::string& PublicCertificate::_internal_metadata_encryption_key_tag() const {
  return _impl_.metadata_encryption_key_tag_.Get();
}
inline void PublicCertificate::_internal_set_metadata_encryption_key_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.metadata_encryption_key_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicCertificate::_internal_mutable_metadata_encryption_key_tag() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.metadata_encryption_key_tag_.Mutable( GetArenaForAllocation());
}
inline std::string* PublicCertificate::release_metadata_encryption_key_tag() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.PublicCertificate.metadata_encryption_key_tag)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.metadata_encryption_key_tag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.metadata_encryption_key_tag_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PublicCertificate::set_allocated_metadata_encryption_key_tag(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.metadata_encryption_key_tag_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metadata_encryption_key_tag_.IsDefault()) {
          _impl_.metadata_encryption_key_tag_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.PublicCertificate.metadata_encryption_key_tag)
}

// -------------------------------------------------------------------

// WifiCredentials

// optional string password = 1;
inline bool WifiCredentials::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WifiCredentials::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WifiCredentials::password() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.WifiCredentials.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WifiCredentials::set_password(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.WifiCredentials.password)
}
inline std::string* WifiCredentials::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:nearby.sharing.service.proto.WifiCredentials.password)
  return _s;
}
inline const std::string& WifiCredentials::_internal_password() const {
  return _impl_.password_.Get();
}
inline void WifiCredentials::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* WifiCredentials::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.password_.Mutable( GetArenaForAllocation());
}
inline std::string* WifiCredentials::release_password() {
  // @@protoc_insertion_point(field_release:nearby.sharing.service.proto.WifiCredentials.password)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.password_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void WifiCredentials::set_allocated_password(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.password_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nearby.sharing.service.proto.WifiCredentials.password)
}

// optional bool hidden_ssid = 2 [default = false];
inline bool WifiCredentials::has_hidden_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WifiCredentials::clear_hidden_ssid() {
  _impl_.hidden_ssid_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool WifiCredentials::hidden_ssid() const {
  // @@protoc_insertion_point(field_get:nearby.sharing.service.proto.WifiCredentials.hidden_ssid)
  return _internal_hidden_ssid();
}
inline void WifiCredentials::set_hidden_ssid(bool value) {
  _internal_set_hidden_ssid(value);
  // @@protoc_insertion_point(field_set:nearby.sharing.service.proto.WifiCredentials.hidden_ssid)
}
inline bool WifiCredentials::_internal_hidden_ssid() const {
  return _impl_.hidden_ssid_;
}
inline void WifiCredentials::_internal_set_hidden_ssid(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hidden_ssid_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace service
}  // namespace sharing
}  // namespace nearby


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::nearby::sharing::service::proto::FileMetadata_Type> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::TextMetadata_Type> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::WifiCredentialsMetadata_SecurityType> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::Frame_Version> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::V1Frame_FrameType> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::ConnectionResponseFrame_Status> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::AttachmentDetails_Type> : std::true_type {};
template <>
struct is_proto_enum<::nearby::sharing::service::proto::PairedKeyResultFrame_Status> : std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sharing_2fproto_2fwire_5fformat_2eproto_2epb_2eh
