// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#include "payload_w.h"

#include <cstddef>
#include <cstdint>
#include <memory>
#include <utility>

#include "file_w.h"
#include "connections/payload.h"
#include "connections/payload_type.h"
#include "internal/platform/byte_array.h"
#include "internal/platform/input_stream.h"
#include "internal/platform/payload_id.h"



namespace nearby {
// Must implement Deleter since Payload wasn't fully defined in
// the header
namespace connections {
class Payload;
void PayloadDeleter::operator()(connections::Payload *p) { delete p; }

}  // namespace connections
namespace windows {


    //struct InputFile {
    //    InputFile() = default;
    //    explicit InputFile(std::filesystem::path path) { this->path = path; }

    //    std::filesystem::path path;
    //};

    //// A simple payload containing raw bytes.
    //struct BytesPayload {
    //    // The bytes of this payload.
    //    std::vector<uint8_t> bytes;
    //};

    //// A file payload representing a file.
    //struct FilePayload {
    //    // The file to which this payload points to. When sending this payload, the
    //    // NearbyConnections library reads from this file. When receiving a file
    //    // payload it writes to this file.
    //    InputFile file;
    //    int64_t size;
    //    std::string parent_folder;
    //};

    //// Union of all supported payload types.
    //struct PayloadContent {
    //    // A Payload consisting of a single byte array.
    //    BytesPayload bytes_payload;
    //    // A Payload representing a file on the device.
    //    FilePayload file_payload;
    //    enum class Type { kUnknown = 0, kBytes = 1, kStream = 2, kFile = 3 };
    //    Type type;
    //    bool is_bytes() { return type == Type::kBytes; }
    //    bool is_file() { return type == Type::kFile; }
    //    bool is_stream() { return type == Type::kStream; }
    //};

    //// A Payload sent between devices. Payloads sent with a particular content type
    //// will be received as that same type on the other device, e.g. the content for
    //// a Payload of type BytesPayload must be received by reading from the bytes
    //// field returned by Payload::content::bytes.
    //struct Payload {
    //    // A unique identifier for this payload. Generated by the sender of the
    //    // payload and used to keep track of the transfer progress.
    //    int64_t id;
    //    // The content of this payload which is one of multiple types, see
    //    // PayloadContent for all possible types.
    //    PayloadContent content;

    //    Payload() = default;
    //    explicit Payload(std::vector<uint8_t> bytes)
    //        : Payload(GenerateId(), std::move(bytes)) {}

    //    explicit Payload(InputFile file,
    //        absl::string_view parent_folder = absl::string_view()) {
    //        id = std::hash<std::string>()(GetCompatibleU8String(file.path.u8string()));

    //        content.type = PayloadContent::Type::kFile;
    //        if (std::filesystem::exists(file.path)) {
    //            content.file_payload.size = std::filesystem::file_size(file.path);
    //        }

    //        content.file_payload.file = std::move(file);
    //        content.file_payload.parent_folder = std::string(parent_folder);
    //    }

    //    Payload(int64_t id, std::vector<uint8_t> bytes) : id(id) {
    //        content.type = PayloadContent::Type::kBytes;
    //        content.bytes_payload.bytes = std::move(bytes);
    //    }

    //    Payload(int64_t id, InputFile file,
    //        absl::string_view parent_folder = absl::string_view())
    //        : id(id) {
    //        content.type = PayloadContent::Type::kFile;
    //        if (std::filesystem::exists(file.path)) {
    //            content.file_payload.size = std::filesystem::file_size(file.path);
    //        }

    //        content.file_payload.file = std::move(file);
    //        content.file_payload.parent_folder = std::string(parent_folder);
    //    }

    //    Payload(char* bytes, int size)
    //        : Payload(GenerateId(), std::vector<uint8_t>(bytes, bytes + size)) {}

    //    int64_t GenerateId() {
    //        int64_t id;
    //        crypto::RandBytes(&id, sizeof(id));
    //        return id;
    //    }
    //};

PayloadW::PayloadW()
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload())) {}

PayloadW::~PayloadW() = default;
PayloadW::PayloadW(PayloadW &&other) noexcept : impl_(std::move(other.impl_)) {}

PayloadW &PayloadW::operator=(PayloadW &&other) noexcept {
  impl_ = std::move(other.impl_);
  return *this;
}

// Constructors for outgoing payloads.
PayloadW::PayloadW(const char *bytes, const size_t bytes_size)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(ByteArray(bytes, bytes_size)))) {}

PayloadW::PayloadW(InputFileW &file)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(InputFile(std::move(*file.GetImpl()))))) {}

PayloadW::PayloadW(std::unique_ptr<InputStream> stream)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(std::move(stream)))) {}

// Constructors for incoming payloads.
PayloadW::PayloadW(PayloadId id, const char *bytes, const size_t bytes_size)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(id, ByteArray(bytes, bytes_size)))) {}

PayloadW::PayloadW(PayloadId id, InputFileW file)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(id, std::move(*file.GetImpl())))) {}

PayloadW::PayloadW(const char *parent_folder, const char *file_name,
                   InputFileW file)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(parent_folder, file_name,
                                   std::move(*file.GetImpl())))) {}

PayloadW::PayloadW(PayloadId id, std::unique_ptr<InputStream> stream)
    : impl_(std::unique_ptr<connections::Payload, connections::PayloadDeleter>(
          new connections::Payload(id, std::move(stream)))) {}

// Returns ByteArray payload, if it has been defined, or empty ByteArray.
bool PayloadW::AsBytes(const char *&bytes, size_t &bytes_size) const & {
  auto byteArray = impl_->AsBytes();
  if (bytes_size < byteArray.size()) {
    bytes_size = byteArray.size();
    bytes = nullptr;
    return false;
  }

  bytes_size = byteArray.size();
  bytes = byteArray.data();
  return true;
}
bool PayloadW::AsBytes(const char *&bytes, size_t &bytes_size) && {
  auto byteArray = impl_->AsBytes();
  if (bytes_size < byteArray.size()) {
    bytes_size = byteArray.size();
    bytes = nullptr;
    return false;
  }

  bytes_size = byteArray.size();
  bytes = byteArray.data();
  return true;
}
// Returns InputStream* payload, if it has been defined, or nullptr.
InputStream *PayloadW::AsStream() { return impl_->AsStream(); }
// Returns InputFile* payload, if it has been defined, or nullptr.
InputFile *PayloadW::AsFile() const { return impl_->AsFile(); }

// Returns Payload unique ID.
int64_t PayloadW::GetId() const { return impl_->GetId(); }

// Returns Payload type.
const connections::PayloadType PayloadW::GetType() const {
  return static_cast<connections::PayloadType>(impl_->GetType());
}

// Sets the payload offset in bytes
void PayloadW::SetOffset(size_t offset) { impl_->SetOffset(offset); }

size_t PayloadW::GetOffset() { return impl_->GetOffset(); }

// Generate Payload Id; to be passed to outgoing file constructor.
PayloadId PayloadW::GenerateId() { return connections::Payload::GenerateId(); }

const char *PayloadW::GetParentFolder() const { return nullptr; }

const char *PayloadW::GetFileName() const { return nullptr; }

std::unique_ptr<connections::Payload, connections::PayloadDeleter>
PayloadW::GetImpl() {
  return std::move(impl_);
}

}  // namespace windows
}  // namespace nearby
